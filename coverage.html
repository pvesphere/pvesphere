
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">pvesphere/internal/handler/dashboard.go (0.0%)</option>
				
				<option value="file1">pvesphere/internal/handler/handler.go (80.0%)</option>
				
				<option value="file2">pvesphere/internal/handler/pve_auth.go (0.0%)</option>
				
				<option value="file3">pvesphere/internal/handler/pve_cluster.go (0.0%)</option>
				
				<option value="file4">pvesphere/internal/handler/pve_node.go (0.0%)</option>
				
				<option value="file5">pvesphere/internal/handler/pve_storage.go (0.0%)</option>
				
				<option value="file6">pvesphere/internal/handler/pve_task.go (0.0%)</option>
				
				<option value="file7">pvesphere/internal/handler/pve_template.go (0.0%)</option>
				
				<option value="file8">pvesphere/internal/handler/pve_vm.go (0.0%)</option>
				
				<option value="file9">pvesphere/internal/handler/template_management.go (0.0%)</option>
				
				<option value="file10">pvesphere/internal/handler/user.go (43.1%)</option>
				
				<option value="file11">pvesphere/internal/repository/pve_cluster.go (0.0%)</option>
				
				<option value="file12">pvesphere/internal/repository/pve_node.go (0.0%)</option>
				
				<option value="file13">pvesphere/internal/repository/pve_storage.go (0.0%)</option>
				
				<option value="file14">pvesphere/internal/repository/pve_template.go (0.0%)</option>
				
				<option value="file15">pvesphere/internal/repository/pve_vm.go (0.0%)</option>
				
				<option value="file16">pvesphere/internal/repository/repository.go (8.2%)</option>
				
				<option value="file17">pvesphere/internal/repository/template_instance.go (0.0%)</option>
				
				<option value="file18">pvesphere/internal/repository/template_sync_task.go (0.0%)</option>
				
				<option value="file19">pvesphere/internal/repository/template_upload.go (0.0%)</option>
				
				<option value="file20">pvesphere/internal/repository/user.go (57.9%)</option>
				
				<option value="file21">pvesphere/internal/repository/vm_ipaddress.go (0.0%)</option>
				
				<option value="file22">pvesphere/internal/repository/vm_template.go (0.0%)</option>
				
				<option value="file23">pvesphere/internal/service/dashboard.go (0.0%)</option>
				
				<option value="file24">pvesphere/internal/service/pve_cluster.go (0.0%)</option>
				
				<option value="file25">pvesphere/internal/service/pve_node.go (0.0%)</option>
				
				<option value="file26">pvesphere/internal/service/pve_storage.go (0.0%)</option>
				
				<option value="file27">pvesphere/internal/service/pve_task.go (0.0%)</option>
				
				<option value="file28">pvesphere/internal/service/pve_template.go (0.0%)</option>
				
				<option value="file29">pvesphere/internal/service/pve_vm.go (0.0%)</option>
				
				<option value="file30">pvesphere/internal/service/service.go (100.0%)</option>
				
				<option value="file31">pvesphere/internal/service/template_management.go (0.0%)</option>
				
				<option value="file32">pvesphere/internal/service/user.go (64.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handler

import (
        "net/http"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type DashboardHandler struct {
        *Handler
        dashboardService service.DashboardService
}

func NewDashboardHandler(handler *Handler, dashboardService service.DashboardService) *DashboardHandler <span class="cov0" title="0">{
        return &amp;DashboardHandler{
                Handler:          handler,
                dashboardService: dashboardService,
        }
}</span>

// GetScopes godoc
// @Summary 获取可选集群列表
// @Tags Dashboard模块
// @Accept json
// @Produce json
// @Security Bearer
// @Success 200 {object} v1.DashboardScopesResponse
// @Router /api/v1/dashboard/scopes [get]
func (h *DashboardHandler) GetScopes(ctx *gin.Context) <span class="cov0" title="0">{
        data, err := h.dashboardService.GetScopes(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("dashboardService.GetScopes error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetOverview godoc
// @Summary 获取全局概览
// @Tags Dashboard模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param scope query string false "范围: all 或 cluster" default(all)
// @Param cluster_id query int false "集群ID（当 scope 为 cluster 时使用）"
// @Success 200 {object} v1.DashboardOverviewResponse
// @Router /api/v1/dashboard/overview [get]
func (h *DashboardHandler) GetOverview(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.DashboardOverviewRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Scope == "" </span><span class="cov0" title="0">{
                req.Scope = "all"
        }</span>

        <span class="cov0" title="0">data, err := h.dashboardService.GetOverview(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("dashboardService.GetOverview error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetResources godoc
// @Summary 获取资源使用率
// @Tags Dashboard模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param scope query string false "范围: all 或 cluster" default(all)
// @Param cluster_id query int false "集群ID（当 scope 为 cluster 时使用）"
// @Success 200 {object} v1.DashboardResourcesResponse
// @Router /api/v1/dashboard/resources [get]
func (h *DashboardHandler) GetResources(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.DashboardResourcesRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Scope == "" </span><span class="cov0" title="0">{
                req.Scope = "all"
        }</span>

        <span class="cov0" title="0">data, err := h.dashboardService.GetResources(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("dashboardService.GetResources error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetHotspots godoc
// @Summary 获取压力和风险焦点
// @Tags Dashboard模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param scope query string false "范围: all 或 cluster" default(all)
// @Param cluster_id query int false "集群ID（当 scope 为 cluster 时使用）"
// @Param limit query int false "Top N 数量" default(5)
// @Success 200 {object} v1.DashboardHotspotsResponse
// @Router /api/v1/dashboard/hotspots [get]
func (h *DashboardHandler) GetHotspots(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.DashboardHotspotsRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Scope == "" </span><span class="cov0" title="0">{
                req.Scope = "all"
        }</span>
        <span class="cov0" title="0">if req.Limit &lt;= 0 </span><span class="cov0" title="0">{
                req.Limit = 5
        }</span>

        <span class="cov0" title="0">data, err := h.dashboardService.GetHotspots(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("dashboardService.GetHotspots error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetOperations godoc
// @Summary 获取运行中的操作
// @Tags Dashboard模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param scope query string false "范围: all 或 cluster" default(all)
// @Param cluster_id query int false "集群ID（当 scope 为 cluster 时使用）"
// @Success 200 {object} v1.DashboardOperationsResponse
// @Router /api/v1/dashboard/operations [get]
func (h *DashboardHandler) GetOperations(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.DashboardOperationsRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Scope == "" </span><span class="cov0" title="0">{
                req.Scope = "all"
        }</span>

        <span class="cov0" title="0">data, err := h.dashboardService.GetOperations(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("dashboardService.GetOperations error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "github.com/gin-gonic/gin"
        "pvesphere/pkg/jwt"
        "pvesphere/pkg/log"
)

type Handler struct {
        logger *log.Logger
}

func NewHandler(
        logger *log.Logger,
) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                logger: logger,
        }
}</span>
func GetUserIdFromCtx(ctx *gin.Context) string <span class="cov8" title="1">{
        v, exists := ctx.Get("claims")
        if !exists </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return v.(*jwt.MyCustomClaims).UserId</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "net/http"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"
        "pvesphere/pkg/proxmox"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type PveAuthHandler struct {
        *Handler
        clusterService service.PveClusterService
}

func NewPveAuthHandler(handler *Handler, clusterService service.PveClusterService) *PveAuthHandler <span class="cov0" title="0">{
        return &amp;PveAuthHandler{
                Handler:        handler,
                clusterService: clusterService,
        }
}</span>

// GetAccessTicket godoc
// @Summary 获取 Proxmox 高权限票据（/access/ticket）
// @Description 按照 Proxmox 原生 /api2/json/access/ticket 接口封装，使用用户名/密码获取 ticket 和 CSRFPreventionToken。api_url 从集群表中根据 cluster_id 获取。
// @Tags PVE认证模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.GetAccessTicketRequest true "params"
// @Success 200 {object} v1.GetAccessTicketResponse
// @Router /api/v1/pve/access/ticket [post]
func (h *PveAuthHandler) GetAccessTicket(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetAccessTicketRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 通过 cluster_id 获取集群信息，提取 api_url
        <span class="cov0" title="0">cluster, err := h.clusterService.GetCluster(ctx, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err), zap.Int64("cluster_id", req.ClusterID))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusNotFound, v1.ErrNotFound, nil)
                return
        }</span>

        // 使用集群的 api_url 调用 Proxmox 接口
        <span class="cov0" title="0">result, err := proxmox.GetAccessTicket(ctx, cluster.ApiUrl, req.Username, req.Realm, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("failed to get proxmox access ticket", zap.Error(err),
                        zap.Int64("cluster_id", req.ClusterID),
                        zap.String("api_url", cluster.ApiUrl))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "username":            result.Username,
                "ticket":              result.Ticket,
                "CSRFPreventionToken": result.CSRFPreventionToken,
        }

        v1.HandleSuccess(ctx, data)</span>
}


</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "strconv"

        "net/http"
        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type PveClusterHandler struct {
        *Handler
        clusterService service.PveClusterService
}

func NewPveClusterHandler(handler *Handler, clusterService service.PveClusterService) *PveClusterHandler <span class="cov0" title="0">{
        return &amp;PveClusterHandler{
                Handler:        handler,
                clusterService: clusterService,
        }
}</span>

// CreateCluster godoc
// @Summary 创建集群
// @Tags PVE集群模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.CreateClusterRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/clusters [post]
func (h *PveClusterHandler) CreateCluster(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.CreateClusterRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.clusterService.CreateCluster(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("clusterService.CreateCluster error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// UpdateCluster godoc
// @Summary 更新集群
// @Tags PVE集群模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "集群ID"
// @Param request body v1.UpdateClusterRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/clusters/{id} [put]
func (h *PveClusterHandler) UpdateCluster(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">req := new(v1.UpdateClusterRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.clusterService.UpdateCluster(ctx, id, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("clusterService.UpdateCluster error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// DeleteCluster godoc
// @Summary 删除集群
// @Tags PVE集群模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "集群ID"
// @Success 200 {object} v1.Response
// @Router /api/v1/clusters/{id} [delete]
func (h *PveClusterHandler) DeleteCluster(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.clusterService.DeleteCluster(ctx, id); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("clusterService.DeleteCluster error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetCluster godoc
// @Summary 获取集群详情
// @Tags PVE集群模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "集群ID"
// @Success 200 {object} v1.GetClusterResponse
// @Router /api/v1/clusters/{id} [get]
func (h *PveClusterHandler) GetCluster(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">cluster, err := h.clusterService.GetCluster(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("clusterService.GetCluster error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, cluster)</span>
}

// ListClusters godoc
// @Summary 获取集群列表
// @Tags PVE集群模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param page query int false "页码" default(1)
// @Param page_size query int false "每页数量" default(10)
// @Param env query string false "环境"
// @Param region query string false "区域"
// @Success 200 {object} v1.ListClusterResponse
// @Router /api/v1/clusters [get]
func (h *PveClusterHandler) ListClusters(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.ListClusterRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>
        // 验证 PageSize 最大值
        <span class="cov0" title="0">if req.PageSize &gt; 100 </span><span class="cov0" title="0">{
                req.PageSize = 100
        }</span>

        <span class="cov0" title="0">data, err := h.clusterService.ListClusters(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("clusterService.ListClusters error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetClusterStatus godoc
// @Summary 获取集群状态
// @Tags PVE集群模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param cluster_id query int true "集群ID"
// @Success 200 {object} v1.GetClusterStatusResponse
// @Router /api/v1/clusters/status [get]
func (h *PveClusterHandler) GetClusterStatus(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetClusterStatusRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">status, err := h.clusterService.GetClusterStatus(ctx, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("clusterService.GetClusterStatus error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, status)</span>
}

// GetClusterResources godoc
// @Summary 获取集群资源
// @Tags PVE集群模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param cluster_id query int true "集群ID"
// @Success 200 {object} v1.GetClusterResourcesResponse
// @Router /api/v1/clusters/resources [get]
func (h *PveClusterHandler) GetClusterResources(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetClusterResourcesRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">resources, err := h.clusterService.GetClusterResources(ctx, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("clusterService.GetClusterResources error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, resources)</span>
}

// VerifyCluster godoc
// @Summary 验证集群连接
// @Description 通过调用 Proxmox /api2/json/version 接口验证集群连接和认证是否正常。支持两种验证方式：1. 通过 cluster_id 验证（从数据库获取集群信息）；2. 通过 api_url + user_id + user_token 直接验证（不依赖数据库）
// @Tags PVE集群模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param cluster_id query int false "集群ID（与 api_url+user_id+user_token 二选一）"
// @Param api_url query string false "API地址（与 cluster_id 二选一）"
// @Param user_id query string false "用户ID（与 cluster_id 二选一）"
// @Param user_token query string false "用户Token（与 cluster_id 二选一）"
// @Success 200 {object} v1.VerifyClusterResponse
// @Router /api/v1/clusters/verify [get]
func (h *PveClusterHandler) VerifyCluster(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.VerifyClusterRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 验证参数：必须提供 cluster_id 或者 (api_url + user_id + user_token)
        <span class="cov0" title="0">if req.ClusterID == nil &amp;&amp; (req.ApiUrl == "" || req.UserId == "" || req.UserToken == "") </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">var data *v1.VerifyClusterData
        var err error

        if req.ClusterID != nil </span><span class="cov0" title="0">{
                // 方式1：通过 cluster_id 验证
                data, err = h.clusterService.VerifyCluster(ctx, req.ClusterID)
        }</span> else<span class="cov0" title="0"> {
                // 方式2：通过 api_url + user_id + user_token 直接验证
                data, err = h.clusterService.VerifyClusterWithCredentials(ctx, req.ApiUrl, req.UserId, req.UserToken)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("clusterService.VerifyCluster error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "fmt"
        "net/http"
        "net/url"
        "strconv"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

type PveNodeHandler struct {
        *Handler
        nodeService service.PveNodeService
}

func NewPveNodeHandler(handler *Handler, nodeService service.PveNodeService) *PveNodeHandler <span class="cov0" title="0">{
        return &amp;PveNodeHandler{
                Handler:     handler,
                nodeService: nodeService,
        }
}</span>

// CreateNode godoc
// @Summary 创建节点
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.CreateNodeRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/nodes [post]
func (h *PveNodeHandler) CreateNode(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.CreateNodeRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.nodeService.CreateNode(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.CreateNode error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// UpdateNode godoc
// @Summary 更新节点
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "节点ID"
// @Param request body v1.UpdateNodeRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/nodes/{id} [put]
func (h *PveNodeHandler) UpdateNode(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">req := new(v1.UpdateNodeRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.nodeService.UpdateNode(ctx, id, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.UpdateNode error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// DeleteNode godoc
// @Summary 删除节点
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "节点ID"
// @Success 200 {object} v1.Response
// @Router /api/v1/nodes/{id} [delete]
func (h *PveNodeHandler) DeleteNode(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.nodeService.DeleteNode(ctx, id); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.DeleteNode error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetNode godoc
// @Summary 获取节点详情
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "节点ID"
// @Success 200 {object} v1.GetNodeResponse
// @Router /api/v1/nodes/{id} [get]
func (h *PveNodeHandler) GetNode(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">node, err := h.nodeService.GetNode(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNode error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, node)</span>
}

// ListNodes godoc
// @Summary 获取节点列表
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param page query int false "页码" default(1)
// @Param page_size query int false "每页数量" default(10)
// @Param cluster_id query int false "集群ID"
// @Param env query string false "环境"
// @Param status query string false "状态"
// @Success 200 {object} v1.ListNodeResponse
// @Router /api/v1/nodes [get]
func (h *PveNodeHandler) ListNodes(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.ListNodeRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>
        // 验证 PageSize 最大值
        <span class="cov0" title="0">if req.PageSize &gt; 100 </span><span class="cov0" title="0">{
                req.PageSize = 100
        }</span>

        <span class="cov0" title="0">data, err := h.nodeService.ListNodes(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.ListNodes error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetNodeStatus godoc
// @Summary 获取节点状态
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Success 200 {object} v1.GetNodeStatusResponse
// @Router /api/v1/nodes/status [get]
func (h *PveNodeHandler) GetNodeStatus(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeStatusRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">status, err := h.nodeService.GetNodeStatus(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeStatus error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, status)</span>
}

// SetNodeStatus godoc
// @Summary 设置节点状态（重启/关闭）
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.SetNodeStatusRequest true "params"
// @Success 200 {object} v1.SetNodeStatusResponse
// @Router /api/v1/nodes/status [post]
func (h *PveNodeHandler) SetNodeStatus(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.SetNodeStatusRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">upid, err := h.nodeService.SetNodeStatus(ctx, req.NodeID, req.Command)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.SetNodeStatus error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, map[string]interface{}{
                "upid": upid,
        })</span>
}

// GetNodeServices godoc
// @Summary 获取节点服务列表
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Success 200 {object} v1.GetNodeServicesResponse
// @Router /api/v1/nodes/services [get]
func (h *PveNodeHandler) GetNodeServices(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeServicesRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">services, err := h.nodeService.GetNodeServices(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeServices error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, services)</span>
}

// StartNodeService godoc
// @Summary 启动节点服务
// @Description 启动指定的节点服务
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.StartNodeServiceRequest true "启动服务请求"
// @Success 200 {object} v1.StartNodeServiceResponse
// @Router /api/v1/nodes/services/start [post]
func (h *PveNodeHandler) StartNodeService(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.StartNodeServiceRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("StartNodeService bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">upid, err := h.nodeService.StartNodeService(ctx, req.NodeID, req.ServiceName)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.StartNodeService error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, map[string]interface{}{
                "upid": upid,
        })</span>
}

// StopNodeService godoc
// @Summary 停止节点服务
// @Description 停止指定的节点服务
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.StopNodeServiceRequest true "停止服务请求"
// @Success 200 {object} v1.StopNodeServiceResponse
// @Router /api/v1/nodes/services/stop [post]
func (h *PveNodeHandler) StopNodeService(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.StopNodeServiceRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("StopNodeService bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">upid, err := h.nodeService.StopNodeService(ctx, req.NodeID, req.ServiceName)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.StopNodeService error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, map[string]interface{}{
                "upid": upid,
        })</span>
}

// RestartNodeService godoc
// @Summary 重启节点服务
// @Description 重启指定的节点服务
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.RestartNodeServiceRequest true "重启服务请求"
// @Success 200 {object} v1.RestartNodeServiceResponse
// @Router /api/v1/nodes/services/restart [post]
func (h *PveNodeHandler) RestartNodeService(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.RestartNodeServiceRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("RestartNodeService bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">upid, err := h.nodeService.RestartNodeService(ctx, req.NodeID, req.ServiceName)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.RestartNodeService error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, map[string]interface{}{
                "upid": upid,
        })</span>
}

// GetNodeNetworks godoc
// @Summary 获取节点网络列表
// @Description 列出节点的可用网络配置
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Success 200 {object} v1.GetNodeNetworksResponse
// @Router /api/v1/nodes/network [get]
func (h *PveNodeHandler) GetNodeNetworks(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeNetworksRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("GetNodeNetworks bind query error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">networks, err := h.nodeService.GetNodeNetworks(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeNetworks error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, networks)</span>
}

// CreateNodeNetwork godoc
// @Summary 创建网络设备配置
// @Description 创建或更新节点的网络设备配置
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.CreateNodeNetworkRequest true "创建网络配置请求"
// @Success 200 {object} v1.CreateNodeNetworkResponse
// @Router /api/v1/nodes/network [post]
func (h *PveNodeHandler) CreateNodeNetwork(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.CreateNodeNetworkRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("CreateNodeNetwork bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.nodeService.CreateNodeNetwork(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.CreateNodeNetwork error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// ReloadNodeNetwork godoc
// @Summary 重新加载网络配置
// @Description 重新加载节点的网络配置
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.ReloadNodeNetworkRequest true "重新加载网络配置请求"
// @Success 200 {object} v1.ReloadNodeNetworkResponse
// @Router /api/v1/nodes/network [put]
func (h *PveNodeHandler) ReloadNodeNetwork(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.ReloadNodeNetworkRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("ReloadNodeNetwork bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.nodeService.ReloadNodeNetwork(ctx, req.NodeID); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.ReloadNodeNetwork error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// RevertNodeNetwork godoc
// @Summary 恢复网络配置更改
// @Description 恢复节点的网络配置更改
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.RevertNodeNetworkRequest true "恢复网络配置请求"
// @Success 200 {object} v1.RevertNodeNetworkResponse
// @Router /api/v1/nodes/network [delete]
func (h *PveNodeHandler) RevertNodeNetwork(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.RevertNodeNetworkRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("RevertNodeNetwork bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.nodeService.RevertNodeNetwork(ctx, req.NodeID); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.RevertNodeNetwork error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetNodeRRDData godoc
// @Summary 获取节点RRD监控数据
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Param timeframe query string true "时间范围" Enums(hour, day, week, month, year)
// @Param cf query string true "聚合函数" Enums(AVERAGE, MAX)
// @Success 200 {object} v1.GetNodeRRDDataResponse
// @Router /api/v1/nodes/rrd [get]
func (h *PveNodeHandler) GetNodeRRDData(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeRRDDataRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">rrdData, err := h.nodeService.GetNodeRRDData(ctx, req.NodeID, req.Timeframe, req.Cf)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeRRDData error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, rrdData)</span>
}

// GetNodeDisksList godoc
// @Summary 获取节点磁盘列表
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Param include_partitions query bool false "是否包含分区信息" default(false)
// @Success 200 {object} v1.GetNodeDisksListResponse
// @Router /api/v1/nodes/disks/list [get]
func (h *PveNodeHandler) GetNodeDisksList(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeDisksListRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">disks, err := h.nodeService.GetNodeDisksList(ctx, req.NodeID, req.IncludePartitions)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeDisksList error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, disks)</span>
}

// GetNodeDisksDirectory godoc
// @Summary 获取节点 Directory 存储
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Success 200 {object} v1.GetNodeDisksDirectoryResponse
// @Router /api/v1/nodes/disks/directory [get]
func (h *PveNodeHandler) GetNodeDisksDirectory(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeDisksDirectoryRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">directories, err := h.nodeService.GetNodeDisksDirectory(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeDisksDirectory error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, directories)</span>
}

// GetNodeDisksLVM godoc
// @Summary 获取节点 LVM 存储
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Success 200 {object} v1.GetNodeDisksLVMResponse
// @Router /api/v1/nodes/disks/lvm [get]
func (h *PveNodeHandler) GetNodeDisksLVM(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeDisksLVMRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">lvms, err := h.nodeService.GetNodeDisksLVM(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeDisksLVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, lvms)</span>
}

// GetNodeDisksLVMThin godoc
// @Summary 获取节点 LVM-Thin 存储
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Success 200 {object} v1.GetNodeDisksLVMThinResponse
// @Router /api/v1/nodes/disks/lvmthin [get]
func (h *PveNodeHandler) GetNodeDisksLVMThin(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeDisksLVMThinRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">lvmthins, err := h.nodeService.GetNodeDisksLVMThin(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeDisksLVMThin error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, lvmthins)</span>
}

// GetNodeDisksZFS godoc
// @Summary 获取节点 ZFS 存储
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Success 200 {object} v1.GetNodeDisksZFSResponse
// @Router /api/v1/nodes/disks/zfs [get]
func (h *PveNodeHandler) GetNodeDisksZFS(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeDisksZFSRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">zfss, err := h.nodeService.GetNodeDisksZFS(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeDisksZFS error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, zfss)</span>
}

// InitGPTDisk godoc
// @Summary 初始化 GPT 磁盘
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.InitGPTDiskRequest true "params"
// @Success 200 {object} v1.InitGPTDiskResponse
// @Router /api/v1/nodes/disks/initgpt [post]
func (h *PveNodeHandler) InitGPTDisk(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.InitGPTDiskRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">upid, err := h.nodeService.InitGPTDisk(ctx, req.NodeID, req.Disk)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.InitGPTDisk error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, upid)</span>
}

// WipeDisk godoc
// @Summary 擦除磁盘或分区
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.WipeDiskRequest true "params"
// @Success 200 {object} v1.WipeDiskResponse
// @Router /api/v1/nodes/disks/wipedisk [put]
func (h *PveNodeHandler) WipeDisk(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.WipeDiskRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">upid, err := h.nodeService.WipeDisk(ctx, req.NodeID, req.Disk, req.Partition)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.WipeDisk error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, upid)</span>
}

// GetNodeStorageStatus godoc
// @Summary 获取节点存储状态
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Param storage query string true "存储名称"
// @Success 200 {object} v1.GetStorageStatusResponse
// @Router /api/v1/nodes/storage/status [get]
func (h *PveNodeHandler) GetNodeStorageStatus(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetStorageStatusRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">data, err := h.nodeService.GetNodeStorageStatus(ctx, req.NodeID, req.Storage)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeStorageStatus error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetNodeStorageRRDData godoc
// @Summary 获取节点存储 RRD 监控数据
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Param storage query string true "存储名称"
// @Param timeframe query string true "时间范围" Enums(hour, day, week, month, year)
// @Param cf query string true "聚合函数" Enums(AVERAGE, MAX)
// @Success 200 {object} v1.GetStorageRRDDataResponse
// @Router /api/v1/nodes/storage/rrd [get]
func (h *PveNodeHandler) GetNodeStorageRRDData(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetStorageRRDDataRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">data, err := h.nodeService.GetNodeStorageRRDData(ctx, req.NodeID, req.Storage, req.Timeframe, req.Cf)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeStorageRRDData error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetNodeStorageContent godoc
// @Summary 获取节点存储内容列表
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Param storage query string true "存储名称"
// @Param content query string false "内容类型过滤，如 images,iso,backup"
// @Success 200 {object} v1.GetStorageContentResponse
// @Router /api/v1/nodes/storage/content [get]
func (h *PveNodeHandler) GetNodeStorageContent(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetStorageContentRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">items, err := h.nodeService.GetNodeStorageContent(ctx, req.NodeID, req.Storage, req.Content)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeStorageContent error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, items)</span>
}

// GetNodeStorageVolume godoc
// @Summary 获取节点存储卷属性
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Param storage query string true "存储名称"
// @Param volume query string true "卷标识（volume ID）"
// @Success 200 {object} v1.GetStorageVolumeResponse
// @Router /api/v1/nodes/storage/content/detail [get]
func (h *PveNodeHandler) GetNodeStorageVolume(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetStorageVolumeRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">info, err := h.nodeService.GetNodeStorageVolume(ctx, req.NodeID, req.Storage, req.Volume)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeStorageVolume error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, info)</span>
}

// UploadNodeStorageContent godoc
// @Summary 上传存储内容（模板 / ISO / OVA / VM 镜像）
// @Tags PVE节点模块
// @Accept multipart/form-data
// @Produce json
// @Security Bearer
// @Param node_id formData int true "节点ID"
// @Param storage formData string true "存储名称"
// @Param content formData string false "内容类型" Enums(iso,vztmpl,backup,images)
// @Param file formData file true "上传文件"
// @Success 200 {object} v1.Response
// @Router /api/v1/nodes/storage/upload [post]
func (h *PveNodeHandler) UploadNodeStorageContent(ctx *gin.Context) <span class="cov0" title="0">{
        nodeIDStr := ctx.PostForm("node_id")
        if nodeIDStr == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>
        <span class="cov0" title="0">nodeID, err := strconv.ParseInt(nodeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">storage := ctx.PostForm("storage")
        if storage == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>
        <span class="cov0" title="0">content := ctx.PostForm("content")

        file, header, err := ctx.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        result, err := h.nodeService.UploadNodeStorageContent(ctx, nodeID, storage, content, header.Filename, file)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.UploadNodeStorageContent error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, result)</span>
}

// DeleteNodeStorageContent godoc
// @Summary 删除存储内容（镜像 / ISO / OVA / VM 镜像等）
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param node_id query int true "节点ID"
// @Param storage query string true "存储名称"
// @Param volume query string true "卷标识（volume ID，需要完整路径，例如：/local-dir:iso/baohe_pro_8_51_0_1619.iso）"
// @Param delay query int false "延迟删除时间（秒）"
// @Success 200 {object} v1.Response
// @Router /api/v1/nodes/storage/content [delete]
func (h *PveNodeHandler) DeleteNodeStorageContent(ctx *gin.Context) <span class="cov0" title="0">{
        var req v1.DeleteStorageContentRequest
        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">var delay *int
        if req.Delay != nil &amp;&amp; *req.Delay &gt; 0 </span><span class="cov0" title="0">{
                delay = req.Delay
        }</span>

        <span class="cov0" title="0">if err := h.nodeService.DeleteNodeStorageContent(ctx, req.NodeID, req.Storage, req.Volume, delay); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.DeleteNodeStorageContent error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetNodeConsole godoc
// @Summary 获取节点控制台信息
// @Description 获取节点控制台信息，支持 termproxy（终端）和 vncshell（VNC图形界面）两种模式
// @Tags PVE节点模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.GetNodeConsoleRequest true "params"
// @Success 200 {object} v1.GetNodeConsoleResponse
// @Router /api/v1/nodes/console [post]
func (h *PveNodeHandler) GetNodeConsole(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetNodeConsoleRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">data, err := h.nodeService.GetNodeConsole(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("nodeService.GetNodeConsole error", zap.Error(err))
                // 检查是否是预定义的错误类型
                if err == v1.ErrInternalServerError || err == v1.ErrNotFound || err == v1.ErrBadRequest </span><span class="cov0" title="0">{
                        v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                }</span> else<span class="cov0" title="0"> {
                        // 返回自定义错误信息（包含 Proxmox API 的详细错误）
                        ctx.JSON(http.StatusInternalServerError, v1.Response{
                                Code:    500,
                                Message: err.Error(),
                                Data:    nil,
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // 如果返回了 ws_token（无论是 vncshell 还是 termproxy），组装同域 websocket 连接地址（用于 noVNC/终端）
                <span class="cov0" title="0">wsToken, _ := data["ws_token"].(string)
                if wsToken != "" </span><span class="cov0" title="0">{
                        // 兼容前端可能使用 token 字段名
                        data["token"] = wsToken

                        scheme := "ws"
                        proto := ctx.Request.Header.Get("X-Forwarded-Proto")
                        if proto == "https" || proto == "wss" </span><span class="cov0" title="0">{
                                scheme = "wss"
                        }</span> else<span class="cov0" title="0"> if ctx.Request.TLS != nil </span><span class="cov0" title="0">{
                                scheme = "wss"
                        }</span>

                        <span class="cov0" title="0">host := ctx.Request.Host
                        if xfHost := ctx.Request.Header.Get("X-Forwarded-Host"); xfHost != "" </span><span class="cov0" title="0">{
                                host = xfHost
                        }</span>

                        <span class="cov0" title="0">wsURL := fmt.Sprintf("%s://%s/api/v1/nodes/console/ws?token=%s", scheme, host, url.QueryEscape(wsToken))
                        data["ws_url"] = wsURL</span>
        }

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// NodeConsoleWS godoc
// @Summary 节点 Console WebSocket（VNC WebSocket 代理）
// @Description 同域 WS 代理到 Proxmox vncwebsocket，供 noVNC 直接连接（仅 vncshell 模式）
// @Tags PVE节点模块
// @Security Bearer
// @Param token query string true "ws_token（由 /api/v1/nodes/console 返回）"
// @Router /api/v1/nodes/console/ws [get]
func (h *PveNodeHandler) NodeConsoleWS(ctx *gin.Context) <span class="cov0" title="0">{
        token := ctx.Query("token")
        upgrader := websocket.Upgrader{
                CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{ return true }</span>,
        }

        <span class="cov0" title="0">clientConn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("NodeConsoleWS: failed to upgrade websocket", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer clientConn.Close()

        proxmoxConn, err := h.nodeService.DialNodeConsoleWebsocket(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("NodeConsoleWS: failed to dial proxmox", zap.Error(err))
                _ = clientConn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.ClosePolicyViolation, "invalid console token"))
                return
        }</span>
        <span class="cov0" title="0">defer proxmoxConn.Close()

        h.logger.WithContext(ctx).Info("NodeConsoleWS: proxy established")

        errCh := make(chan error, 2)
        proxy := func(src, dst *websocket.Conn) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        mt, msg, err := src.ReadMessage()
                        if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">if err := dst.WriteMessage(mt, msg); err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- err
                                return
                        }</span>
                }
        }

        <span class="cov0" title="0">go proxy(clientConn, proxmoxConn)
        go proxy(proxmoxConn, clientConn)

        &lt;-errCh</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "strconv"
        
        "github.com/gin-gonic/gin"
        "pvesphere/api/v1"
        "pvesphere/internal/service"
        "go.uber.org/zap"
        "net/http"
)

type PveStorageHandler struct {
        *Handler
        storageService service.PveStorageService
}

func NewPveStorageHandler(handler *Handler, storageService service.PveStorageService) *PveStorageHandler <span class="cov0" title="0">{
        return &amp;PveStorageHandler{
                Handler:        handler,
                storageService: storageService,
        }
}</span>

// CreateStorage godoc
// @Summary 创建存储
// @Tags PVE存储模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.CreateStorageRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/storages [post]
func (h *PveStorageHandler) CreateStorage(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.CreateStorageRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.storageService.CreateStorage(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("storageService.CreateStorage error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// UpdateStorage godoc
// @Summary 更新存储
// @Tags PVE存储模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "存储ID"
// @Param request body v1.UpdateStorageRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/storages/{id} [put]
func (h *PveStorageHandler) UpdateStorage(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">req := new(v1.UpdateStorageRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.storageService.UpdateStorage(ctx, id, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("storageService.UpdateStorage error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// DeleteStorage godoc
// @Summary 删除存储
// @Tags PVE存储模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "存储ID"
// @Success 200 {object} v1.Response
// @Router /api/v1/storages/{id} [delete]
func (h *PveStorageHandler) DeleteStorage(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.storageService.DeleteStorage(ctx, id); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("storageService.DeleteStorage error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetStorage godoc
// @Summary 获取存储详情
// @Tags PVE存储模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "存储ID"
// @Success 200 {object} v1.GetStorageResponse
// @Router /api/v1/storages/{id} [get]
func (h *PveStorageHandler) GetStorage(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">storage, err := h.storageService.GetStorage(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("storageService.GetStorage error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, storage)</span>
}

// ListStorages godoc
// @Summary 获取存储列表
// @Tags PVE存储模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param page query int false "页码" default(1)
// @Param page_size query int false "每页数量" default(10)
// @Param cluster_id query int false "集群ID"
// @Param node_name query string false "节点名称"
// @Param type query string false "存储类型"
// @Param storage_name query string false "存储名称"
// @Success 200 {object} v1.ListStorageResponse
// @Router /api/v1/storages [get]
func (h *PveStorageHandler) ListStorages(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.ListStorageRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>
        // 验证 PageSize 最大值
        <span class="cov0" title="0">if req.PageSize &gt; 100 </span><span class="cov0" title="0">{
                req.PageSize = 100
        }</span>

        <span class="cov0" title="0">data, err := h.storageService.ListStorages(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("storageService.ListStorages error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "net/http"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type PveTaskHandler struct {
        *Handler
        taskService service.PveTaskService
}

func NewPveTaskHandler(handler *Handler, taskService service.PveTaskService) *PveTaskHandler <span class="cov0" title="0">{
        return &amp;PveTaskHandler{
                Handler:     handler,
                taskService: taskService,
        }
}</span>

// ListClusterTasks godoc
// @Summary 获取集群任务列表
// @Tags PVE任务模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param cluster_id query int true "集群ID"
// @Success 200 {object} v1.ListClusterTasksResponse
// @Router /api/v1/tasks/cluster [get]
func (h *PveTaskHandler) ListClusterTasks(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.ListClusterTasksRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">tasks, err := h.taskService.ListClusterTasks(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("taskService.ListClusterTasks error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, tasks)</span>
}

// ListNodeTasks godoc
// @Summary 获取节点任务列表
// @Tags PVE任务模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param cluster_id query int true "集群ID"
// @Param node_name query string true "节点名称"
// @Success 200 {object} v1.ListNodeTasksResponse
// @Router /api/v1/tasks/node [get]
func (h *PveTaskHandler) ListNodeTasks(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.ListNodeTasksRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">tasks, err := h.taskService.ListNodeTasks(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("taskService.ListNodeTasks error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, tasks)</span>
}

// GetTaskLog godoc
// @Summary 获取任务日志
// @Tags PVE任务模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param cluster_id query int true "集群ID"
// @Param node_name query string true "节点名称"
// @Param upid query string true "任务UPID"
// @Param start query int false "起始行号" default(0)
// @Param limit query int false "返回行数" default(50)
// @Success 200 {object} v1.GetTaskLogResponse
// @Router /api/v1/tasks/log [get]
func (h *PveTaskHandler) GetTaskLog(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetTaskLogRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Start &lt; 0 </span><span class="cov0" title="0">{
                req.Start = 0
        }</span>
        <span class="cov0" title="0">if req.Limit &lt;= 0 </span><span class="cov0" title="0">{
                req.Limit = 50
        }</span>
        // 限制最大返回行数
        <span class="cov0" title="0">if req.Limit &gt; 1000 </span><span class="cov0" title="0">{
                req.Limit = 1000
        }</span>

        <span class="cov0" title="0">logs, err := h.taskService.GetTaskLog(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("taskService.GetTaskLog error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, logs)</span>
}

// GetTaskStatus godoc
// @Summary 获取任务状态
// @Tags PVE任务模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param cluster_id query int true "集群ID"
// @Param node_name query string true "节点名称"
// @Param upid query string true "任务UPID"
// @Success 200 {object} v1.GetTaskStatusResponse
// @Router /api/v1/tasks/status [get]
func (h *PveTaskHandler) GetTaskStatus(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetTaskStatusRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">status, err := h.taskService.GetTaskStatus(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("taskService.GetTaskStatus error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, status)</span>
}

// StopTask godoc
// @Summary 终止任务
// @Tags PVE任务模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param cluster_id query int true "集群ID"
// @Param node_name query string true "节点名称"
// @Param upid query string true "任务UPID"
// @Success 200 {object} v1.StopTaskResponse
// @Router /api/v1/tasks/stop [delete]
func (h *PveTaskHandler) StopTask(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.StopTaskRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.taskService.StopTask(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("taskService.StopTask error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "net/http"
        "strconv"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type PveTemplateHandler struct {
        *Handler
        templateService service.PveTemplateService
}

func NewPveTemplateHandler(handler *Handler, templateService service.PveTemplateService) *PveTemplateHandler <span class="cov0" title="0">{
        return &amp;PveTemplateHandler{
                Handler:         handler,
                templateService: templateService,
        }
}</span>

// CreateTemplate godoc
// @Summary 创建模板
// @Tags 模板管理
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.CreateTemplateRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/templates [post]
func (h *PveTemplateHandler) CreateTemplate(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.CreateTemplateRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.templateService.CreateTemplate(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("templateService.CreateTemplate error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// UpdateTemplate godoc
// @Summary 更新模板
// @Tags 模板管理
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "模板ID"
// @Param request body v1.UpdateTemplateRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/templates/{id} [put]
func (h *PveTemplateHandler) UpdateTemplate(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">req := new(v1.UpdateTemplateRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.templateService.UpdateTemplate(ctx, id, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("templateService.UpdateTemplate error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// DeleteTemplate godoc
// @Summary 删除模板
// @Tags 模板管理
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "模板ID"
// @Success 200 {object} v1.Response
// @Router /api/v1/templates/{id} [delete]
func (h *PveTemplateHandler) DeleteTemplate(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.templateService.DeleteTemplate(ctx, id); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("templateService.DeleteTemplate error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetTemplate godoc
// @Summary 获取模板详情
// @Tags 模板管理
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "模板ID"
// @Success 200 {object} v1.GetTemplateResponse
// @Router /api/v1/templates/{id} [get]
func (h *PveTemplateHandler) GetTemplate(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">data, err := h.templateService.GetTemplate(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("templateService.GetTemplate error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// ListTemplates godoc
// @Summary 获取模板列表
// @Tags 模板管理
// @Accept json
// @Produce json
// @Security Bearer
// @Param page query int false "页码" default(1)
// @Param page_size query int false "每页数量" default(10)
// @Param cluster_id query int false "集群ID"
// @Success 200 {object} v1.ListTemplateResponse
// @Router /api/v1/templates [get]
func (h *PveTemplateHandler) ListTemplates(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.ListTemplateRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>
        // 验证 PageSize 最大值
        <span class="cov0" title="0">if req.PageSize &gt; 100 </span><span class="cov0" title="0">{
                req.PageSize = 100
        }</span>

        <span class="cov0" title="0">data, err := h.templateService.ListTemplates(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("templateService.ListTemplates error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "fmt"
        "net/url"
        "strconv"

        "net/http"
        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

type PveVMHandler struct {
        *Handler
        vmService service.PveVMService
}

func NewPveVMHandler(handler *Handler, vmService service.PveVMService) *PveVMHandler <span class="cov0" title="0">{
        return &amp;PveVMHandler{
                Handler:   handler,
                vmService: vmService,
        }
}</span>

// CreateVM godoc
// @Summary 创建虚拟机（仅数据库记录）
// @Description 仅创建数据库记录，用于手动同步或导入场景，不调用 Proxmox API
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.CreateVMRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/vms [post]
func (h *PveVMHandler) CreateVM(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.CreateVMRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.CreateVM(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.CreateVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// CreateVMInProxmox godoc
// @Summary 创建虚拟机（完整流程）
// @Description 调用 Proxmox API 创建虚拟机并自动创建数据库记录，这是最常用的场景
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.CreateVMRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/vms/create [post]
func (h *PveVMHandler) CreateVMInProxmox(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.CreateVMRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.CreateVMInProxmox(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.CreateVMInProxmox error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// UpdateVM godoc
// @Summary 更新虚拟机
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "虚拟机ID"
// @Param request body v1.UpdateVMRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/vms/{id} [put]
func (h *PveVMHandler) UpdateVM(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">req := new(v1.UpdateVMRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.UpdateVM(ctx, id, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.UpdateVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// DeleteVM godoc
// @Summary 删除虚拟机
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "虚拟机ID"
// @Success 200 {object} v1.Response
// @Router /api/v1/vms/{id} [delete]
func (h *PveVMHandler) DeleteVM(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.DeleteVM(ctx, id); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.DeleteVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetVM godoc
// @Summary 获取虚拟机详情
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "虚拟机ID"
// @Success 200 {object} v1.GetVMResponse
// @Router /api/v1/vms/{id} [get]
func (h *PveVMHandler) GetVM(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">vm, err := h.vmService.GetVM(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.GetVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, vm)</span>
}

// ListVMs godoc
// @Summary 获取虚拟机列表
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param page query int false "页码" default(1)
// @Param page_size query int false "每页数量" default(10)
// @Param cluster_name query string false "集群名称"
// @Param node_name query string false "节点名称"
// @Param status query string false "状态"
// @Param app_id query string false "应用ID"
// @Success 200 {object} v1.ListVMResponse
// @Router /api/v1/vms [get]
func (h *PveVMHandler) ListVMs(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.ListVMRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>
        // 验证 PageSize 最大值
        <span class="cov0" title="0">if req.PageSize &gt; 100 </span><span class="cov0" title="0">{
                req.PageSize = 100
        }</span>

        <span class="cov0" title="0">data, err := h.vmService.ListVMs(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.ListVMs error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// StartVM godoc
// @Summary 启动虚拟机
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "虚拟机ID"
// @Success 200 {object} v1.Response
// @Router /api/v1/vms/{id}/start [post]
func (h *PveVMHandler) StartVM(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.StartVM(ctx, id); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.StartVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// StopVM godoc
// @Summary 停止虚拟机
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "虚拟机ID"
// @Success 200 {object} v1.Response
// @Router /api/v1/vms/{id}/stop [post]
func (h *PveVMHandler) StopVM(ctx *gin.Context) <span class="cov0" title="0">{
        idStr := ctx.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.StopVM(ctx, id); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.StopVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetVMCurrentConfig godoc
// @Summary 获取虚拟机当前配置
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param vm_id query int true "虚拟机ID"
// @Success 200 {object} v1.GetVMCurrentConfigResponse
// @Router /api/v1/vms/config [get]
func (h *PveVMHandler) GetVMCurrentConfig(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetVMCurrentConfigRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">config, err := h.vmService.GetVMCurrentConfig(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.GetVMCurrentConfig error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, config)</span>
}

// GetVMPendingConfig godoc
// @Summary 获取虚拟机pending配置
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param vm_id query int true "虚拟机ID"
// @Success 200 {object} v1.GetVMPendingConfigResponse
// @Router /api/v1/vms/config/pending [get]
func (h *PveVMHandler) GetVMPendingConfig(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetVMPendingConfigRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">config, err := h.vmService.GetVMPendingConfig(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.GetVMPendingConfig error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, config)</span>
}

// UpdateVMConfig godoc
// @Summary 更新虚拟机配置
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.UpdateVMConfigRequest true "params"
// @Success 200 {object} v1.UpdateVMConfigResponse
// @Router /api/v1/vms/config [put]
func (h *PveVMHandler) UpdateVMConfig(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.UpdateVMConfigRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.UpdateVMConfig(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.UpdateVMConfig error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetVMStatus godoc
// @Summary 获取虚拟机状态
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param vm_id query int true "虚拟机ID"
// @Success 200 {object} v1.GetVMStatusResponse
// @Router /api/v1/vms/status [get]
func (h *PveVMHandler) GetVMStatus(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetVMStatusRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">status, err := h.vmService.GetVMStatus(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.GetVMStatus error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, status)</span>
}

// GetVMRRDData godoc
// @Summary 获取虚拟机RRD监控数据
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param vm_id query int true "虚拟机ID"
// @Param timeframe query string true "时间范围" Enums(hour, day, week, month, year)
// @Param cf query string true "聚合函数" Enums(AVERAGE, MAX)
// @Success 200 {object} v1.GetVMRRDDataResponse
// @Router /api/v1/vms/rrd [get]
func (h *PveVMHandler) GetVMRRDData(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetVMRRDDataRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">rrdData, err := h.vmService.GetVMRRDData(ctx, req.VMID, req.Timeframe, req.Cf)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.GetVMRRDData error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, rrdData)</span>
}

// GetVMConsole godoc
// @Summary 获取虚拟机 Console（VNCProxy）
// @Description 调用 Proxmox vncproxy 获取 port/ticket 等信息，用于 noVNC 连接
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.GetVMConsoleRequest true "params"
// @Success 200 {object} v1.GetVMConsoleResponse
// @Router /api/v1/vms/console [post]
func (h *PveVMHandler) GetVMConsole(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetVMConsoleRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">data, err := h.vmService.GetVMConsole(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.GetVMConsole error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        // 组装同域 websocket 连接地址（用于 noVNC）
        // 这里返回我们后端的 ws 代理地址，避免跨域/证书/鉴权问题
        <span class="cov0" title="0">wsToken, _ := data["ws_token"].(string)
        if wsToken != "" </span><span class="cov0" title="0">{
                // 兼容前端可能使用 token 字段名
                data["token"] = wsToken

                scheme := "ws"
                proto := ctx.Request.Header.Get("X-Forwarded-Proto")
                if proto == "https" || proto == "wss" </span><span class="cov0" title="0">{
                        scheme = "wss"
                }</span> else<span class="cov0" title="0"> if ctx.Request.TLS != nil </span><span class="cov0" title="0">{
                        scheme = "wss"
                }</span>

                <span class="cov0" title="0">host := ctx.Request.Host
                if xfHost := ctx.Request.Header.Get("X-Forwarded-Host"); xfHost != "" </span><span class="cov0" title="0">{
                        host = xfHost
                }</span>

                <span class="cov0" title="0">wsURL := fmt.Sprintf("%s://%s/api/v1/vms/console/ws?token=%s", scheme, host, url.QueryEscape(wsToken))
                data["ws_url"] = wsURL</span>
        }

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// VMConsoleWS godoc
// @Summary 虚拟机 Console WebSocket（VNC WebSocket 代理）
// @Description 同域 WS 代理到 Proxmox vncwebsocket，供 noVNC 直接连接
// @Tags PVE虚拟机模块
// @Security Bearer
// @Param token query string true "ws_token（由 /api/v1/vms/console 返回）"
// @Router /api/v1/vms/console/ws [get]
func (h *PveVMHandler) VMConsoleWS(ctx *gin.Context) <span class="cov0" title="0">{
        token := ctx.Query("token")
        upgrader := websocket.Upgrader{
                CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{ return true }</span>,
        }

        <span class="cov0" title="0">clientConn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer clientConn.Close()

        proxmoxConn, err := h.vmService.DialVMConsoleWebsocket(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                _ = clientConn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.ClosePolicyViolation, "invalid console token"))
                return
        }</span>
        <span class="cov0" title="0">defer proxmoxConn.Close()

        errCh := make(chan error, 2)
        proxy := func(src, dst *websocket.Conn) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        mt, msg, err := src.ReadMessage()
                        if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">if err := dst.WriteMessage(mt, msg); err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- err
                                return
                        }</span>
                }
        }

        <span class="cov0" title="0">go proxy(clientConn, proxmoxConn)
        go proxy(proxmoxConn, clientConn)

        &lt;-errCh</span>
}

// MigrateVM godoc
// @Summary 迁移虚拟机（同集群）
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.MigrateVMRequest true "迁移请求"
// @Success 200 {object} v1.MigrateVMResponse
// @Router /api/v1/vms/migrate [post]
func (h *PveVMHandler) MigrateVM(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.MigrateVMRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.vmService.MigrateVM(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.MigrateVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, result)</span>
}

// RemoteMigrateVM godoc
// @Summary 远程迁移虚拟机（跨集群）
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.RemoteMigrateVMRequest true "远程迁移请求"
// @Success 200 {object} v1.RemoteMigrateVMResponse
// @Router /api/v1/vms/remote-migrate [post]
func (h *PveVMHandler) RemoteMigrateVM(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.RemoteMigrateVMRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.vmService.RemoteMigrateVM(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.RemoteMigrateVM error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, result)</span>
}

// CreateBackup godoc
// @Summary 创建虚拟机备份
// @Description 使用 Proxmox vzdump API 创建虚拟机备份
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.CreateBackupRequest true "创建备份请求"
// @Success 200 {object} v1.CreateBackupResponse
// @Router /api/v1/vms/backup [post]
func (h *PveVMHandler) CreateBackup(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.CreateBackupRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("CreateBackup bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">data, err := h.vmService.CreateBackup(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.CreateBackup error", zap.Error(err))
                if err == v1.ErrNotFound </span><span class="cov0" title="0">{
                        v1.HandleError(ctx, http.StatusNotFound, err, nil)
                        return
                }</span>
                <span class="cov0" title="0">v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return</span>
        }

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// DeleteBackup godoc
// @Summary 删除虚拟机备份
// @Description 删除指定存储中的备份文件
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.DeleteBackupRequest true "删除备份请求"
// @Success 200 {object} v1.DeleteBackupResponse
// @Router /api/v1/vms/backup [delete]
func (h *PveVMHandler) DeleteBackup(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.DeleteBackupRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("DeleteBackup bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.DeleteBackup(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.DeleteBackup error", zap.Error(err))
                if err == v1.ErrNotFound </span><span class="cov0" title="0">{
                        v1.HandleError(ctx, http.StatusNotFound, err, nil)
                        return
                }</span>
                <span class="cov0" title="0">v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return</span>
        }

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}

// GetVMCloudInit godoc
// @Summary 获取虚拟机 CloudInit 配置
// @Description 获取虚拟机的 CloudInit 配置，包含当前和待处理的值
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param vm_id query int true "虚拟机ID"
// @Param node_id query int true "节点ID"
// @Success 200 {object} v1.GetVMCloudInitResponse
// @Router /api/v1/vms/cloudinit [get]
func (h *PveVMHandler) GetVMCloudInit(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.GetVMCloudInitRequest)
        if err := ctx.ShouldBindQuery(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("GetVMCloudInit bind query error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">config, err := h.vmService.GetVMCloudInit(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.GetVMCloudInit error", zap.Error(err))
                if err == v1.ErrNotFound </span><span class="cov0" title="0">{
                        v1.HandleError(ctx, http.StatusNotFound, err, nil)
                        return
                }</span>
                <span class="cov0" title="0">v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return</span>
        }

        <span class="cov0" title="0">v1.HandleSuccess(ctx, config)</span>
}

// UpdateVMCloudInit godoc
// @Summary 更新虚拟机 CloudInit 配置
// @Description 重新生成和更改 cloudinit 配置驱动器
// @Tags PVE虚拟机模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.UpdateVMCloudInitRequest true "更新 CloudInit 配置请求"
// @Success 200 {object} v1.UpdateVMCloudInitResponse
// @Router /api/v1/vms/cloudinit [put]
func (h *PveVMHandler) UpdateVMCloudInit(ctx *gin.Context) <span class="cov0" title="0">{
        req := new(v1.UpdateVMCloudInitRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("UpdateVMCloudInit bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">if err := h.vmService.UpdateVMCloudInit(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("vmService.UpdateVMCloudInit error", zap.Error(err))
                if err == v1.ErrNotFound </span><span class="cov0" title="0">{
                        v1.HandleError(ctx, http.StatusNotFound, err, nil)
                        return
                }</span>
                <span class="cov0" title="0">v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return</span>
        }

        <span class="cov0" title="0">v1.HandleSuccess(ctx, nil)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "net/http"
        "strconv"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type TemplateManagementHandler struct {
        *Handler
        templateManagementService service.TemplateManagementService
}

func NewTemplateManagementHandler(
        handler *Handler,
        templateManagementService service.TemplateManagementService,
) *TemplateManagementHandler <span class="cov0" title="0">{
        return &amp;TemplateManagementHandler{
                Handler:                   handler,
                templateManagementService: templateManagementService,
        }
}</span>

// ImportTemplate 从备份文件导入模板
// @Summary 从备份文件导入模板
// @Description 基于已有的虚拟机备份文件创建模板，支持共享存储和本地存储
// @Tags 模板管理
// @Accept json
// @Produce json
// @Param request body v1.ImportTemplateRequest true "导入模板请求"
// @Success 200 {object} v1.ImportTemplateResponse
// @Router /api/v1/templates/import [post]
func (h *TemplateManagementHandler) ImportTemplate(ctx *gin.Context) <span class="cov0" title="0">{
        // 解析请求体
        var req v1.ImportTemplateRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("ImportTemplate bind json error", zap.Error(err))
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, map[string]string{
                        "error": err.Error(),
                })
                return
        }</span>

        // 调用服务层
        <span class="cov0" title="0">data, err := h.templateManagementService.ImportTemplateFromBackup(ctx.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetTemplateDetail 查询模板详情（包含实例）
// @Summary 查询模板详情
// @Description 查询模板详细信息，包括上传信息和实例列表
// @Tags 模板管理
// @Accept json
// @Produce json
// @Param id path int true "模板ID"
// @Param include_instances query boolean false "是否包含实例信息"
// @Success 200 {object} v1.GetTemplateDetailResponse
// @Router /api/v1/templates/{id}/detail [get]
func (h *TemplateManagementHandler) GetTemplateDetail(ctx *gin.Context) <span class="cov0" title="0">{
        // 获取模板ID
        idStr := ctx.Param("id")
        if idStr == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">templateID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 解析查询参数
        <span class="cov0" title="0">includeInstancesStr := ctx.Query("include_instances")
        includeInstances := includeInstancesStr == "true"

        // 调用服务层
        data, err := h.templateManagementService.GetTemplateDetailWithInstances(ctx.Request.Context(), templateID, includeInstances)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// SyncTemplate 同步模板到其他节点
// @Summary 同步模板到其他节点
// @Description 将本地存储的模板同步到其他节点（仅支持local存储）
// @Tags 模板管理
// @Accept json
// @Produce json
// @Param id path int true "模板ID"
// @Param request body v1.SyncTemplateRequest true "同步请求"
// @Success 200 {object} v1.SyncTemplateResponse
// @Router /api/v1/templates/{id}/sync [post]
func (h *TemplateManagementHandler) SyncTemplate(ctx *gin.Context) <span class="cov0" title="0">{
        // 获取模板ID
        idStr := ctx.Param("id")
        if idStr == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">templateID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 解析请求体
        <span class="cov0" title="0">var req v1.SyncTemplateRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 调用服务层
        <span class="cov0" title="0">data, err := h.templateManagementService.SyncTemplateToNodes(ctx.Request.Context(), templateID, req.TargetNodeIDs)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// GetSyncTask 查询同步任务
// @Summary 查询同步任务
// @Description 查询指定同步任务的详细信息
// @Tags 模板管理
// @Accept json
// @Produce json
// @Param task_id path int true "任务ID"
// @Success 200 {object} v1.GetSyncTaskResponse
// @Router /api/v1/templates/sync-tasks/{task_id} [get]
func (h *TemplateManagementHandler) GetSyncTask(ctx *gin.Context) <span class="cov0" title="0">{
        // 获取任务ID
        taskIDStr := ctx.Param("task_id")
        if taskIDStr == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">taskID, err := strconv.ParseInt(taskIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 调用服务层
        <span class="cov0" title="0">data, err := h.templateManagementService.GetSyncTask(ctx.Request.Context(), taskID)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// ListSyncTasks 列出同步任务
// @Summary 列出同步任务
// @Description 列出同步任务列表，支持分页和过滤
// @Tags 模板管理
// @Accept json
// @Produce json
// @Param page query int false "页码"
// @Param page_size query int false "每页数量"
// @Param template_id query int false "模板ID"
// @Param status query string false "任务状态"
// @Success 200 {object} v1.ListSyncTasksResponse
// @Router /api/v1/templates/sync-tasks [get]
func (h *TemplateManagementHandler) ListSyncTasks(ctx *gin.Context) <span class="cov0" title="0">{
        // 解析查询参数
        var req v1.ListSyncTasksRequest

        pageStr := ctx.Query("page")
        if pageStr != "" </span><span class="cov0" title="0">{
                page, err := strconv.Atoi(pageStr)
                if err == nil </span><span class="cov0" title="0">{
                        req.Page = page
                }</span>
        }
        <span class="cov0" title="0">if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>

        <span class="cov0" title="0">pageSizeStr := ctx.Query("page_size")
        if pageSizeStr != "" </span><span class="cov0" title="0">{
                pageSize, err := strconv.Atoi(pageSizeStr)
                if err == nil </span><span class="cov0" title="0">{
                        req.PageSize = pageSize
                }</span>
        }
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>

        <span class="cov0" title="0">templateIDStr := ctx.Query("template_id")
        if templateIDStr != "" </span><span class="cov0" title="0">{
                templateID, err := strconv.ParseInt(templateIDStr, 10, 64)
                if err == nil </span><span class="cov0" title="0">{
                        req.TemplateID = &amp;templateID
                }</span>
        }

        <span class="cov0" title="0">req.Status = ctx.Query("status")

        // 调用服务层
        data, err := h.templateManagementService.ListSyncTasks(ctx.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}

// RetrySyncTask 重试同步任务
// @Summary 重试同步任务
// @Description 重试失败的同步任务
// @Tags 模板管理
// @Accept json
// @Produce json
// @Param task_id path int true "任务ID"
// @Success 200 {object} v1.RetrySyncTaskResponse
// @Router /api/v1/templates/sync-tasks/{task_id}/retry [post]
func (h *TemplateManagementHandler) RetrySyncTask(ctx *gin.Context) <span class="cov0" title="0">{
        // 获取任务ID
        taskIDStr := ctx.Param("task_id")
        if taskIDStr == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">taskID, err := strconv.ParseInt(taskIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 调用服务层
        <span class="cov0" title="0">err = h.templateManagementService.RetrySyncTask(ctx.Request.Context(), taskID)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, map[string]interface{}{
                "task_id": taskID,
                "status":  "pending",
        })</span>
}

// ListTemplateInstances 列出模板实例
// @Summary 列出模板实例
// @Description 列出指定模板的所有实例
// @Tags 模板管理
// @Accept json
// @Produce json
// @Param id path int true "模板ID"
// @Success 200 {object} v1.ListTemplateInstancesResponse
// @Router /api/v1/templates/{id}/instances [get]
func (h *TemplateManagementHandler) ListTemplateInstances(ctx *gin.Context) <span class="cov0" title="0">{
        // 获取模板ID
        idStr := ctx.Param("id")
        if idStr == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov0" title="0">templateID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 调用服务层
        <span class="cov0" title="0">data, err := h.templateManagementService.ListTemplateInstances(ctx.Request.Context(), templateID)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov0" title="0">v1.HandleSuccess(ctx, data)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handler

import (
        "net/http"
        v1 "pvesphere/api/v1"
        "pvesphere/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type UserHandler struct {
        *Handler
        userService service.UserService
}

func NewUserHandler(handler *Handler, userService service.UserService) *UserHandler <span class="cov8" title="1">{
        return &amp;UserHandler{
                Handler:     handler,
                userService: userService,
        }
}</span>

// Register godoc
// @Summary 用户注册
// @Schemes
// @Description 目前只支持邮箱登录
// @Tags 用户模块
// @Accept json
// @Produce json
// @Param request body v1.RegisterRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/register [post]
func (h *UserHandler) Register(ctx *gin.Context) <span class="cov8" title="1">{
        req := new(v1.RegisterRequest)
        if err := ctx.ShouldBindJSON(req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov8" title="1">if err := h.userService.Register(ctx, req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("userService.Register error", zap.Error(err))
                v1.HandleError(ctx, http.StatusInternalServerError, err, nil)
                return
        }</span>

        <span class="cov8" title="1">v1.HandleSuccess(ctx, nil)</span>
}

// Login godoc
// @Summary 账号登录
// @Schemes
// @Description
// @Tags 用户模块
// @Accept json
// @Produce json
// @Param request body v1.LoginRequest true "params"
// @Success 200 {object} v1.LoginResponse
// @Router /api/v1/login [post]
func (h *UserHandler) Login(ctx *gin.Context) <span class="cov8" title="1">{
        var req v1.LoginRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov8" title="1">token, err := h.userService.Login(ctx, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusUnauthorized, v1.ErrUnauthorized, nil)
                return
        }</span>
        <span class="cov8" title="1">v1.HandleSuccess(ctx, v1.LoginResponseData{
                AccessToken: token,
        })</span>
}

// GetProfile godoc
// @Summary 获取用户信息
// @Schemes
// @Description
// @Tags 用户模块
// @Accept json
// @Produce json
// @Security Bearer
// @Success 200 {object} v1.GetProfileResponse
// @Router /api/v1/user [get]
func (h *UserHandler) GetProfile(ctx *gin.Context) <span class="cov8" title="1">{
        userId := GetUserIdFromCtx(ctx)
        if userId == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusUnauthorized, v1.ErrUnauthorized, nil)
                return
        }</span>

        <span class="cov8" title="1">user, err := h.userService.GetProfile(ctx, userId)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("userService.GetProfile error", zap.Error(err))
                if err == v1.ErrUnauthorized </span><span class="cov0" title="0">{
                        v1.HandleError(ctx, http.StatusUnauthorized, v1.ErrUnauthorized, nil)
                }</span> else<span class="cov0" title="0"> if err == v1.ErrNotFound </span><span class="cov0" title="0">{
                        v1.HandleError(ctx, http.StatusNotFound, v1.ErrNotFound, nil)
                }</span> else<span class="cov0" title="0"> {
                        v1.HandleError(ctx, http.StatusInternalServerError, v1.ErrInternalServerError, nil)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">v1.HandleSuccess(ctx, user)</span>
}

// UpdateProfile godoc
// @Summary 修改用户信息
// @Schemes
// @Description 支持修改昵称和密码，不允许修改邮箱。修改密码需要提供旧密码和新密码。
// @Tags 用户模块
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body v1.UpdateProfileRequest true "params"
// @Success 200 {object} v1.Response
// @Router /api/v1/user [put]
func (h *UserHandler) UpdateProfile(ctx *gin.Context) <span class="cov8" title="1">{
        userId := GetUserIdFromCtx(ctx)
        if userId == "" </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusUnauthorized, v1.ErrUnauthorized, nil)
                return
        }</span>

        <span class="cov8" title="1">var req v1.UpdateProfileRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        // 验证：如果修改密码，必须同时提供旧密码和新密码
        <span class="cov8" title="1">if (req.OldPassword != "" &amp;&amp; req.NewPassword == "") || (req.OldPassword == "" &amp;&amp; req.NewPassword != "") </span><span class="cov0" title="0">{
                v1.HandleError(ctx, http.StatusBadRequest, v1.ErrBadRequest, nil)
                return
        }</span>

        <span class="cov8" title="1">if err := h.userService.UpdateProfile(ctx, userId, &amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.WithContext(ctx).Error("userService.UpdateProfile error", zap.Error(err))
                if err == v1.ErrUnauthorized </span><span class="cov0" title="0">{
                        v1.HandleError(ctx, http.StatusUnauthorized, v1.ErrUnauthorized, nil)
                }</span> else<span class="cov0" title="0"> {
                        v1.HandleError(ctx, http.StatusInternalServerError, v1.ErrInternalServerError, nil)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">v1.HandleSuccess(ctx, nil)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package repository

import (
        "context"
        "errors"
        "pvesphere/internal/model"

        "gorm.io/gorm"
)

type PveClusterRepository interface {
        Create(ctx context.Context, cluster *model.PveCluster) error
        Update(ctx context.Context, cluster *model.PveCluster) error
        Delete(ctx context.Context, id int64) error
        GetByID(ctx context.Context, id int64) (*model.PveCluster, error)
        GetByClusterName(ctx context.Context, clusterName string) (*model.PveCluster, error)
        List(ctx context.Context) ([]*model.PveCluster, error)
        ListWithPagination(ctx context.Context, page, pageSize int, env, region string) ([]*model.PveCluster, int64, error)
        GetAllSchedulable(ctx context.Context) ([]*model.PveCluster, error)
        GetAllEnabled(ctx context.Context) ([]*model.PveCluster, error) // 获取所有启用的集群（用于数据自动上报）
        GetByIDs(ctx context.Context, ids []int64) (map[int64]*model.PveCluster, error) // 批量查询集群，返回 map[id]*cluster
}

func NewPveClusterRepository(r *Repository) PveClusterRepository <span class="cov0" title="0">{
        return &amp;pveClusterRepository{Repository: r}
}</span>

type pveClusterRepository struct {
        *Repository
}

func (r *pveClusterRepository) Create(ctx context.Context, cluster *model.PveCluster) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(cluster).Error
}</span>

func (r *pveClusterRepository) Update(ctx context.Context, cluster *model.PveCluster) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(cluster).Error
}</span>

func (r *pveClusterRepository) GetByID(ctx context.Context, id int64) (*model.PveCluster, error) <span class="cov0" title="0">{
        var cluster model.PveCluster
        if err := r.DB(ctx).Where("id = ?", id).First(&amp;cluster).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;cluster, nil</span>
}

func (r *pveClusterRepository) GetByClusterName(ctx context.Context, clusterName string) (*model.PveCluster, error) <span class="cov0" title="0">{
        var cluster model.PveCluster
        if err := r.DB(ctx).Where("cluster_name = ?", clusterName).First(&amp;cluster).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;cluster, nil</span>
}

func (r *pveClusterRepository) List(ctx context.Context) ([]*model.PveCluster, error) <span class="cov0" title="0">{
        var clusters []*model.PveCluster
        if err := r.DB(ctx).Find(&amp;clusters).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return clusters, nil</span>
}

func (r *pveClusterRepository) GetAllSchedulable(ctx context.Context) ([]*model.PveCluster, error) <span class="cov0" title="0">{
        var clusters []*model.PveCluster
        if err := r.DB(ctx).Where("is_schedulable = ?", 1).Find(&amp;clusters).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return clusters, nil</span>
}

func (r *pveClusterRepository) GetAllEnabled(ctx context.Context) ([]*model.PveCluster, error) <span class="cov0" title="0">{
        var clusters []*model.PveCluster
        if err := r.DB(ctx).Where("is_enabled = ?", 1).Find(&amp;clusters).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return clusters, nil</span>
}

func (r *pveClusterRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("id = ?", id).Delete(&amp;model.PveCluster{}).Error
}</span>

func (r *pveClusterRepository) ListWithPagination(ctx context.Context, page, pageSize int, env, region string) ([]*model.PveCluster, int64, error) <span class="cov0" title="0">{
        var clusters []*model.PveCluster
        var total int64

        query := r.DB(ctx).Model(&amp;model.PveCluster{})

        if env != "" </span><span class="cov0" title="0">{
                query = query.Where("env = ?", env)
        }</span>
        <span class="cov0" title="0">if region != "" </span><span class="cov0" title="0">{
                query = query.Where("region = ?", region)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize
        if err := query.Offset(offset).Limit(pageSize).Find(&amp;clusters).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return clusters, total, nil</span>
}

// GetByIDs 批量查询集群，返回 map[id]*cluster，用于批量填充名称
func (r *pveClusterRepository) GetByIDs(ctx context.Context, ids []int64) (map[int64]*model.PveCluster, error) <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return make(map[int64]*model.PveCluster), nil
        }</span>

        <span class="cov0" title="0">var clusters []*model.PveCluster
        if err := r.DB(ctx).Where("id IN ?", ids).Find(&amp;clusters).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make(map[int64]*model.PveCluster, len(clusters))
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                result[cluster.Id] = cluster
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "context"
        "errors"
        "pvesphere/internal/model"
        "time"

        "gorm.io/gorm"
)

type PveNodeRepository interface {
        Create(ctx context.Context, node *model.PveNode) error
        Update(ctx context.Context, node *model.PveNode) error
        Delete(ctx context.Context, id int64) error
        GetByID(ctx context.Context, id int64) (*model.PveNode, error)
        GetByNodeName(ctx context.Context, nodeName string, clusterID int64) (*model.PveNode, error)
        GetByClusterID(ctx context.Context, clusterID int64) ([]*model.PveNode, error)
        ListWithPagination(ctx context.Context, page, pageSize int, clusterID int64, env, status string) ([]*model.PveNode, int64, error)
        Upsert(ctx context.Context, node *model.PveNode) error
        DeleteByNodeName(ctx context.Context, nodeName string, clusterID int64) error
        GetHashByNodeName(ctx context.Context, nodeName string, clusterID int64) (string, int64, error) // 返回 hash 和 id
        UpdateSyncTimeOnly(ctx context.Context, id int64) error
        GetByIDs(ctx context.Context, ids []int64) (map[int64]*model.PveNode, error) // 批量查询节点，返回 map[id]*node
}

func NewPveNodeRepository(r *Repository) PveNodeRepository <span class="cov0" title="0">{
        return &amp;pveNodeRepository{Repository: r}
}</span>

type pveNodeRepository struct {
        *Repository
}

func (r *pveNodeRepository) Create(ctx context.Context, node *model.PveNode) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(node).Error
}</span>

func (r *pveNodeRepository) Update(ctx context.Context, node *model.PveNode) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(node).Error
}</span>

func (r *pveNodeRepository) GetByID(ctx context.Context, id int64) (*model.PveNode, error) <span class="cov0" title="0">{
        var node model.PveNode
        if err := r.DB(ctx).Where("id = ?", id).First(&amp;node).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;node, nil</span>
}

func (r *pveNodeRepository) GetByNodeName(ctx context.Context, nodeName string, clusterID int64) (*model.PveNode, error) <span class="cov0" title="0">{
        var node model.PveNode
        if err := r.DB(ctx).Where("node_name = ? AND cluster_id = ?", nodeName, clusterID).First(&amp;node).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;node, nil</span>
}

func (r *pveNodeRepository) GetByClusterID(ctx context.Context, clusterID int64) ([]*model.PveNode, error) <span class="cov0" title="0">{
        var nodes []*model.PveNode
        if err := r.DB(ctx).Where("cluster_id = ?", clusterID).Find(&amp;nodes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return nodes, nil</span>
}

func (r *pveNodeRepository) Upsert(ctx context.Context, node *model.PveNode) error <span class="cov0" title="0">{
        // 先查询是否存在以及 hash
        existingHash, existingID, err := r.GetHashByNodeName(ctx, node.NodeName, node.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 计算新资源的 hash
        <span class="cov0" title="0">if node.ResourceHash == "" </span>{<span class="cov0" title="0">
                // 如果没有提供 hash，需要从外部计算（由调用者提供）
                // 这里假设 hash 已经在 Handler 中计算好了
        }</span>

        // 如果不存在，创建新记录
        <span class="cov0" title="0">if existingID == 0 </span><span class="cov0" title="0">{
                return r.Create(ctx, node)
        }</span>

        // 如果 hash 相同，只更新同步时间（轻量级更新）
        <span class="cov0" title="0">if existingHash != "" &amp;&amp; existingHash == node.ResourceHash </span><span class="cov0" title="0">{
                node.Id = existingID
                return r.UpdateSyncTimeOnly(ctx, existingID)
        }</span>

        // hash 不同，完整更新记录
        <span class="cov0" title="0">node.Id = existingID
        return r.Update(ctx, node)</span>
}

func (r *pveNodeRepository) GetHashByNodeName(ctx context.Context, nodeName string, clusterID int64) (string, int64, error) <span class="cov0" title="0">{
        var result struct {
                Id           int64  `gorm:"column:id"`
                ResourceHash string `gorm:"column:resource_hash"`
        }

        err := r.DB(ctx).
                Table("pve_node").
                Select("id, resource_hash").
                Where("node_name = ? AND cluster_id = ?", nodeName, clusterID).
                First(&amp;result).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return "", 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov0" title="0">return result.ResourceHash, result.Id, nil</span>
}

func (r *pveNodeRepository) UpdateSyncTimeOnly(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).
                Model(&amp;model.PveNode{}).
                Where("id = ?", id).
                Update("last_sync_time", time.Now()).Error
}</span>

func (r *pveNodeRepository) DeleteByNodeName(ctx context.Context, nodeName string, clusterID int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("node_name = ? AND cluster_id = ?", nodeName, clusterID).Delete(&amp;model.PveNode{}).Error
}</span>

func (r *pveNodeRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("id = ?", id).Delete(&amp;model.PveNode{}).Error
}</span>

func (r *pveNodeRepository) ListWithPagination(ctx context.Context, page, pageSize int, clusterID int64, env, status string) ([]*model.PveNode, int64, error) <span class="cov0" title="0">{
        var nodes []*model.PveNode
        var total int64

        query := r.DB(ctx).Model(&amp;model.PveNode{})

        if clusterID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("cluster_id = ?", clusterID)
        }</span>
        <span class="cov0" title="0">if env != "" </span><span class="cov0" title="0">{
                query = query.Where("env = ?", env)
        }</span>
        <span class="cov0" title="0">if status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", status)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize
        if err := query.Offset(offset).Limit(pageSize).Order("id DESC").Find(&amp;nodes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return nodes, total, nil</span>
}

// GetByIDs 批量查询节点，返回 map[id]*node，用于批量填充名称
func (r *pveNodeRepository) GetByIDs(ctx context.Context, ids []int64) (map[int64]*model.PveNode, error) <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return make(map[int64]*model.PveNode), nil
        }</span>

        <span class="cov0" title="0">var nodes []*model.PveNode
        if err := r.DB(ctx).Where("id IN ?", ids).Find(&amp;nodes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make(map[int64]*model.PveNode, len(nodes))
        for _, node := range nodes </span><span class="cov0" title="0">{
                result[node.Id] = node
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "context"
        "errors"
        "pvesphere/internal/model"
        "time"

        "gorm.io/gorm"
)

type PveStorageRepository interface {
        Create(ctx context.Context, storage *model.PveStorage) error
        Update(ctx context.Context, storage *model.PveStorage) error
        Delete(ctx context.Context, id int64) error
        GetByID(ctx context.Context, id int64) (*model.PveStorage, error)
        GetByStorageName(ctx context.Context, storageName string, nodeName string, clusterID int64) (*model.PveStorage, error)
        ListByStorageName(ctx context.Context, clusterID int64, storageName string) ([]*model.PveStorage, error)
        GetByClusterID(ctx context.Context, clusterID int64) ([]*model.PveStorage, error)
        ListWithPagination(ctx context.Context, page, pageSize int, clusterID int64, nodeName, storageType, storageName string) ([]*model.PveStorage, int64, error)
        Upsert(ctx context.Context, storage *model.PveStorage) error
        DeleteByStorageName(ctx context.Context, storageName string, nodeName string, clusterID int64) error
        GetHashByStorageName(ctx context.Context, storageName string, nodeName string, clusterID int64) (string, int64, error)
        UpdateSyncTimeOnly(ctx context.Context, id int64) error
}

func NewPveStorageRepository(r *Repository) PveStorageRepository <span class="cov0" title="0">{
        return &amp;pveStorageRepository{Repository: r}
}</span>

type pveStorageRepository struct {
        *Repository
}

func (r *pveStorageRepository) Create(ctx context.Context, storage *model.PveStorage) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(storage).Error
}</span>

func (r *pveStorageRepository) Update(ctx context.Context, storage *model.PveStorage) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(storage).Error
}</span>

func (r *pveStorageRepository) GetByID(ctx context.Context, id int64) (*model.PveStorage, error) <span class="cov0" title="0">{
        var storage model.PveStorage
        if err := r.DB(ctx).Where("id = ?", id).First(&amp;storage).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;storage, nil</span>
}

func (r *pveStorageRepository) GetByStorageName(ctx context.Context, storageName string, nodeName string, clusterID int64) (*model.PveStorage, error) <span class="cov0" title="0">{
        var storage model.PveStorage
        if err := r.DB(ctx).Where("storage_name = ? AND node_name = ? AND cluster_id = ?", storageName, nodeName, clusterID).First(&amp;storage).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;storage, nil</span>
}

func (r *pveStorageRepository) GetByClusterID(ctx context.Context, clusterID int64) ([]*model.PveStorage, error) <span class="cov0" title="0">{
        var storages []*model.PveStorage
        if err := r.DB(ctx).Where("cluster_id = ?", clusterID).Find(&amp;storages).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return storages, nil</span>
}

func (r *pveStorageRepository) ListByStorageName(ctx context.Context, clusterID int64, storageName string) ([]*model.PveStorage, error) <span class="cov0" title="0">{
        var storages []*model.PveStorage
        if err := r.DB(ctx).Where("cluster_id = ? AND storage_name = ?", clusterID, storageName).Find(&amp;storages).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return storages, nil</span>
}

func (r *pveStorageRepository) Upsert(ctx context.Context, storage *model.PveStorage) error <span class="cov0" title="0">{
        // 先查询是否存在以及 hash
        existingHash, existingID, err := r.GetHashByStorageName(ctx, storage.StorageName, storage.NodeName, storage.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 如果不存在，创建新记录
        <span class="cov0" title="0">if existingID == 0 </span><span class="cov0" title="0">{
                return r.Create(ctx, storage)
        }</span>

        // 如果 hash 相同，只更新同步时间（轻量级更新）
        <span class="cov0" title="0">if existingHash != "" &amp;&amp; existingHash == storage.ResourceHash </span><span class="cov0" title="0">{
                storage.Id = existingID
                return r.UpdateSyncTimeOnly(ctx, existingID)
        }</span>

        // hash 不同，完整更新记录
        <span class="cov0" title="0">storage.Id = existingID
        return r.Update(ctx, storage)</span>
}

func (r *pveStorageRepository) GetHashByStorageName(ctx context.Context, storageName string, nodeName string, clusterID int64) (string, int64, error) <span class="cov0" title="0">{
        var result struct {
                Id           int64  `gorm:"column:id"`
                ResourceHash string `gorm:"column:resource_hash"`
        }

        err := r.DB(ctx).
                Table("pve_storage").
                Select("id, resource_hash").
                Where("storage_name = ? AND node_name = ? AND cluster_id = ?", storageName, nodeName, clusterID).
                First(&amp;result).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return "", 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov0" title="0">return result.ResourceHash, result.Id, nil</span>
}

func (r *pveStorageRepository) UpdateSyncTimeOnly(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).
                Model(&amp;model.PveStorage{}).
                Where("id = ?", id).
                Update("last_sync_time", time.Now()).Error
}</span>

func (r *pveStorageRepository) DeleteByStorageName(ctx context.Context, storageName string, nodeName string, clusterID int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("storage_name = ? AND node_name = ? AND cluster_id = ?", storageName, nodeName, clusterID).Delete(&amp;model.PveStorage{}).Error
}</span>

func (r *pveStorageRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("id = ?", id).Delete(&amp;model.PveStorage{}).Error
}</span>

func (r *pveStorageRepository) ListWithPagination(ctx context.Context, page, pageSize int, clusterID int64, nodeName, storageType, storageName string) ([]*model.PveStorage, int64, error) <span class="cov0" title="0">{
        var storages []*model.PveStorage
        var total int64

        query := r.DB(ctx).Model(&amp;model.PveStorage{})

        if clusterID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("cluster_id = ?", clusterID)
        }</span>
        <span class="cov0" title="0">if nodeName != "" </span><span class="cov0" title="0">{
                query = query.Where("node_name = ?", nodeName)
        }</span>
        <span class="cov0" title="0">if storageType != "" </span><span class="cov0" title="0">{
                query = query.Where("type = ?", storageType)
        }</span>
        <span class="cov0" title="0">if storageName != "" </span><span class="cov0" title="0">{
                query = query.Where("storage_name = ?", storageName)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize
        if err := query.Offset(offset).Limit(pageSize).Order("id DESC").Find(&amp;storages).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return storages, total, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "context"
        "errors"
        "pvesphere/internal/model"

        "gorm.io/gorm"
)

// PveTemplateRepository 模板仓储
type PveTemplateRepository interface {
        Create(ctx context.Context, tpl *model.PveTemplate) error
        Update(ctx context.Context, tpl *model.PveTemplate) error
        Delete(ctx context.Context, id int64) error
        GetByID(ctx context.Context, id int64) (*model.PveTemplate, error)
        ListWithPagination(ctx context.Context, page, pageSize int, clusterID int64) ([]*model.PveTemplate, int64, error)
}

func NewPveTemplateRepository(r *Repository) PveTemplateRepository <span class="cov0" title="0">{
        return &amp;pveTemplateRepository{Repository: r}
}</span>

type pveTemplateRepository struct {
        *Repository
}

func (r *pveTemplateRepository) Create(ctx context.Context, tpl *model.PveTemplate) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(tpl).Error
}</span>

func (r *pveTemplateRepository) Update(ctx context.Context, tpl *model.PveTemplate) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(tpl).Error
}</span>

func (r *pveTemplateRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("id = ?", id).Delete(&amp;model.PveTemplate{}).Error
}</span>

func (r *pveTemplateRepository) GetByID(ctx context.Context, id int64) (*model.PveTemplate, error) <span class="cov0" title="0">{
        var tpl model.PveTemplate
        if err := r.DB(ctx).Where("id = ?", id).First(&amp;tpl).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;tpl, nil</span>
}

func (r *pveTemplateRepository) ListWithPagination(ctx context.Context, page, pageSize int, clusterID int64) ([]*model.PveTemplate, int64, error) <span class="cov0" title="0">{
        var tpls []*model.PveTemplate
        var total int64

        query := r.DB(ctx).Model(&amp;model.PveTemplate{})
        if clusterID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("cluster_id = ?", clusterID)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize
        if err := query.Offset(offset).Limit(pageSize).Order("id DESC").Find(&amp;tpls).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return tpls, total, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "context"
        "errors"
        "pvesphere/internal/model"
        "time"

        "gorm.io/gorm"
)

type PveVMRepository interface {
        Create(ctx context.Context, vm *model.PveVM) error
        Update(ctx context.Context, vm *model.PveVM) error
        Delete(ctx context.Context, id int64) error
        GetByID(ctx context.Context, id int64) (*model.PveVM, error)
        GetByVMID(ctx context.Context, vmid uint32, nodeID int64) (*model.PveVM, error)               // 通过 VM ID 和节点 ID 查询
        GetByVMIDAndNodeName(ctx context.Context, vmid uint32, nodeName string) (*model.PveVM, error) // 通过 VM ID 和节点名称查询（向后兼容）
        GetByClusterID(ctx context.Context, clusterID int64) ([]*model.PveVM, error)                         // 通过集群 ID 查询
        GetByClusterName(ctx context.Context, clusterName string) ([]*model.PveVM, error)                    // 通过集群名称查询（向后兼容）
        ListWithPagination(ctx context.Context, page, pageSize int, clusterID int64, clusterName string, nodeID int64, nodeName string, templateID int64, status, appId string) ([]*model.PveVM, int64, error)
        Upsert(ctx context.Context, vm *model.PveVM) error
        DeleteByVMID(ctx context.Context, vmid uint32, nodeID int64) error
        GetHashByVMID(ctx context.Context, vmid uint32, nodeID int64) (string, int64, error)
        UpdateSyncTimeOnly(ctx context.Context, id int64) error
        GetTemplateVMByID(ctx context.Context, templateID, clusterID int64, nodeName string) (*model.PveVM, error) // 根据模板 ID、集群 ID 和节点名称查找模板虚拟机
        GetTemplateVM(ctx context.Context, templateName, clusterName string) (*model.PveVM, error)                 // 根据模板名称和集群名称查找模板虚拟机（向后兼容）
}

func NewPveVMRepository(r *Repository) PveVMRepository <span class="cov0" title="0">{
        return &amp;pveVMRepository{Repository: r}
}</span>

type pveVMRepository struct {
        *Repository
}

func (r *pveVMRepository) Create(ctx context.Context, vm *model.PveVM) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(vm).Error
}</span>

func (r *pveVMRepository) Update(ctx context.Context, vm *model.PveVM) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(vm).Error
}</span>

func (r *pveVMRepository) GetByID(ctx context.Context, id int64) (*model.PveVM, error) <span class="cov0" title="0">{
        var vm model.PveVM
        if err := r.DB(ctx).Where("id = ?", id).First(&amp;vm).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;vm, nil</span>
}

func (r *pveVMRepository) GetByVMID(ctx context.Context, vmid uint32, nodeID int64) (*model.PveVM, error) <span class="cov0" title="0">{
        var vm model.PveVM
        if err := r.DB(ctx).Where("vmid = ? AND node_id = ?", vmid, nodeID).First(&amp;vm).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;vm, nil</span>
}

func (r *pveVMRepository) GetByVMIDAndNodeName(ctx context.Context, vmid uint32, nodeName string) (*model.PveVM, error) <span class="cov0" title="0">{
        var vm model.PveVM
        // 通过 JOIN Node 表查询，使用 node_id 关联
        err := r.DB(ctx).
                Table("pve_vm").
                Select("pve_vm.*").
                Joins("JOIN pve_node ON pve_vm.node_id = pve_node.id").
                Where("pve_vm.vmid = ? AND pve_node.node_name = ?", vmid, nodeName).
                First(&amp;vm).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;vm, nil</span>
}

func (r *pveVMRepository) GetByClusterID(ctx context.Context, clusterID int64) ([]*model.PveVM, error) <span class="cov0" title="0">{
        var vms []*model.PveVM
        if err := r.DB(ctx).Where("cluster_id = ?", clusterID).Find(&amp;vms).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return vms, nil</span>
}

func (r *pveVMRepository) GetByClusterName(ctx context.Context, clusterName string) ([]*model.PveVM, error) <span class="cov0" title="0">{
        var vms []*model.PveVM
        if err := r.DB(ctx).Where("cluster_name = ?", clusterName).Find(&amp;vms).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return vms, nil</span>
}

func (r *pveVMRepository) Upsert(ctx context.Context, vm *model.PveVM) error <span class="cov0" title="0">{
        // 验证必要字段
        if vm.VMID == 0 </span><span class="cov0" title="0">{
                return errors.New("vmid is required")
        }</span>
        <span class="cov0" title="0">if vm.NodeID == 0 &amp;&amp; vm.NodeName == "" </span><span class="cov0" title="0">{
                return errors.New("node_id or node_name is required")
        }</span>

        // 先查询是否存在以及 hash
        <span class="cov0" title="0">var existingHash string
        var existingID int64
        var err error

        if vm.NodeID &gt; 0 </span><span class="cov0" title="0">{
                existingHash, existingID, err = r.GetHashByVMID(ctx, vm.VMID, vm.NodeID)
        }</span> else<span class="cov0" title="0"> if vm.NodeName != "" </span><span class="cov0" title="0">{
                // 向后兼容：如果 NodeID 为空，使用 NodeName
                existingHash, existingID, err = r.GetHashByVMIDAndNodeName(ctx, vm.VMID, vm.NodeName)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 如果不存在，创建新记录
        <span class="cov0" title="0">if existingID == 0 </span><span class="cov0" title="0">{
                // 使用事务确保唯一性（即使唯一索引存在，也要防止并发问题）
                return r.DB(ctx).Create(vm).Error
        }</span>

        // 如果 hash 相同，只更新同步时间（轻量级更新）
        <span class="cov0" title="0">if existingHash != "" &amp;&amp; existingHash == vm.ResourceHash </span><span class="cov0" title="0">{
                vm.Id = existingID
                return r.UpdateSyncTimeOnly(ctx, existingID)
        }</span>

        // hash 不同，完整更新记录
        <span class="cov0" title="0">vm.Id = existingID
        return r.Update(ctx, vm)</span>
}

func (r *pveVMRepository) GetHashByVMID(ctx context.Context, vmid uint32, nodeID int64) (string, int64, error) <span class="cov0" title="0">{
        var result struct {
                Id           int64  `gorm:"column:id"`
                ResourceHash string `gorm:"column:resource_hash"`
        }

        err := r.DB(ctx).
                Table("pve_vm").
                Select("id, resource_hash").
                Where("vmid = ? AND node_id = ?", vmid, nodeID).
                First(&amp;result).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return "", 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov0" title="0">return result.ResourceHash, result.Id, nil</span>
}

func (r *pveVMRepository) GetHashByVMIDAndNodeName(ctx context.Context, vmid uint32, nodeName string) (string, int64, error) <span class="cov0" title="0">{
        // 先通过 NodeName 查询 Node 获取 NodeID（需要知道 ClusterID，但这里没有，所以先尝试通过 VM 表查找）
        // 由于数据库表中已经没有 node_name 字段，我们需要通过 JOIN Node 表来查询
        var result struct {
                Id           int64  `gorm:"column:id"`
                ResourceHash string `gorm:"column:resource_hash"`
        }

        // 通过 JOIN Node 表查询，使用 node_id 关联
        err := r.DB(ctx).
                Table("pve_vm").
                Select("pve_vm.id, pve_vm.resource_hash").
                Joins("JOIN pve_node ON pve_vm.node_id = pve_node.id").
                Where("pve_vm.vmid = ? AND pve_node.node_name = ?", vmid, nodeName).
                First(&amp;result).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return "", 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov0" title="0">return result.ResourceHash, result.Id, nil</span>
}

func (r *pveVMRepository) UpdateSyncTimeOnly(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).
                Model(&amp;model.PveVM{}).
                Where("id = ?", id).
                Update("last_sync_time", time.Now()).Error
}</span>

func (r *pveVMRepository) DeleteByVMID(ctx context.Context, vmid uint32, nodeID int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("vmid = ? AND node_id = ?", vmid, nodeID).Delete(&amp;model.PveVM{}).Error
}</span>

func (r *pveVMRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("id = ?", id).Delete(&amp;model.PveVM{}).Error
}</span>

func (r *pveVMRepository) ListWithPagination(ctx context.Context, page, pageSize int, clusterID int64, clusterName string, nodeID int64, nodeName string, templateID int64, status, appId string) ([]*model.PveVM, int64, error) <span class="cov0" title="0">{
        var vms []*model.PveVM
        var total int64

        query := r.DB(ctx).Model(&amp;model.PveVM{})

        // 优先使用 ID 过滤，如果 ID 为空则使用名称（向后兼容）
        if clusterID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("cluster_id = ?", clusterID)
        }</span> else<span class="cov0" title="0"> if clusterName != "" </span><span class="cov0" title="0">{
                query = query.Where("cluster_name = ?", clusterName)
        }</span>

        <span class="cov0" title="0">if nodeID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("node_id = ?", nodeID)
        }</span> else<span class="cov0" title="0"> if nodeName != "" </span><span class="cov0" title="0">{
                query = query.Where("node_name = ?", nodeName)
        }</span>

        <span class="cov0" title="0">if templateID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("template_id = ?", templateID)
        }</span>

        <span class="cov0" title="0">if status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", status)
        }</span>
        <span class="cov0" title="0">if appId != "" </span><span class="cov0" title="0">{
                query = query.Where("appid = ?", appId)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize
        if err := query.Offset(offset).Limit(pageSize).Order("id DESC").Find(&amp;vms).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return vms, total, nil</span>
}

// GetTemplateVMByID 根据模板 ID、集群 ID 和节点名称查找模板虚拟机
// 模板虚拟机应该通过 vm_name 匹配模板名称来查找，而不是通过 template_id
// 因为 template_id 字段表示虚拟机是从哪个模板创建的，而不是模板虚拟机本身
func (r *pveVMRepository) GetTemplateVMByID(ctx context.Context, templateID, clusterID int64, nodeName string) (*model.PveVM, error) <span class="cov0" title="0">{
        // 通过 JOIN vm_template 和 pve_node 表来查询
        var vm model.PveVM
        query := r.DB(ctx).
                Table("pve_vm").
                Select("pve_vm.*").
                Joins("JOIN vm_template ON pve_vm.vm_name = vm_template.template_name").
                Joins("JOIN pve_node ON pve_vm.node_id = pve_node.id").
                Where("vm_template.id = ? AND pve_vm.cluster_id = ?", templateID, clusterID)

        // 如果提供了节点名称，则添加节点名称过滤条件
        if nodeName != "" </span><span class="cov0" title="0">{
                query = query.Where("pve_node.node_name = ?", nodeName)
        }</span>

        <span class="cov0" title="0">err := query.First(&amp;vm).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;vm, nil</span>
}

// GetTemplateVM 根据模板名称和集群名称查找模板虚拟机（向后兼容）
// 假设模板虚拟机在 pve_vm 表中，vm_name 或 template_name 字段等于模板名称
func (r *pveVMRepository) GetTemplateVM(ctx context.Context, templateName, clusterName string) (*model.PveVM, error) <span class="cov0" title="0">{
        var vm model.PveVM
        err := r.DB(ctx).
                Where("cluster_name = ? AND (vm_name = ? OR template_name = ?)", clusterName, templateName, templateName).
                First(&amp;vm).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;vm, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repository

import (
        "context"
        "fmt"
        "pvesphere/pkg/log"
        "pvesphere/pkg/zapgorm2"
        "time"

        "github.com/glebarez/sqlite"
        "github.com/redis/go-redis/v9"
        "github.com/spf13/viper"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "gorm.io/driver/mysql"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

const ctxTxKey = "TxKey"

type Repository struct {
        db *gorm.DB
        //rdb    *redis.Client
        //mongo  *mongo.Client
        logger *log.Logger
}

func NewRepository(
        logger *log.Logger,
        db *gorm.DB,
        // rdb *redis.Client,
        //
        //        mongo *mongo.Client,
) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db: db,
                //rdb:    rdb,
                //mongo:  mongo,
                logger: logger,
        }
}</span>

type Transaction interface {
        Transaction(ctx context.Context, fn func(ctx context.Context) error) error
}

func NewTransaction(r *Repository) Transaction <span class="cov0" title="0">{
        return r
}</span>

// DB return tx
// If you need to create a Transaction, you must call DB(ctx) and Transaction(ctx,fn)
func (r *Repository) DB(ctx context.Context) *gorm.DB <span class="cov8" title="1">{
        v := ctx.Value(ctxTxKey)
        if v != nil </span><span class="cov0" title="0">{
                if tx, ok := v.(*gorm.DB); ok </span><span class="cov0" title="0">{
                        return tx
                }</span>
        }
        <span class="cov8" title="1">return r.db.WithContext(ctx)</span>
}

func (r *Repository) Transaction(ctx context.Context, fn func(ctx context.Context) error) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, ctxTxKey, tx)
                return fn(ctx)
        }</span>)
}

func NewDB(conf *viper.Viper, l *log.Logger) *gorm.DB <span class="cov0" title="0">{
        var (
                db  *gorm.DB
                err error
        )

        logger := zapgorm2.New(l.Logger)
        driver := conf.GetString("data.db.user.driver")
        dsn := conf.GetString("data.db.user.dsn")

        // GORM doc: https://gorm.io/docs/connecting_to_the_database.html
        switch driver </span>{
        case "mysql":<span class="cov0" title="0">
                db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
                        Logger: logger,
                })</span>
        case "postgres":<span class="cov0" title="0">
                db, err = gorm.Open(postgres.New(postgres.Config{
                        DSN:                  dsn,
                        PreferSimpleProtocol: true, // disables implicit prepared statement usage
                }), &amp;gorm.Config{})</span>
        case "sqlite":<span class="cov0" title="0">
                db, err = gorm.Open(sqlite.Open(dsn), &amp;gorm.Config{})</span>
        default:<span class="cov0" title="0">
                panic("unknown db driver")</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">db = db.Debug()

        // Connection Pool config
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">sqlDB.SetMaxIdleConns(10)
        sqlDB.SetMaxOpenConns(100)
        sqlDB.SetConnMaxLifetime(time.Hour)
        return db</span>
}
func NewRedis(conf *viper.Viper) *redis.Client <span class="cov0" title="0">{
        rdb := redis.NewClient(&amp;redis.Options{
                Addr:     conf.GetString("data.redis.addr"),
                Password: conf.GetString("data.redis.password"),
                DB:       conf.GetInt("data.redis.db"),
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := rdb.Ping(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("redis error: %s", err.Error()))</span>
        }

        <span class="cov0" title="0">return rdb</span>
}
func NewMongo(conf *viper.Viper) (*mongo.Client, func(), error) <span class="cov0" title="0">{
        // https://www.mongodb.com/zh-cn/docs/drivers/go/current/
        uri := conf.GetString("data.mongo.uri")
        client, err := mongo.Connect(context.TODO(), options.Client().
                ApplyURI(uri))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("mongo client error: %s", err.Error()))</span>
        }

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        err = client.Ping(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("mongo ping error: %s", err.Error()))</span>
        }

        <span class="cov0" title="0">return client, func() </span><span class="cov0" title="0">{
                err = client.Disconnect(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("mongo disconnect error: %s", err.Error()))</span>
                }
        }, err
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "context"

        "pvesphere/internal/model"

        "gorm.io/gorm"
)

type TemplateInstanceRepository interface {
        Create(ctx context.Context, instance *model.TemplateInstance) error
        Update(ctx context.Context, instance *model.TemplateInstance) error
        Delete(ctx context.Context, id int64) error
        GetByID(ctx context.Context, id int64) (*model.TemplateInstance, error)
        GetByTemplateAndNode(ctx context.Context, templateID, nodeID int64) (*model.TemplateInstance, error)
        ListByTemplateID(ctx context.Context, templateID int64) ([]*model.TemplateInstance, error)
        ListByNodeID(ctx context.Context, nodeID int64) ([]*model.TemplateInstance, error)
        GetPrimaryInstance(ctx context.Context, templateID int64) (*model.TemplateInstance, error)
        UpdateStatus(ctx context.Context, id int64, status string) error
        UpdateSyncTask(ctx context.Context, id int64, syncTaskID int64) error
        DeleteByTemplateID(ctx context.Context, templateID int64) error
}

func NewTemplateInstanceRepository(
        repository *Repository,
) TemplateInstanceRepository <span class="cov0" title="0">{
        return &amp;templateInstanceRepository{
                Repository: repository,
        }
}</span>

type templateInstanceRepository struct {
        *Repository
}

func (r *templateInstanceRepository) Create(ctx context.Context, instance *model.TemplateInstance) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(instance).Error
}</span>

func (r *templateInstanceRepository) Update(ctx context.Context, instance *model.TemplateInstance) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(instance).Error
}</span>

func (r *templateInstanceRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Delete(&amp;model.TemplateInstance{}, id).Error
}</span>

func (r *templateInstanceRepository) GetByID(ctx context.Context, id int64) (*model.TemplateInstance, error) <span class="cov0" title="0">{
        var instance model.TemplateInstance
        err := r.DB(ctx).Where("id = ?", id).First(&amp;instance).Error
        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;instance, nil</span>
}

func (r *templateInstanceRepository) GetByTemplateAndNode(ctx context.Context, templateID, nodeID int64) (*model.TemplateInstance, error) <span class="cov0" title="0">{
        var instance model.TemplateInstance
        err := r.DB(ctx).Where("template_id = ? AND node_id = ?", templateID, nodeID).
                First(&amp;instance).Error
        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;instance, nil</span>
}

func (r *templateInstanceRepository) ListByTemplateID(ctx context.Context, templateID int64) ([]*model.TemplateInstance, error) <span class="cov0" title="0">{
        var instances []*model.TemplateInstance
        err := r.DB(ctx).Where("template_id = ?", templateID).
                Order("is_primary DESC, gmt_create ASC").
                Find(&amp;instances).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return instances, nil</span>
}

func (r *templateInstanceRepository) ListByNodeID(ctx context.Context, nodeID int64) ([]*model.TemplateInstance, error) <span class="cov0" title="0">{
        var instances []*model.TemplateInstance
        err := r.DB(ctx).Where("node_id = ?", nodeID).
                Order("gmt_create DESC").
                Find(&amp;instances).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return instances, nil</span>
}

func (r *templateInstanceRepository) GetPrimaryInstance(ctx context.Context, templateID int64) (*model.TemplateInstance, error) <span class="cov0" title="0">{
        var instance model.TemplateInstance
        err := r.DB(ctx).Where("template_id = ? AND is_primary = 1", templateID).
                First(&amp;instance).Error
        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;instance, nil</span>
}

func (r *templateInstanceRepository) UpdateStatus(ctx context.Context, id int64, status string) error <span class="cov0" title="0">{
        return r.DB(ctx).Model(&amp;model.TemplateInstance{}).
                Where("id = ?", id).
                Update("status", status).Error
}</span>

func (r *templateInstanceRepository) UpdateSyncTask(ctx context.Context, id int64, syncTaskID int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Model(&amp;model.TemplateInstance{}).
                Where("id = ?", id).
                Update("sync_task_id", syncTaskID).Error
}</span>

func (r *templateInstanceRepository) DeleteByTemplateID(ctx context.Context, templateID int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("template_id = ?", templateID).
                Delete(&amp;model.TemplateInstance{}).Error
}</span>

</pre>
		
		<pre class="file" id="file18" style="display: none">package repository

import (
        "context"
        "time"

        "pvesphere/internal/model"

        "gorm.io/gorm"
)

type TemplateSyncTaskRepository interface {
        Create(ctx context.Context, task *model.TemplateSyncTask) error
        Update(ctx context.Context, task *model.TemplateSyncTask) error
        Delete(ctx context.Context, id int64) error
        GetByID(ctx context.Context, id int64) (*model.TemplateSyncTask, error)
        ListByTemplateID(ctx context.Context, templateID int64) ([]*model.TemplateSyncTask, error)
        ListByStatus(ctx context.Context, status string) ([]*model.TemplateSyncTask, error)
        ListWithPagination(ctx context.Context, page, pageSize int, templateID *int64, status string) ([]*model.TemplateSyncTask, int64, error)
        UpdateStatus(ctx context.Context, id int64, status string, progress int, errorMsg string) error
        UpdateSyncTime(ctx context.Context, id int64, startTime, endTime *time.Time) error
        GetPendingTasks(ctx context.Context, limit int) ([]*model.TemplateSyncTask, error)
}

func NewTemplateSyncTaskRepository(
        repository *Repository,
) TemplateSyncTaskRepository <span class="cov0" title="0">{
        return &amp;templateSyncTaskRepository{
                Repository: repository,
        }
}</span>

type templateSyncTaskRepository struct {
        *Repository
}

func (r *templateSyncTaskRepository) Create(ctx context.Context, task *model.TemplateSyncTask) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(task).Error
}</span>

func (r *templateSyncTaskRepository) Update(ctx context.Context, task *model.TemplateSyncTask) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(task).Error
}</span>

func (r *templateSyncTaskRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Delete(&amp;model.TemplateSyncTask{}, id).Error
}</span>

func (r *templateSyncTaskRepository) GetByID(ctx context.Context, id int64) (*model.TemplateSyncTask, error) <span class="cov0" title="0">{
        var task model.TemplateSyncTask
        err := r.DB(ctx).Where("id = ?", id).First(&amp;task).Error
        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;task, nil</span>
}

func (r *templateSyncTaskRepository) ListByTemplateID(ctx context.Context, templateID int64) ([]*model.TemplateSyncTask, error) <span class="cov0" title="0">{
        var tasks []*model.TemplateSyncTask
        err := r.DB(ctx).Where("template_id = ?", templateID).
                Order("gmt_create DESC").
                Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *templateSyncTaskRepository) ListByStatus(ctx context.Context, status string) ([]*model.TemplateSyncTask, error) <span class="cov0" title="0">{
        var tasks []*model.TemplateSyncTask
        err := r.DB(ctx).Where("status = ?", status).
                Order("gmt_create ASC").
                Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *templateSyncTaskRepository) ListWithPagination(ctx context.Context, page, pageSize int, templateID *int64, status string) ([]*model.TemplateSyncTask, int64, error) <span class="cov0" title="0">{
        var tasks []*model.TemplateSyncTask
        var total int64

        query := r.DB(ctx).Model(&amp;model.TemplateSyncTask{})

        // 条件过滤
        if templateID != nil &amp;&amp; *templateID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("template_id = ?", *templateID)
        }</span>
        <span class="cov0" title="0">if status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", status)
        }</span>

        // 统计总数
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 分页查询
        <span class="cov0" title="0">offset := (page - 1) * pageSize
        if err := query.Order("gmt_create DESC").
                Offset(offset).
                Limit(pageSize).
                Find(&amp;tasks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return tasks, total, nil</span>
}

func (r *templateSyncTaskRepository) UpdateStatus(ctx context.Context, id int64, status string, progress int, errorMsg string) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "status":   status,
                "progress": progress,
        }
        if errorMsg != "" </span><span class="cov0" title="0">{
                updates["error_message"] = errorMsg
        }</span>
        <span class="cov0" title="0">return r.DB(ctx).Model(&amp;model.TemplateSyncTask{}).
                Where("id = ?", id).
                Updates(updates).Error</span>
}

func (r *templateSyncTaskRepository) UpdateSyncTime(ctx context.Context, id int64, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        updates := map[string]interface{}{}
        if startTime != nil </span><span class="cov0" title="0">{
                updates["sync_start_time"] = startTime
        }</span>
        <span class="cov0" title="0">if endTime != nil </span><span class="cov0" title="0">{
                updates["sync_end_time"] = endTime
        }</span>
        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.DB(ctx).Model(&amp;model.TemplateSyncTask{}).
                Where("id = ?", id).
                Updates(updates).Error</span>
}

func (r *templateSyncTaskRepository) GetPendingTasks(ctx context.Context, limit int) ([]*model.TemplateSyncTask, error) <span class="cov0" title="0">{
        var tasks []*model.TemplateSyncTask
        err := r.DB(ctx).Where("status = ?", model.TemplateSyncTaskStatusPending).
                Order("gmt_create ASC").
                Limit(limit).
                Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tasks, nil</span>
}

</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "context"

        "pvesphere/internal/model"

        "gorm.io/gorm"
)

type TemplateUploadRepository interface {
        Create(ctx context.Context, upload *model.TemplateUpload) error
        Update(ctx context.Context, upload *model.TemplateUpload) error
        Delete(ctx context.Context, id int64) error
        GetByID(ctx context.Context, id int64) (*model.TemplateUpload, error)
        GetByTemplateID(ctx context.Context, templateID int64) (*model.TemplateUpload, error)
        ListByClusterID(ctx context.Context, clusterID int64) ([]*model.TemplateUpload, error)
        UpdateStatus(ctx context.Context, id int64, status string, progress int, errorMsg string) error
}

func NewTemplateUploadRepository(
        repository *Repository,
) TemplateUploadRepository <span class="cov0" title="0">{
        return &amp;templateUploadRepository{
                Repository: repository,
        }
}</span>

type templateUploadRepository struct {
        *Repository
}

func (r *templateUploadRepository) Create(ctx context.Context, upload *model.TemplateUpload) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(upload).Error
}</span>

func (r *templateUploadRepository) Update(ctx context.Context, upload *model.TemplateUpload) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(upload).Error
}</span>

func (r *templateUploadRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Delete(&amp;model.TemplateUpload{}, id).Error
}</span>

func (r *templateUploadRepository) GetByID(ctx context.Context, id int64) (*model.TemplateUpload, error) <span class="cov0" title="0">{
        var upload model.TemplateUpload
        err := r.DB(ctx).Where("id = ?", id).First(&amp;upload).Error
        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;upload, nil</span>
}

func (r *templateUploadRepository) GetByTemplateID(ctx context.Context, templateID int64) (*model.TemplateUpload, error) <span class="cov0" title="0">{
        var upload model.TemplateUpload
        err := r.DB(ctx).Where("template_id = ?", templateID).
                Order("gmt_create DESC").
                First(&amp;upload).Error
        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;upload, nil</span>
}

func (r *templateUploadRepository) ListByClusterID(ctx context.Context, clusterID int64) ([]*model.TemplateUpload, error) <span class="cov0" title="0">{
        var uploads []*model.TemplateUpload
        err := r.DB(ctx).Where("cluster_id = ?", clusterID).
                Order("gmt_create DESC").
                Find(&amp;uploads).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return uploads, nil</span>
}

func (r *templateUploadRepository) UpdateStatus(ctx context.Context, id int64, status string, progress int, errorMsg string) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "status":          status,
                "import_progress": progress,
        }
        if errorMsg != "" </span><span class="cov0" title="0">{
                updates["error_message"] = errorMsg
        }</span>
        <span class="cov0" title="0">return r.DB(ctx).Model(&amp;model.TemplateUpload{}).
                Where("id = ?", id).
                Updates(updates).Error</span>
}

</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "context"
        "errors"
        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"

        "gorm.io/gorm"
)

type UserRepository interface {
        Create(ctx context.Context, user *model.User) error
        Update(ctx context.Context, user *model.User) error
        GetByID(ctx context.Context, id string) (*model.User, error)
        GetByEmail(ctx context.Context, email string) (*model.User, error)
}

func NewUserRepository(
        r *Repository,
) UserRepository <span class="cov8" title="1">{
        return &amp;userRepository{
                Repository: r,
        }
}</span>

type userRepository struct {
        *Repository
}

func (r *userRepository) Create(ctx context.Context, user *model.User) error <span class="cov8" title="1">{
        if err := r.DB(ctx).Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *userRepository) Update(ctx context.Context, user *model.User) error <span class="cov8" title="1">{
        if err := r.DB(ctx).Save(user).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *userRepository) GetByID(ctx context.Context, userId string) (*model.User, error) <span class="cov8" title="1">{
        var user model.User
        if err := r.DB(ctx).Where("user_id = ?", userId).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, v1.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *userRepository) GetByEmail(ctx context.Context, email string) (*model.User, error) <span class="cov8" title="1">{
        var user model.User
        if err := r.DB(ctx).Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "context"
        "errors"
        "pvesphere/internal/model"

        "gorm.io/gorm"
)

type VMIPAddressRepository interface {
        Create(ctx context.Context, ip *model.VMIPAddress) error
        Update(ctx context.Context, ip *model.VMIPAddress) error
        GetByID(ctx context.Context, id int64) (*model.VMIPAddress, error)
        GetByVMID(ctx context.Context, vmID int64) ([]*model.VMIPAddress, error)
        DeleteByVMID(ctx context.Context, vmID int64) error
}

func NewVMIPAddressRepository(r *Repository) VMIPAddressRepository <span class="cov0" title="0">{
        return &amp;vmIPAddressRepository{Repository: r}
}</span>

type vmIPAddressRepository struct {
        *Repository
}

func (r *vmIPAddressRepository) Create(ctx context.Context, ip *model.VMIPAddress) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(ip).Error
}</span>

func (r *vmIPAddressRepository) Update(ctx context.Context, ip *model.VMIPAddress) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(ip).Error
}</span>

func (r *vmIPAddressRepository) GetByID(ctx context.Context, id int64) (*model.VMIPAddress, error) <span class="cov0" title="0">{
        var ip model.VMIPAddress
        if err := r.DB(ctx).Where("id = ?", id).First(&amp;ip).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;ip, nil</span>
}

func (r *vmIPAddressRepository) GetByVMID(ctx context.Context, vmID int64) ([]*model.VMIPAddress, error) <span class="cov0" title="0">{
        var ips []*model.VMIPAddress
        if err := r.DB(ctx).Where("vm_id = ?", vmID).Find(&amp;ips).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ips, nil</span>
}

func (r *vmIPAddressRepository) DeleteByVMID(ctx context.Context, vmID int64) error <span class="cov0" title="0">{
        return r.DB(ctx).Where("vm_id = ?", vmID).Delete(&amp;model.VMIPAddress{}).Error
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "context"
        "errors"
        "pvesphere/internal/model"

        "gorm.io/gorm"
)

type VmTemplateRepository interface {
        Create(ctx context.Context, template *model.VmTemplate) error
        Update(ctx context.Context, template *model.VmTemplate) error
        GetByID(ctx context.Context, id int64) (*model.VmTemplate, error)
        GetByTemplateName(ctx context.Context, templateName string, clusterID int64) (*model.VmTemplate, error)
        GetByClusterID(ctx context.Context, clusterID int64) ([]*model.VmTemplate, error)
        GetByIDs(ctx context.Context, ids []int64) (map[int64]*model.VmTemplate, error) // 批量查询模板，返回 map[id]*template
}

func NewVmTemplateRepository(r *Repository) VmTemplateRepository <span class="cov0" title="0">{
        return &amp;vmTemplateRepository{Repository: r}
}</span>

type vmTemplateRepository struct {
        *Repository
}

func (r *vmTemplateRepository) Create(ctx context.Context, template *model.VmTemplate) error <span class="cov0" title="0">{
        return r.DB(ctx).Create(template).Error
}</span>

func (r *vmTemplateRepository) Update(ctx context.Context, template *model.VmTemplate) error <span class="cov0" title="0">{
        return r.DB(ctx).Save(template).Error
}</span>

func (r *vmTemplateRepository) GetByID(ctx context.Context, id int64) (*model.VmTemplate, error) <span class="cov0" title="0">{
        var template model.VmTemplate
        if err := r.DB(ctx).Where("id = ?", id).First(&amp;template).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;template, nil</span>
}

func (r *vmTemplateRepository) GetByTemplateName(ctx context.Context, templateName string, clusterID int64) (*model.VmTemplate, error) <span class="cov0" title="0">{
        var template model.VmTemplate
        if err := r.DB(ctx).Where("template_name = ? AND cluster_id = ?", templateName, clusterID).First(&amp;template).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;template, nil</span>
}

func (r *vmTemplateRepository) GetByClusterID(ctx context.Context, clusterID int64) ([]*model.VmTemplate, error) <span class="cov0" title="0">{
        var templates []*model.VmTemplate
        if err := r.DB(ctx).Where("cluster_id = ?", clusterID).Find(&amp;templates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return templates, nil</span>
}

// GetByIDs 批量查询模板，返回 map[id]*template，用于批量填充名称
func (r *vmTemplateRepository) GetByIDs(ctx context.Context, ids []int64) (map[int64]*model.VmTemplate, error) <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return make(map[int64]*model.VmTemplate), nil
        }</span>

        <span class="cov0" title="0">var templates []*model.VmTemplate
        if err := r.DB(ctx).Where("id IN ?", ids).Find(&amp;templates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make(map[int64]*model.VmTemplate, len(templates))
        for _, template := range templates </span><span class="cov0" title="0">{
                result[template.Id] = template
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "context"
        "fmt"
        "sort"
        "strings"
        "time"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"
        "pvesphere/internal/repository"
        "pvesphere/pkg/log"
        "pvesphere/pkg/proxmox"

        "go.uber.org/zap"
)

type DashboardService interface {
        GetScopes(ctx context.Context) (*v1.DashboardScopesData, error)
        GetOverview(ctx context.Context, req *v1.DashboardOverviewRequest) (*v1.DashboardOverviewData, error)
        GetResources(ctx context.Context, req *v1.DashboardResourcesRequest) (*v1.DashboardResourcesData, error)
        GetHotspots(ctx context.Context, req *v1.DashboardHotspotsRequest) (*v1.DashboardHotspotsData, error)
        GetOperations(ctx context.Context, req *v1.DashboardOperationsRequest) (*v1.DashboardOperationsData, error)
}

func NewDashboardService(
        service *Service,
        clusterRepo repository.PveClusterRepository,
        nodeRepo repository.PveNodeRepository,
        vmRepo repository.PveVMRepository,
        storageRepo repository.PveStorageRepository,
        logger *log.Logger,
) DashboardService <span class="cov0" title="0">{
        return &amp;dashboardService{
                clusterRepo: clusterRepo,
                nodeRepo:    nodeRepo,
                vmRepo:      vmRepo,
                storageRepo: storageRepo,
                Service:     service,
                logger:      logger,
        }
}</span>

type dashboardService struct {
        clusterRepo repository.PveClusterRepository
        nodeRepo    repository.PveNodeRepository
        vmRepo      repository.PveVMRepository
        storageRepo repository.PveStorageRepository
        *Service
        logger *log.Logger
}

// GetScopes 获取可选集群列表
func (s *dashboardService) GetScopes(ctx context.Context) (*v1.DashboardScopesData, error) <span class="cov0" title="0">{
        clusters, err := s.clusterRepo.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list clusters", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">items := make([]v1.ScopeItem, 0, len(clusters))
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                items = append(items, v1.ScopeItem{
                        ClusterID:        cluster.Id,
                        ClusterName:      cluster.ClusterName,
                        ClusterNameAlias: cluster.ClusterNameAlias,
                })
        }</span>

        <span class="cov0" title="0">return &amp;v1.DashboardScopesData{
                Items: items,
        }, nil</span>
}

// GetOverview 获取全局概览
func (s *dashboardService) GetOverview(ctx context.Context, req *v1.DashboardOverviewRequest) (*v1.DashboardOverviewData, error) <span class="cov0" title="0">{
        var clusters []*model.PveCluster
        var err error

        // 根据 scope 获取集群列表
        if req.Scope == "cluster" &amp;&amp; req.ClusterID != nil </span><span class="cov0" title="0">{
                cluster, err := s.clusterRepo.GetByID(ctx, *req.ClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
                <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                        return nil, v1.ErrNotFound
                }</span>
                <span class="cov0" title="0">clusters = []*model.PveCluster{cluster}</span>
        } else<span class="cov0" title="0"> {
                clusters, err = s.clusterRepo.List(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to list clusters", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
        }

        // 统计概览数据
        <span class="cov0" title="0">summary := v1.DashboardOverviewSummary{
                ClusterCount: int64(len(clusters)),
        }

        // 健康状态统计
        health := v1.DashboardOverviewHealth{
                Healthy:  0,
                Warning:  0,
                Critical: 0,
        }

        // 遍历集群,统计节点、虚拟机、存储数量
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                // 统计节点数量
                nodes, err := s.nodeRepo.GetByClusterID(ctx, cluster.Id)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get nodes for cluster",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }
                <span class="cov0" title="0">summary.NodeCount += int64(len(nodes))

                // 统计虚拟机数量
                vms, err := s.vmRepo.GetByClusterID(ctx, cluster.Id)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get vms for cluster",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }
                <span class="cov0" title="0">summary.VMCount += int64(len(vms))

                // 统计存储数量
                storages, err := s.storageRepo.GetByClusterID(ctx, cluster.Id)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get storages for cluster",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }
                <span class="cov0" title="0">summary.StorageCount += int64(len(storages))

                // 评估集群健康状态（简单实现，可以后续扩展）
                clusterHealth := s.evaluateClusterHealth(ctx, cluster, nodes)
                switch clusterHealth </span>{
                case "healthy":<span class="cov0" title="0">
                        health.Healthy++</span>
                case "warning":<span class="cov0" title="0">
                        health.Warning++</span>
                case "critical":<span class="cov0" title="0">
                        health.Critical++</span>
                }
        }

        <span class="cov0" title="0">return &amp;v1.DashboardOverviewData{
                Scope:     req.Scope,
                ClusterID: req.ClusterID,
                Summary:   summary,
                Health:    health,
        }, nil</span>
}

// evaluateClusterHealth 评估集群健康状态
func (s *dashboardService) evaluateClusterHealth(ctx context.Context, cluster *model.PveCluster, nodes []*model.PveNode) string <span class="cov0" title="0">{
        // 简单的健康评估逻辑
        // 1. 检查集群是否启用
        if cluster.IsEnabled != 1 </span><span class="cov0" title="0">{
                return "warning"
        }</span>

        // 2. 检查节点状态
        <span class="cov0" title="0">offlineNodes := 0
        for _, node := range nodes </span><span class="cov0" title="0">{
                if node.Status != "online" </span><span class="cov0" title="0">{
                        offlineNodes++
                }</span>
        }

        <span class="cov0" title="0">if offlineNodes == len(nodes) &amp;&amp; len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                return "critical"
        }</span> else<span class="cov0" title="0"> if offlineNodes &gt; 0 </span><span class="cov0" title="0">{
                return "warning"
        }</span>

        <span class="cov0" title="0">return "healthy"</span>
}

// GetResources 获取资源使用率
func (s *dashboardService) GetResources(ctx context.Context, req *v1.DashboardResourcesRequest) (*v1.DashboardResourcesData, error) <span class="cov0" title="0">{
        var clusters []*model.PveCluster
        var err error

        // 根据 scope 获取集群列表
        if req.Scope == "cluster" &amp;&amp; req.ClusterID != nil </span><span class="cov0" title="0">{
                cluster, err := s.clusterRepo.GetByID(ctx, *req.ClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
                <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                        return nil, v1.ErrNotFound
                }</span>
                <span class="cov0" title="0">clusters = []*model.PveCluster{cluster}</span>
        } else<span class="cov0" title="0"> {
                clusters, err = s.clusterRepo.List(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to list clusters", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
        }

        // 统计资源使用情况
        <span class="cov0" title="0">var totalCPUCores, usedCPUCores float64
        var totalMemory, usedMemory int64
        var totalStorage, usedStorage int64

        // 遍历集群,通过 Proxmox API 获取实时资源数据
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                // 创建 Proxmox 客户端
                client, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to create proxmox client",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }

                // 获取集群资源
                <span class="cov0" title="0">resources, err := client.GetClusterResources(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get cluster resources",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }

                // 聚合节点资源
                <span class="cov0" title="0">for _, resource := range resources </span><span class="cov0" title="0">{
                        resourceType, _ := resource["type"].(string)
                        if resourceType != "node" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // CPU
                        <span class="cov0" title="0">if maxcpu, ok := resource["maxcpu"].(float64); ok </span><span class="cov0" title="0">{
                                totalCPUCores += maxcpu
                        }</span>
                        <span class="cov0" title="0">if cpu, ok := resource["cpu"].(float64); ok </span><span class="cov0" title="0">{
                                if maxcpu, ok := resource["maxcpu"].(float64); ok </span><span class="cov0" title="0">{
                                        usedCPUCores += cpu * maxcpu
                                }</span>
                        }

                        // 内存
                        <span class="cov0" title="0">if maxmem, ok := resource["maxmem"].(float64); ok </span><span class="cov0" title="0">{
                                totalMemory += int64(maxmem)
                        }</span>
                        <span class="cov0" title="0">if mem, ok := resource["mem"].(float64); ok </span><span class="cov0" title="0">{
                                usedMemory += int64(mem)
                        }</span>

                        // 存储
                        <span class="cov0" title="0">if maxdisk, ok := resource["maxdisk"].(float64); ok </span><span class="cov0" title="0">{
                                totalStorage += int64(maxdisk)
                        }</span>
                        <span class="cov0" title="0">if disk, ok := resource["disk"].(float64); ok </span><span class="cov0" title="0">{
                                usedStorage += int64(disk)
                        }</span>
                }
        }

        // 计算使用率
        <span class="cov0" title="0">cpuUsagePercent := 0.0
        if totalCPUCores &gt; 0 </span><span class="cov0" title="0">{
                cpuUsagePercent = (usedCPUCores / totalCPUCores) * 100
        }</span>

        <span class="cov0" title="0">memoryUsagePercent := 0.0
        if totalMemory &gt; 0 </span><span class="cov0" title="0">{
                memoryUsagePercent = (float64(usedMemory) / float64(totalMemory)) * 100
        }</span>

        <span class="cov0" title="0">storageUsagePercent := 0.0
        if totalStorage &gt; 0 </span><span class="cov0" title="0">{
                storageUsagePercent = (float64(usedStorage) / float64(totalStorage)) * 100
        }</span>

        <span class="cov0" title="0">return &amp;v1.DashboardResourcesData{
                Scope:     req.Scope,
                ClusterID: req.ClusterID,
                CPU: v1.ResourceUsage{
                        UsedCores:    &amp;usedCPUCores,
                        TotalCores:   &amp;totalCPUCores,
                        UsagePercent: cpuUsagePercent,
                },
                Memory: v1.ResourceUsage{
                        UsedBytes:    &amp;usedMemory,
                        TotalBytes:   &amp;totalMemory,
                        UsagePercent: memoryUsagePercent,
                },
                Storage: v1.ResourceUsage{
                        UsedBytes:    &amp;usedStorage,
                        TotalBytes:   &amp;totalStorage,
                        UsagePercent: storageUsagePercent,
                },
        }, nil</span>
}

// GetHotspots 获取压力和风险焦点
func (s *dashboardService) GetHotspots(ctx context.Context, req *v1.DashboardHotspotsRequest) (*v1.DashboardHotspotsData, error) <span class="cov0" title="0">{
        var clusters []*model.PveCluster
        var err error

        // 设置默认 limit
        if req.Limit &lt;= 0 </span><span class="cov0" title="0">{
                req.Limit = 5
        }</span>

        // 根据 scope 获取集群列表
        <span class="cov0" title="0">if req.Scope == "cluster" &amp;&amp; req.ClusterID != nil </span><span class="cov0" title="0">{
                cluster, err := s.clusterRepo.GetByID(ctx, *req.ClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
                <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                        return nil, v1.ErrNotFound
                }</span>
                <span class="cov0" title="0">clusters = []*model.PveCluster{cluster}</span>
        } else<span class="cov0" title="0"> {
                clusters, err = s.clusterRepo.List(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to list clusters", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
        }

        // 分别收集各类资源的使用率
        <span class="cov0" title="0">type vmResource struct {
                ID          string
                Name        string
                NodeName    string
                ClusterID   int64
                ClusterName string
                MetricValue float64
                Unit        string
        }

        type nodeResource struct {
                ID          string
                Name        string
                ClusterID   int64
                ClusterName string
                MetricValue float64
                Unit        string
        }

        type storageResource struct {
                ID           string
                Name         string
                UsagePercent float64
                UsedBytes    int64
                TotalBytes   int64
                Unit         string
        }

        // 分别收集 VM 的 CPU、Memory
        var vmCPU []vmResource
        var vmMemory []vmResource

        // 分别收集 Node 的 CPU、Memory
        var nodeCPU []nodeResource
        var nodeMemory []nodeResource

        // 收集 Storage
        var storages []storageResource

        // 遍历集群,获取资源消耗数据
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                // 创建 Proxmox 客户端
                client, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to create proxmox client",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }

                // 1. 获取节点资源（CPU 和 Memory）
                // 使用 GetClusterResources 获取节点数据，因为 GetNodeStatus 可能不包含完整的内存信息
                <span class="cov0" title="0">nodeResources, err := client.GetClusterResources(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get cluster resources",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                }</span> else<span class="cov0" title="0"> {
                        // 从数据库获取节点列表，用于匹配和填充集群信息
                        nodes, err := s.nodeRepo.GetByClusterID(ctx, cluster.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Warn("failed to get nodes from database",
                                        zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        }</span>

                        // 创建节点名称映射，用于快速查找
                        <span class="cov0" title="0">nodeMap := make(map[string]*model.PveNode)
                        for _, node := range nodes </span><span class="cov0" title="0">{
                                nodeMap[node.NodeName] = node
                        }</span>

                        // 遍历资源，查找节点
                        <span class="cov0" title="0">for _, resource := range nodeResources </span><span class="cov0" title="0">{
                                resourceType, _ := resource["type"].(string)
                                if resourceType != "node" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">nodeName, _ := resource["name"].(string)
                                if nodeName == "" </span><span class="cov0" title="0">{
                                        // 如果没有 name 字段，尝试从 id 字段获取（格式可能是 "node/pve01"）
                                        id, _ := resource["id"].(string)
                                        if strings.HasPrefix(id, "node/") </span><span class="cov0" title="0">{
                                                nodeName = strings.TrimPrefix(id, "node/")
                                        }</span>
                                }

                                <span class="cov0" title="0">if nodeName == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // 节点 CPU 使用率
                                <span class="cov0" title="0">if cpu, ok := resource["cpu"].(float64); ok </span><span class="cov0" title="0">{
                                        cpuPercent := cpu * 100
                                        nodeCPU = append(nodeCPU, nodeResource{
                                                ID:          fmt.Sprintf("node/%s", nodeName),
                                                Name:        nodeName,
                                                ClusterID:   cluster.Id,
                                                ClusterName: cluster.ClusterName,
                                                MetricValue: cpuPercent,
                                                Unit:        "%",
                                        })
                                }</span>

                                // 节点内存使用率
                                // GetClusterResources 返回的字段是 mem 和 maxmem
                                <span class="cov0" title="0">var mem, maxmem float64

                                // 尝试多种类型转换
                                if memVal, ok := resource["mem"].(float64); ok </span><span class="cov0" title="0">{
                                        mem = memVal
                                }</span> else<span class="cov0" title="0"> if memVal, ok := resource["mem"].(int64); ok </span><span class="cov0" title="0">{
                                        mem = float64(memVal)
                                }</span> else<span class="cov0" title="0"> if memVal, ok := resource["mem"].(int); ok </span><span class="cov0" title="0">{
                                        mem = float64(memVal)
                                }</span>

                                <span class="cov0" title="0">if maxmemVal, ok := resource["maxmem"].(float64); ok </span><span class="cov0" title="0">{
                                        maxmem = maxmemVal
                                }</span> else<span class="cov0" title="0"> if maxmemVal, ok := resource["maxmem"].(int64); ok </span><span class="cov0" title="0">{
                                        maxmem = float64(maxmemVal)
                                }</span> else<span class="cov0" title="0"> if maxmemVal, ok := resource["maxmem"].(int); ok </span><span class="cov0" title="0">{
                                        maxmem = float64(maxmemVal)
                                }</span>

                                // 只有当两个值都有效时才计算使用率
                                <span class="cov0" title="0">if mem &gt;= 0 &amp;&amp; maxmem &gt; 0 </span><span class="cov0" title="0">{
                                        memPercent := (mem / maxmem) * 100
                                        nodeMemory = append(nodeMemory, nodeResource{
                                                ID:          fmt.Sprintf("node/%s", nodeName),
                                                Name:        nodeName,
                                                ClusterID:   cluster.Id,
                                                ClusterName: cluster.ClusterName,
                                                MetricValue: memPercent,
                                                Unit:        "%",
                                        })
                                }</span> else<span class="cov0" title="0"> {
                                        // 添加调试日志，帮助排查问题
                                        s.logger.WithContext(ctx).Debug("failed to get node memory data from cluster resources",
                                                zap.String("node", nodeName),
                                                zap.Any("resource", resource),
                                                zap.Float64("mem", mem),
                                                zap.Float64("maxmem", maxmem))
                                }</span>
                        }
                }

                // 2. 获取存储资源
                <span class="cov0" title="0">dbStorages, err := s.storageRepo.GetByClusterID(ctx, cluster.Id)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get storages from database",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                }</span> else<span class="cov0" title="0"> {
                        resources, err := client.GetClusterResources(ctx)
                        if err == nil </span><span class="cov0" title="0">{
                                // 创建存储映射，用于快速查找
                                storageMap := make(map[string]*model.PveStorage)
                                for _, storage := range dbStorages </span><span class="cov0" title="0">{
                                        key := fmt.Sprintf("%s:%s", storage.NodeName, storage.StorageName)
                                        storageMap[key] = storage
                                }</span>

                                // 遍历资源，查找存储
                                <span class="cov0" title="0">for _, resource := range resources </span><span class="cov0" title="0">{
                                        resourceType, _ := resource["type"].(string)
                                        if resourceType != "storage" </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">storageName, _ := resource["storage"].(string)
                                        nodeName, _ := resource["node"].(string)
                                        if storageName == "" || nodeName == "" </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        // 检查是否在数据库中存在
                                        <span class="cov0" title="0">key := fmt.Sprintf("%s:%s", nodeName, storageName)
                                        if _, exists := storageMap[key]; !exists </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        // 存储使用率
                                        <span class="cov0" title="0">if disk, ok := resource["disk"].(float64); ok </span><span class="cov0" title="0">{
                                                if maxdisk, ok := resource["maxdisk"].(float64); ok &amp;&amp; maxdisk &gt; 0 </span><span class="cov0" title="0">{
                                                        diskPercent := (disk / maxdisk) * 100
                                                        storages = append(storages, storageResource{
                                                                ID:           fmt.Sprintf("storage/%s/%s", nodeName, storageName),
                                                                Name:         fmt.Sprintf("%s (%s)", storageName, nodeName),
                                                                UsagePercent: diskPercent,
                                                                UsedBytes:    int64(disk),
                                                                TotalBytes:   int64(maxdisk),
                                                                Unit:         "%",
                                                        })
                                                }</span>
                                        }
                                }
                        }
                }

                // 3. 获取 VM 资源（CPU、Memory）
                <span class="cov0" title="0">resources, err := client.GetClusterResources(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get cluster resources",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }

                <span class="cov0" title="0">for _, resource := range resources </span><span class="cov0" title="0">{
                        resourceType, _ := resource["type"].(string)
                        if resourceType != "qemu" &amp;&amp; resourceType != "lxc" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">name, _ := resource["name"].(string)
                        id, _ := resource["id"].(string)
                        nodeName, _ := resource["node"].(string)

                        // VM CPU 使用率
                        if cpu, ok := resource["cpu"].(float64); ok </span><span class="cov0" title="0">{
                                cpuPercent := cpu * 100
                                vmCPU = append(vmCPU, vmResource{
                                        ID:          id,
                                        Name:        name,
                                        NodeName:    nodeName,
                                        ClusterID:   cluster.Id,
                                        ClusterName: cluster.ClusterName,
                                        MetricValue: cpuPercent,
                                        Unit:        "%",
                                })
                        }</span>

                        // VM Memory 使用率
                        <span class="cov0" title="0">if mem, ok := resource["mem"].(float64); ok </span><span class="cov0" title="0">{
                                if maxmem, ok := resource["maxmem"].(float64); ok &amp;&amp; maxmem &gt; 0 </span><span class="cov0" title="0">{
                                        memPercent := (mem / maxmem) * 100
                                        vmMemory = append(vmMemory, vmResource{
                                                ID:          id,
                                                Name:        name,
                                                NodeName:    nodeName,
                                                ClusterID:   cluster.Id,
                                                ClusterName: cluster.ClusterName,
                                                MetricValue: memPercent,
                                                Unit:        "%",
                                        })
                                }</span>
                        }
                }
        }

        // 分别排序并取 Top N
        <span class="cov0" title="0">topN := req.Limit

        // VM CPU Top N
        sort.Slice(vmCPU, func(i, j int) bool </span><span class="cov0" title="0">{
                return vmCPU[i].MetricValue &gt; vmCPU[j].MetricValue
        }</span>)
        <span class="cov0" title="0">vmCPUTopN := make([]v1.TopResourceConsumer, 0, topN)
        for i := 0; i &lt; topN &amp;&amp; i &lt; len(vmCPU); i++ </span><span class="cov0" title="0">{
                vmCPUTopN = append(vmCPUTopN, v1.TopResourceConsumer{
                        ID:          vmCPU[i].ID,
                        Name:        vmCPU[i].Name,
                        MetricValue: vmCPU[i].MetricValue,
                        Unit:        vmCPU[i].Unit,
                        NodeName:    vmCPU[i].NodeName,
                        ClusterID:   vmCPU[i].ClusterID,
                        ClusterName: vmCPU[i].ClusterName,
                })
        }</span>

        // VM Memory Top N
        <span class="cov0" title="0">sort.Slice(vmMemory, func(i, j int) bool </span><span class="cov0" title="0">{
                return vmMemory[i].MetricValue &gt; vmMemory[j].MetricValue
        }</span>)
        <span class="cov0" title="0">vmMemoryTopN := make([]v1.TopResourceConsumer, 0, topN)
        for i := 0; i &lt; topN &amp;&amp; i &lt; len(vmMemory); i++ </span><span class="cov0" title="0">{
                vmMemoryTopN = append(vmMemoryTopN, v1.TopResourceConsumer{
                        ID:          vmMemory[i].ID,
                        Name:        vmMemory[i].Name,
                        MetricValue: vmMemory[i].MetricValue,
                        Unit:        vmMemory[i].Unit,
                        NodeName:    vmMemory[i].NodeName,
                        ClusterID:   vmMemory[i].ClusterID,
                        ClusterName: vmMemory[i].ClusterName,
                })
        }</span>

        // Node CPU Top N
        <span class="cov0" title="0">sort.Slice(nodeCPU, func(i, j int) bool </span><span class="cov0" title="0">{
                return nodeCPU[i].MetricValue &gt; nodeCPU[j].MetricValue
        }</span>)
        <span class="cov0" title="0">nodeCPUTopN := make([]v1.TopResourceConsumer, 0, topN)
        for i := 0; i &lt; topN &amp;&amp; i &lt; len(nodeCPU); i++ </span><span class="cov0" title="0">{
                nodeCPUTopN = append(nodeCPUTopN, v1.TopResourceConsumer{
                        ID:          nodeCPU[i].ID,
                        Name:        nodeCPU[i].Name,
                        MetricValue: nodeCPU[i].MetricValue,
                        Unit:        nodeCPU[i].Unit,
                        ClusterID:   nodeCPU[i].ClusterID,
                        ClusterName: nodeCPU[i].ClusterName,
                })
        }</span>

        // Node Memory Top N
        <span class="cov0" title="0">sort.Slice(nodeMemory, func(i, j int) bool </span><span class="cov0" title="0">{
                return nodeMemory[i].MetricValue &gt; nodeMemory[j].MetricValue
        }</span>)
        <span class="cov0" title="0">nodeMemoryTopN := make([]v1.TopResourceConsumer, 0, topN)
        for i := 0; i &lt; topN &amp;&amp; i &lt; len(nodeMemory); i++ </span><span class="cov0" title="0">{
                nodeMemoryTopN = append(nodeMemoryTopN, v1.TopResourceConsumer{
                        ID:          nodeMemory[i].ID,
                        Name:        nodeMemory[i].Name,
                        MetricValue: nodeMemory[i].MetricValue,
                        Unit:        nodeMemory[i].Unit,
                        ClusterID:   nodeMemory[i].ClusterID,
                        ClusterName: nodeMemory[i].ClusterName,
                })
        }</span>

        // Storage Top N
        <span class="cov0" title="0">sort.Slice(storages, func(i, j int) bool </span><span class="cov0" title="0">{
                return storages[i].UsagePercent &gt; storages[j].UsagePercent
        }</span>)
        <span class="cov0" title="0">storageTopN := make([]v1.StorageHotspot, 0, topN)
        for i := 0; i &lt; topN &amp;&amp; i &lt; len(storages); i++ </span><span class="cov0" title="0">{
                storageTopN = append(storageTopN, v1.StorageHotspot{
                        ID:           storages[i].ID,
                        Name:         storages[i].Name,
                        UsagePercent: storages[i].UsagePercent,
                        UsedBytes:    storages[i].UsedBytes,
                        TotalBytes:   storages[i].TotalBytes,
                        Unit:         storages[i].Unit,
                })
        }</span>

        // 获取最近的风险
        <span class="cov0" title="0">recentRisks := s.getRecentRisks(ctx, clusters)

        return &amp;v1.DashboardHotspotsData{
                Scope:     req.Scope,
                ClusterID: req.ClusterID,
                VMHotspots: v1.VMHotspots{
                        CPU:    vmCPUTopN,
                        Memory: vmMemoryTopN,
                },
                NodeHotspots: v1.NodeHotspots{
                        CPU:    nodeCPUTopN,
                        Memory: nodeMemoryTopN,
                },
                StorageHotspots: storageTopN,
                RecentRisks:     recentRisks,
        }, nil</span>
}

// getRecentRisks 获取最近的风险（简单实现，实际应该从监控系统获取）
func (s *dashboardService) getRecentRisks(ctx context.Context, clusters []*model.PveCluster) []v1.RecentRisk <span class="cov0" title="0">{
        risks := make([]v1.RecentRisk, 0)

        // 遍历集群，检查节点状态
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                nodes, err := s.nodeRepo.GetByClusterID(ctx, cluster.Id)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, node := range nodes </span><span class="cov0" title="0">{
                        // 检查节点是否离线
                        if node.Status != "online" </span><span class="cov0" title="0">{
                                risks = append(risks, v1.RecentRisk{
                                        ID:           fmt.Sprintf("risk-node-%d", node.Id),
                                        Level:        "warning",
                                        Message:      fmt.Sprintf("Node %s is %s", node.NodeName, node.Status),
                                        OccurredAt:   node.UpdateTime.Format(time.RFC3339),
                                        RelativeTime: s.getRelativeTime(node.UpdateTime),
                                        TargetType:   "node",
                                        TargetID:     fmt.Sprintf("node-%d", node.Id),
                                        TargetName:   node.NodeName,
                                })
                        }</span>
                }

                // 检查存储空间
                <span class="cov0" title="0">_, err = s.storageRepo.GetByClusterID(ctx, cluster.Id)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 这里需要从 Proxmox API 获取实时存储数据
                // 简化处理：如果有存储相关的字段可以检查
                // 实际应该调用 API 获取实时数据
        }

        <span class="cov0" title="0">return risks</span>
}

// getRelativeTime 获取相对时间
func (s *dashboardService) getRelativeTime(t time.Time) string <span class="cov0" title="0">{
        duration := time.Since(t)

        if duration &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d sec ago", int(duration.Seconds()))
        }</span> else<span class="cov0" title="0"> if duration &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d min ago", int(duration.Minutes()))
        }</span> else<span class="cov0" title="0"> if duration &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d h ago", int(duration.Hours()))
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%d d ago", int(duration.Hours()/24))
        }</span>
}

// GetOperations 获取运行中的操作
func (s *dashboardService) GetOperations(ctx context.Context, req *v1.DashboardOperationsRequest) (*v1.DashboardOperationsData, error) <span class="cov0" title="0">{
        var clusters []*model.PveCluster
        var err error

        // 根据 scope 获取集群列表
        if req.Scope == "cluster" &amp;&amp; req.ClusterID != nil </span><span class="cov0" title="0">{
                cluster, err := s.clusterRepo.GetByID(ctx, *req.ClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
                <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                        return nil, v1.ErrNotFound
                }</span>
                <span class="cov0" title="0">clusters = []*model.PveCluster{cluster}</span>
        } else<span class="cov0" title="0"> {
                clusters, err = s.clusterRepo.List(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to list clusters", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
        }

        // 统计各类操作
        <span class="cov0" title="0">operationCounts := make(map[string]int64)
        var allItems []v1.OperationItem

        // 遍历集群，获取正在运行的任务
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                // 创建 Proxmox 客户端
                client, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to create proxmox client",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }

                // 获取集群任务
                <span class="cov0" title="0">tasks, err := client.GetClusterTasks(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get cluster tasks",
                                zap.Error(err), zap.Int64("cluster_id", cluster.Id))
                        continue</span>
                }

                // 遍历任务
                <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                        status, _ := task["status"].(string)
                        taskType, _ := task["type"].(string)
                        upid, _ := task["upid"].(string)

                        // 只统计运行中的任务
                        if status != "running" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // 分类统计
                        <span class="cov0" title="0">operationType := s.classifyOperationType(taskType)
                        operationCounts[operationType]++

                        // 收集任务详情
                        startTime, _ := task["starttime"].(float64)
                        startTimeStr := time.Unix(int64(startTime), 0).Format(time.RFC3339)

                        allItems = append(allItems, v1.OperationItem{
                                ID:            upid,
                                OperationType: operationType,
                                Name:          fmt.Sprintf("%s on %s", taskType, task["node"]),
                                Progress:      0, // Proxmox API 可能不提供进度信息
                                Status:        "running",
                                StartedAt:     startTimeStr,
                        })</span>
                }
        }

        // 构建摘要
        <span class="cov0" title="0">summary := make([]v1.OperationSummary, 0)
        if count, ok := operationCounts["vm_migration"]; ok &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                summary = append(summary, v1.OperationSummary{
                        OperationType: "vm_migration",
                        DisplayName:   "VM Migrations",
                        Count:         count,
                })
        }</span>
        <span class="cov0" title="0">if count, ok := operationCounts["node_maintenance"]; ok &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                summary = append(summary, v1.OperationSummary{
                        OperationType: "node_maintenance",
                        DisplayName:   "Node Maintenance",
                        Count:         count,
                })
        }</span>
        <span class="cov0" title="0">if count, ok := operationCounts["storage_rebalance"]; ok &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                summary = append(summary, v1.OperationSummary{
                        OperationType: "storage_rebalance",
                        DisplayName:   "Storage Rebalance",
                        Count:         count,
                })
        }</span>
        <span class="cov0" title="0">if count, ok := operationCounts["other"]; ok &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                summary = append(summary, v1.OperationSummary{
                        OperationType: "other",
                        DisplayName:   "Other Operations",
                        Count:         count,
                })
        }</span>

        <span class="cov0" title="0">return &amp;v1.DashboardOperationsData{
                Scope:     req.Scope,
                ClusterID: req.ClusterID,
                Summary:   summary,
                Items:     allItems,
        }, nil</span>
}

// classifyOperationType 分类操作类型
func (s *dashboardService) classifyOperationType(taskType string) string <span class="cov0" title="0">{
        switch taskType </span>{
        case "qmigrate", "vzmigrate":<span class="cov0" title="0">
                return "vm_migration"</span>
        case "startall", "stopall":<span class="cov0" title="0">
                return "node_maintenance"</span>
        case "storage":<span class="cov0" title="0">
                return "storage_rebalance"</span>
        default:<span class="cov0" title="0">
                return "other"</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package service

import (
        "context"
        "time"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"
        "pvesphere/internal/repository"
        "pvesphere/pkg/log"
        "pvesphere/pkg/proxmox"

        "go.uber.org/zap"
)

type PveClusterService interface {
        CreateCluster(ctx context.Context, req *v1.CreateClusterRequest) error
        UpdateCluster(ctx context.Context, id int64, req *v1.UpdateClusterRequest) error
        DeleteCluster(ctx context.Context, id int64) error
        GetCluster(ctx context.Context, id int64) (*v1.ClusterDetail, error)
        ListClusters(ctx context.Context, req *v1.ListClusterRequest) (*v1.ListClusterResponseData, error)
        GetClusterStatus(ctx context.Context, clusterID int64) ([]map[string]interface{}, error)
        GetClusterResources(ctx context.Context, clusterID int64) ([]map[string]interface{}, error)
        VerifyCluster(ctx context.Context, clusterID *int64) (*v1.VerifyClusterData, error)
        VerifyClusterWithCredentials(ctx context.Context, apiUrl, userId, userToken string) (*v1.VerifyClusterData, error)
}

func NewPveClusterService(
        service *Service,
        clusterRepo repository.PveClusterRepository,
        repo *repository.Repository,
        logger *log.Logger,
) PveClusterService <span class="cov0" title="0">{
        return &amp;pveClusterService{
                clusterRepo: clusterRepo,
                repo:        repo,
                Service:     service,
                logger:      logger,
        }
}</span>

type pveClusterService struct {
        clusterRepo repository.PveClusterRepository
        repo        *repository.Repository
        *Service
        logger *log.Logger
}

func (s *pveClusterService) CreateCluster(ctx context.Context, req *v1.CreateClusterRequest) error <span class="cov0" title="0">{
        // 检查集群名称是否已存在
        existing, err := s.clusterRepo.GetByClusterName(ctx, req.ClusterName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to check cluster name", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                return v1.ErrBadRequest
        }</span>

        <span class="cov0" title="0">cluster := &amp;model.PveCluster{
                ClusterName:      req.ClusterName,
                ClusterNameAlias: req.ClusterNameAlias,
                Env:              req.Env,
                Datacenter:       req.Datacenter,
                ApiUrl:           req.ApiUrl,
                UserId:           req.UserId,
                UserToken:        req.UserToken,
                Dns:              req.Dns,
                Describes:        req.Describes,
                Region:           req.Region,
                IsSchedulable:    req.IsSchedulable,
                IsEnabled:        req.IsEnabled,
                CreateTime:       time.Now(),
                UpdateTime:       time.Now(),
        }

        if err := s.clusterRepo.Create(ctx, cluster); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create cluster", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveClusterService) UpdateCluster(ctx context.Context, id int64, req *v1.UpdateClusterRequest) error <span class="cov0" title="0">{
        cluster, err := s.clusterRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.ClusterNameAlias != nil </span><span class="cov0" title="0">{
                cluster.ClusterNameAlias = *req.ClusterNameAlias
        }</span>
        <span class="cov0" title="0">if req.Env != nil </span><span class="cov0" title="0">{
                cluster.Env = *req.Env
        }</span>
        <span class="cov0" title="0">if req.Datacenter != nil </span><span class="cov0" title="0">{
                cluster.Datacenter = *req.Datacenter
        }</span>
        <span class="cov0" title="0">if req.ApiUrl != nil </span><span class="cov0" title="0">{
                cluster.ApiUrl = *req.ApiUrl
        }</span>
        <span class="cov0" title="0">if req.UserId != nil </span><span class="cov0" title="0">{
                cluster.UserId = *req.UserId
        }</span>
        <span class="cov0" title="0">if req.UserToken != nil </span><span class="cov0" title="0">{
                cluster.UserToken = *req.UserToken
        }</span>
        <span class="cov0" title="0">if req.Dns != nil </span><span class="cov0" title="0">{
                cluster.Dns = *req.Dns
        }</span>
        <span class="cov0" title="0">if req.Describes != nil </span><span class="cov0" title="0">{
                cluster.Describes = *req.Describes
        }</span>
        <span class="cov0" title="0">if req.Region != nil </span><span class="cov0" title="0">{
                cluster.Region = *req.Region
        }</span>
        <span class="cov0" title="0">if req.IsSchedulable != nil </span><span class="cov0" title="0">{
                cluster.IsSchedulable = *req.IsSchedulable
        }</span>
        <span class="cov0" title="0">if req.IsEnabled != nil </span><span class="cov0" title="0">{
                cluster.IsEnabled = *req.IsEnabled
        }</span>
        <span class="cov0" title="0">cluster.UpdateTime = time.Now()

        if err := s.clusterRepo.Update(ctx, cluster); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update cluster", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveClusterService) DeleteCluster(ctx context.Context, id int64) error <span class="cov0" title="0">{
        cluster, err := s.clusterRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 步骤 1：先禁用集群（设置 IsEnabled=0），阻止控制器继续同步数据
        <span class="cov0" title="0">if cluster.IsEnabled != 0 </span><span class="cov0" title="0">{
                cluster.IsEnabled = 0
                cluster.UpdateTime = time.Now()
                if err := s.clusterRepo.Update(ctx, cluster); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to disable cluster before deletion", zap.Error(err))
                        return v1.ErrInternalServerError
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Info("cluster disabled before deletion",
                        zap.Int64("cluster_id", id),
                        zap.String("cluster_name", cluster.ClusterName))</span>
        }

        // 步骤 2：使用事务级联删除所有关联数据
        // 删除顺序：按照依赖关系，先删除子表，再删除父表
        <span class="cov0" title="0">err = s.tm.Transaction(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                db := s.repo.DB(ctx)

                // 1. 删除虚拟机 IP 地址（依赖 vm）
                result := db.Table("vm_ipaddress").Where("cluster_id = ?", id).Delete(&amp;model.VMIPAddress{})
                if result.Error != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete vm ip addresses", zap.Error(result.Error))
                        return result.Error
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("deleted vm ip addresses", zap.Int64("rows_affected", result.RowsAffected))

                // 2. 删除虚拟机（依赖 node）
                result = db.Table("pve_vm").Where("cluster_id = ?", id).Delete(&amp;model.PveVM{})
                if result.Error != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete vms", zap.Error(result.Error))
                        return result.Error
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("deleted vms", zap.Int64("rows_affected", result.RowsAffected))

                // 3. 删除存储（依赖 node）
                // 使用 Table() 明确指定表名，确保删除操作正确执行
                result = db.Table("pve_storage").Where("cluster_id = ?", id).Delete(&amp;model.PveStorage{})
                if result.Error != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete storages", zap.Error(result.Error))
                        return result.Error
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("deleted storages", zap.Int64("rows_affected", result.RowsAffected))

                // 4. 删除模板同步任务（依赖 template_instance）
                result = db.Table("template_sync_task").Where("cluster_id = ?", id).Delete(&amp;model.TemplateSyncTask{})
                if result.Error != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete template sync tasks", zap.Error(result.Error))
                        return result.Error
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("deleted template sync tasks", zap.Int64("rows_affected", result.RowsAffected))

                // 5. 删除模板实例（依赖 template_upload）
                result = db.Table("template_instance").Where("cluster_id = ?", id).Delete(&amp;model.TemplateInstance{})
                if result.Error != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete template instances", zap.Error(result.Error))
                        return result.Error
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("deleted template instances", zap.Int64("rows_affected", result.RowsAffected))

                // 6. 删除模板上传记录（依赖 template）
                result = db.Table("template_upload").Where("cluster_id = ?", id).Delete(&amp;model.TemplateUpload{})
                if result.Error != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete template uploads", zap.Error(result.Error))
                        return result.Error
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("deleted template uploads", zap.Int64("rows_affected", result.RowsAffected))

                // 7. 删除模板（vm_template 表）
                result = db.Table("vm_template").Where("cluster_id = ?", id).Delete(&amp;model.VmTemplate{})
                if result.Error != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete templates", zap.Error(result.Error))
                        return result.Error
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("deleted templates", zap.Int64("rows_affected", result.RowsAffected))

                // 8. 删除节点（依赖 cluster）
                result = db.Table("pve_node").Where("cluster_id = ?", id).Delete(&amp;model.PveNode{})
                if result.Error != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete nodes", zap.Error(result.Error))
                        return result.Error
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("deleted nodes", zap.Int64("rows_affected", result.RowsAffected))

                // 9. 最后删除集群本身
                if err := s.clusterRepo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete cluster", zap.Error(err))
                        return err
                }</span>

                <span class="cov0" title="0">s.logger.WithContext(ctx).Info("cluster and all related data deleted successfully",
                        zap.Int64("cluster_id", id),
                        zap.String("cluster_name", cluster.ClusterName))
                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete cluster with cascade", zap.Error(err), zap.Int64("cluster_id", id))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveClusterService) GetCluster(ctx context.Context, id int64) (*v1.ClusterDetail, error) <span class="cov0" title="0">{
        cluster, err := s.clusterRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        <span class="cov0" title="0">return &amp;v1.ClusterDetail{
                Id:               cluster.Id,
                ClusterName:      cluster.ClusterName,
                ClusterNameAlias: cluster.ClusterNameAlias,
                Env:              cluster.Env,
                Datacenter:       cluster.Datacenter,
                ApiUrl:           cluster.ApiUrl,
                UserId:           cluster.UserId,
                Dns:              cluster.Dns,
                Describes:        cluster.Describes,
                Region:           cluster.Region,
                IsSchedulable:    cluster.IsSchedulable,
                IsEnabled:        cluster.IsEnabled,
                CreateTime:       cluster.CreateTime,
                UpdateTime:       cluster.UpdateTime,
                Creator:          cluster.Creator,
                Modifier:         cluster.Modifier,
        }, nil</span>
}

func (s *pveClusterService) ListClusters(ctx context.Context, req *v1.ListClusterRequest) (*v1.ListClusterResponseData, error) <span class="cov0" title="0">{
        clusters, total, err := s.clusterRepo.ListWithPagination(ctx, req.Page, req.PageSize, req.Env, req.Region)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list clusters", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">items := make([]v1.ClusterItem, 0, len(clusters))
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                items = append(items, v1.ClusterItem{
                        Id:               cluster.Id,
                        ClusterName:      cluster.ClusterName,
                        ClusterNameAlias: cluster.ClusterNameAlias,
                        Env:              cluster.Env,
                        Datacenter:       cluster.Datacenter,
                        ApiUrl:           cluster.ApiUrl,
                        Region:           cluster.Region,
                        IsSchedulable:    cluster.IsSchedulable,
                        IsEnabled:        cluster.IsEnabled,
                })
        }</span>

        <span class="cov0" title="0">return &amp;v1.ListClusterResponseData{
                Total: total,
                List:  items,
        }, nil</span>
}

func (s *pveClusterService) GetClusterStatus(ctx context.Context, clusterID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // 1. 获取集群信息
        cluster, err := s.clusterRepo.GetByID(ctx, clusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 2. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 3. 获取集群状态
        <span class="cov0" title="0">status, err := proxmoxClient.GetClusterStatus(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster status", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

func (s *pveClusterService) GetClusterResources(ctx context.Context, clusterID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // 1. 获取集群信息
        cluster, err := s.clusterRepo.GetByID(ctx, clusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 2. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 3. 获取集群资源
        <span class="cov0" title="0">resources, err := proxmoxClient.GetClusterResources(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster resources", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

func (s *pveClusterService) VerifyCluster(ctx context.Context, clusterID *int64) (*v1.VerifyClusterData, error) <span class="cov0" title="0">{
        // 1. 获取集群信息
        cluster, err := s.clusterRepo.GetByID(ctx, *clusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 2. 使用集群信息验证连接
        <span class="cov0" title="0">return s.VerifyClusterWithCredentials(ctx, cluster.ApiUrl, cluster.UserId, cluster.UserToken)</span>
}

func (s *pveClusterService) VerifyClusterWithCredentials(ctx context.Context, apiUrl, userId, userToken string) (*v1.VerifyClusterData, error) <span class="cov0" title="0">{
        // 1. 创建 Proxmox 客户端
        proxmoxClient, err := proxmox.NewProxmoxClient(apiUrl, userId, userToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return &amp;v1.VerifyClusterData{
                        Connected: false,
                        Message:   "failed to create proxmox client: " + err.Error(),
                }, nil
        }</span>

        // 2. 调用 /version 接口验证连接
        <span class="cov0" title="0">versionInfo, err := proxmoxClient.GetVersion(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get proxmox version", zap.Error(err),
                        zap.String("api_url", apiUrl))
                return &amp;v1.VerifyClusterData{
                        Connected: false,
                        Message:   "connection failed: " + err.Error(),
                }, nil
        }</span>

        // 3. 解析版本信息
        <span class="cov0" title="0">version, _ := versionInfo["version"].(string)
        release, _ := versionInfo["release"].(string)
        repoid, _ := versionInfo["repoid"].(string)

        return &amp;v1.VerifyClusterData{
                Version:   version,
                Release:   release,
                RepoID:    repoid,
                Connected: true,
                Message:   "connection successful",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package service

import (
        "context"
        "crypto/rand"
        "encoding/json"
        "fmt"
        "mime/multipart"
        "net/url"
        "strconv"
        "strings"
        "sync"
        "time"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"
        "pvesphere/internal/repository"
        "pvesphere/pkg/log"
        "pvesphere/pkg/proxmox"

        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

type PveNodeService interface {
        CreateNode(ctx context.Context, req *v1.CreateNodeRequest) error
        UpdateNode(ctx context.Context, id int64, req *v1.UpdateNodeRequest) error
        DeleteNode(ctx context.Context, id int64) error
        GetNode(ctx context.Context, id int64) (*v1.NodeDetail, error)
        ListNodes(ctx context.Context, req *v1.ListNodeRequest) (*v1.ListNodeResponseData, error)
        GetNodeStatus(ctx context.Context, nodeID int64) (map[string]interface{}, error)
        SetNodeStatus(ctx context.Context, nodeID int64, command string) (string, error)
        GetNodeServices(ctx context.Context, nodeID int64) ([]map[string]interface{}, error)
        StartNodeService(ctx context.Context, nodeID int64, serviceName string) (string, error)
        StopNodeService(ctx context.Context, nodeID int64, serviceName string) (string, error)
        RestartNodeService(ctx context.Context, nodeID int64, serviceName string) (string, error)
        GetNodeNetworks(ctx context.Context, nodeID int64) ([]map[string]interface{}, error)
        CreateNodeNetwork(ctx context.Context, req *v1.CreateNodeNetworkRequest) error
        ReloadNodeNetwork(ctx context.Context, nodeID int64) error
        RevertNodeNetwork(ctx context.Context, nodeID int64) error
        GetNodeRRDData(ctx context.Context, nodeID int64, timeframe, cf string) ([]map[string]interface{}, error)
        GetNodeDisksList(ctx context.Context, nodeID int64, includePartitions bool) ([]map[string]interface{}, error)
        GetNodeDisksDirectory(ctx context.Context, nodeID int64) ([]map[string]interface{}, error)
        GetNodeDisksLVM(ctx context.Context, nodeID int64) ([]map[string]interface{}, error)
        GetNodeDisksLVMThin(ctx context.Context, nodeID int64) ([]map[string]interface{}, error)
        GetNodeDisksZFS(ctx context.Context, nodeID int64) ([]map[string]interface{}, error)
        InitGPTDisk(ctx context.Context, nodeID int64, disk string) (string, error)
        WipeDisk(ctx context.Context, nodeID int64, disk string, partition *int) (string, error)
        GetNodeStorageStatus(ctx context.Context, nodeID int64, storage string) (map[string]interface{}, error)
        GetNodeStorageRRDData(ctx context.Context, nodeID int64, storage, timeframe, cf string) ([]map[string]interface{}, error)
        GetNodeStorageContent(ctx context.Context, nodeID int64, storage, content string) ([]map[string]interface{}, error)
        GetNodeStorageVolume(ctx context.Context, nodeID int64, storage, volume string) (map[string]interface{}, error)
        UploadNodeStorageContent(ctx context.Context, nodeID int64, storage, content, filename string, file multipart.File) (interface{}, error)
        DeleteNodeStorageContent(ctx context.Context, nodeID int64, storage, volume string, delay *int) error
        GetNodeConsole(ctx context.Context, req *v1.GetNodeConsoleRequest) (map[string]interface{}, error)
        DialNodeConsoleWebsocket(ctx context.Context, token string) (*websocket.Conn, error)
}

func NewPveNodeService(
        service *Service,
        nodeRepo repository.PveNodeRepository,
        clusterRepo repository.PveClusterRepository,
        logger *log.Logger,
) PveNodeService <span class="cov0" title="0">{
        return &amp;pveNodeService{
                nodeRepo:    nodeRepo,
                clusterRepo: clusterRepo,
                Service:     service,
                logger:      logger,
        }
}</span>

type pveNodeService struct {
        nodeRepo    repository.PveNodeRepository
        clusterRepo repository.PveClusterRepository
        *Service
        logger *log.Logger

        consoleSessions sync.Map // token -&gt; nodeConsoleSession
}

type nodeConsoleSession struct {
        NodeID    int64
        NodeName  string
        Port      int
        Ticket    string // VNC ticket（用于 vncwebsocket 连接）
        ExpiresAt time.Time
        // 高权限认证信息（可选）：如果原始请求使用了 ticket + csrf_token，保存这些信息用于 WebSocket 连接
        AuthTicket    string // Proxmox 高权限认证 ticket
        AuthCSRFToken string // CSRF 防护令牌
        ClusterApiURL string // 集群 API URL（用于创建 ProxmoxClient）
}

func newNodeConsoleToken() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 24)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", b), nil</span>
}

func (s *pveNodeService) CreateNode(ctx context.Context, req *v1.CreateNodeRequest) error <span class="cov0" title="0">{
        // 检查节点名称是否已存在
        existing, err := s.nodeRepo.GetByNodeName(ctx, req.NodeName, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to check node name", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                return v1.ErrBadRequest
        }</span>

        <span class="cov0" title="0">node := &amp;model.PveNode{
                NodeName:      req.NodeName,
                IPAddress:     req.IPAddress,
                ClusterID:     req.ClusterID,
                IsSchedulable: req.IsSchedulable,
                Env:           req.Env,
                Status:        req.Status,
                Annotations:   req.Annotations,
                VMLimit:       req.VMLimit,
                CreateTime:    time.Now(),
                UpdateTime:    time.Now(),
        }

        if err := s.nodeRepo.Create(ctx, node); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveNodeService) UpdateNode(ctx context.Context, id int64, req *v1.UpdateNodeRequest) error <span class="cov0" title="0">{
        node, err := s.nodeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.IPAddress != nil </span><span class="cov0" title="0">{
                node.IPAddress = *req.IPAddress
        }</span>
        <span class="cov0" title="0">if req.IsSchedulable != nil </span><span class="cov0" title="0">{
                node.IsSchedulable = *req.IsSchedulable
        }</span>
        <span class="cov0" title="0">if req.Env != nil </span><span class="cov0" title="0">{
                node.Env = *req.Env
        }</span>
        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                node.Status = *req.Status
        }</span>
        <span class="cov0" title="0">if req.Annotations != nil </span><span class="cov0" title="0">{
                node.Annotations = *req.Annotations
        }</span>
        <span class="cov0" title="0">if req.VMLimit != nil </span><span class="cov0" title="0">{
                node.VMLimit = *req.VMLimit
        }</span>
        <span class="cov0" title="0">node.UpdateTime = time.Now()

        if err := s.nodeRepo.Update(ctx, node); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveNodeService) DeleteNode(ctx context.Context, id int64) error <span class="cov0" title="0">{
        node, err := s.nodeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        <span class="cov0" title="0">if err := s.nodeRepo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveNodeService) GetNode(ctx context.Context, id int64) (*v1.NodeDetail, error) <span class="cov0" title="0">{
        node, err := s.nodeRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 查询集群信息填充 cluster_name
        <span class="cov0" title="0">var clusterName string
        if node.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                cluster, err := s.clusterRepo.GetByID(ctx, node.ClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get cluster",
                                zap.Error(err), zap.Int64("cluster_id", node.ClusterID))
                        // 不阻塞主流程，cluster_name 为空
                }</span> else<span class="cov0" title="0"> if cluster != nil </span><span class="cov0" title="0">{
                        clusterName = cluster.ClusterName
                }</span>
        }

        <span class="cov0" title="0">return &amp;v1.NodeDetail{
                Id:            node.Id,
                NodeName:      node.NodeName,
                IPAddress:     node.IPAddress,
                ClusterID:     node.ClusterID,
                ClusterName:   clusterName,
                IsSchedulable: node.IsSchedulable,
                Env:           node.Env,
                Status:        node.Status,
                Annotations:   node.Annotations,
                VMLimit:       node.VMLimit,
                CreateTime:    node.CreateTime,
                UpdateTime:    node.UpdateTime,
                Creator:       node.Creator,
                Modifier:      node.Modifier,
        }, nil</span>
}

func (s *pveNodeService) ListNodes(ctx context.Context, req *v1.ListNodeRequest) (*v1.ListNodeResponseData, error) <span class="cov0" title="0">{
        nodes, total, err := s.nodeRepo.ListWithPagination(ctx, req.Page, req.PageSize, req.ClusterID, req.Env, req.Status)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list nodes", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 1. 提取所有唯一的 cluster_id
        <span class="cov0" title="0">clusterIDs := make([]int64, 0)
        clusterIDSet := make(map[int64]struct{})
        for _, node := range nodes </span><span class="cov0" title="0">{
                if node.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                        if _, exists := clusterIDSet[node.ClusterID]; !exists </span><span class="cov0" title="0">{
                                clusterIDs = append(clusterIDs, node.ClusterID)
                                clusterIDSet[node.ClusterID] = struct{}{}
                        }</span>
                }
        }

        // 2. 批量查询集群信息（通常只有 1-5 个集群）
        <span class="cov0" title="0">clusterMap := make(map[int64]*model.PveCluster)
        if len(clusterIDs) &gt; 0 </span><span class="cov0" title="0">{
                clusters, err := s.clusterRepo.GetByIDs(ctx, clusterIDs)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get clusters", zap.Error(err))
                        // 不阻塞主流程，cluster_name 为空
                }</span> else<span class="cov0" title="0"> {
                        clusterMap = clusters
                }</span>
        }

        // 3. 构建响应，填充 cluster_name
        <span class="cov0" title="0">items := make([]v1.NodeItem, 0, len(nodes))
        for _, node := range nodes </span><span class="cov0" title="0">{
                item := v1.NodeItem{
                        Id:            node.Id,
                        NodeName:      node.NodeName,
                        IPAddress:     node.IPAddress,
                        ClusterID:     node.ClusterID,
                        ClusterName:   "", // 默认为空
                        IsSchedulable: node.IsSchedulable,
                        Env:           node.Env,
                        Status:        node.Status,
                        VMLimit:       node.VMLimit,
                }

                // 填充 cluster_name
                if cluster, ok := clusterMap[node.ClusterID]; ok </span><span class="cov0" title="0">{
                        item.ClusterName = cluster.ClusterName
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return &amp;v1.ListNodeResponseData{
                Total: total,
                List:  items,
        }, nil</span>
}

// getProxmoxClientForNode 根据节点ID获取ProxmoxClient
func (s *pveNodeService) getProxmoxClientForNode(ctx context.Context, nodeID int64) (*proxmox.ProxmoxClient, *model.PveNode, error) <span class="cov0" title="0">{
        // 1. 获取节点信息
        node, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, nil, v1.ErrNotFound
        }</span>

        // 2. 获取集群信息
        <span class="cov0" title="0">if node.ClusterID &lt;= 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("节点的集群 ID 无效")
        }</span>
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, node.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("集群 ID %d 不存在", node.ClusterID)
        }</span>

        // 3. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return proxmoxClient, node, nil</span>
}

func (s *pveNodeService) GetNodeStatus(ctx context.Context, nodeID int64) (map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status, err := client.GetNodeStatus(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node status", zap.Error(err),
                        zap.String("node", node.NodeName), zap.Int64("node_id", nodeID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

func (s *pveNodeService) SetNodeStatus(ctx context.Context, nodeID int64, command string) (string, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 验证 command 参数
        <span class="cov0" title="0">command = strings.ToLower(strings.TrimSpace(command))
        if command != "reboot" &amp;&amp; command != "shutdown" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid command: %s (must be 'reboot' or 'shutdown')", command)
        }</span>

        <span class="cov0" title="0">upid, err := client.SetNodeStatus(ctx, node.NodeName, command)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to set node status", zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("command", command))
                return "", v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("node status set", zap.String("node", node.NodeName),
                zap.Int64("node_id", nodeID),
                zap.String("command", command),
                zap.String("upid", upid))

        return upid, nil</span>
}

func (s *pveNodeService) GetNodeServices(ctx context.Context, nodeID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">services, err := client.GetNodeServices(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node services", zap.Error(err),
                        zap.String("node", node.NodeName), zap.Int64("node_id", nodeID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return services, nil</span>
}

// StartNodeService 启动节点服务
func (s *pveNodeService) StartNodeService(ctx context.Context, nodeID int64, serviceName string) (string, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">upid, err := client.StartNodeService(ctx, node.NodeName, serviceName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to start node service",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.String("service", serviceName),
                        zap.Int64("node_id", nodeID))
                return "", fmt.Errorf("启动节点服务失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("node service started successfully",
                zap.String("node", node.NodeName),
                zap.String("service", serviceName),
                zap.String("upid", upid))

        return upid, nil</span>
}

// StopNodeService 停止节点服务
func (s *pveNodeService) StopNodeService(ctx context.Context, nodeID int64, serviceName string) (string, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">upid, err := client.StopNodeService(ctx, node.NodeName, serviceName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to stop node service",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.String("service", serviceName),
                        zap.Int64("node_id", nodeID))
                return "", fmt.Errorf("停止节点服务失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("node service stopped successfully",
                zap.String("node", node.NodeName),
                zap.String("service", serviceName),
                zap.String("upid", upid))

        return upid, nil</span>
}

// RestartNodeService 重启节点服务
func (s *pveNodeService) RestartNodeService(ctx context.Context, nodeID int64, serviceName string) (string, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">upid, err := client.RestartNodeService(ctx, node.NodeName, serviceName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to restart node service",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.String("service", serviceName),
                        zap.Int64("node_id", nodeID))
                return "", fmt.Errorf("重启节点服务失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("node service restarted successfully",
                zap.String("node", node.NodeName),
                zap.String("service", serviceName),
                zap.String("upid", upid))

        return upid, nil</span>
}

// GetNodeNetworks 获取节点网络列表
func (s *pveNodeService) GetNodeNetworks(ctx context.Context, nodeID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">networks, err := client.GetNodeNetworks(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node networks",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return networks, nil</span>
}

// CreateNodeNetwork 创建网络设备配置
func (s *pveNodeService) CreateNodeNetwork(ctx context.Context, req *v1.CreateNodeNetworkRequest) error <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 构建 form 参数
        <span class="cov0" title="0">params := url.Values{}
        if req.Iface != nil &amp;&amp; *req.Iface != "" </span><span class="cov0" title="0">{
                params.Set("iface", *req.Iface)
        }</span>
        <span class="cov0" title="0">if req.Type != nil &amp;&amp; *req.Type != "" </span><span class="cov0" title="0">{
                params.Set("type", *req.Type)
        }</span>
        <span class="cov0" title="0">if req.Autostart != nil </span><span class="cov0" title="0">{
                params.Set("autostart", fmt.Sprintf("%d", *req.Autostart))
        }</span>
        <span class="cov0" title="0">if req.Comments != nil &amp;&amp; *req.Comments != "" </span><span class="cov0" title="0">{
                params.Set("comments", *req.Comments)
        }</span>
        <span class="cov0" title="0">if req.BridgePorts != nil &amp;&amp; *req.BridgePorts != "" </span><span class="cov0" title="0">{
                params.Set("bridge_ports", *req.BridgePorts)
        }</span>
        <span class="cov0" title="0">if req.BridgeVlanAware != nil </span><span class="cov0" title="0">{
                params.Set("bridge_vlan_aware", fmt.Sprintf("%d", *req.BridgeVlanAware))
        }</span>
        <span class="cov0" title="0">if req.Gateway != nil &amp;&amp; *req.Gateway != "" </span><span class="cov0" title="0">{
                params.Set("gateway", *req.Gateway)
        }</span>
        <span class="cov0" title="0">if req.Address != nil &amp;&amp; *req.Address != "" </span><span class="cov0" title="0">{
                params.Set("address", *req.Address)
        }</span>
        <span class="cov0" title="0">if req.Netmask != nil &amp;&amp; *req.Netmask != "" </span><span class="cov0" title="0">{
                params.Set("netmask", *req.Netmask)
        }</span>
        <span class="cov0" title="0">if req.BondMode != nil </span><span class="cov0" title="0">{
                params.Set("bond_mode", fmt.Sprintf("%d", *req.BondMode))
        }</span>
        <span class="cov0" title="0">if req.BondSlaves != nil &amp;&amp; *req.BondSlaves != "" </span><span class="cov0" title="0">{
                params.Set("bond_slaves", *req.BondSlaves)
        }</span>
        <span class="cov0" title="0">if req.MTU != nil </span><span class="cov0" title="0">{
                params.Set("mtu", fmt.Sprintf("%d", *req.MTU))
        }</span>

        // 调用 Proxmox API 创建网络配置
        <span class="cov0" title="0">err = client.CreateNodeNetwork(ctx, node.NodeName, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create node network",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", req.NodeID))
                return fmt.Errorf("创建网络配置失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("node network created successfully",
                zap.String("node", node.NodeName),
                zap.Int64("node_id", req.NodeID))

        return nil</span>
}

// ReloadNodeNetwork 重新加载网络配置
func (s *pveNodeService) ReloadNodeNetwork(ctx context.Context, nodeID int64) error <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = client.ReloadNodeNetwork(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to reload node network",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID))
                return fmt.Errorf("重新加载网络配置失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("node network reloaded successfully",
                zap.String("node", node.NodeName),
                zap.Int64("node_id", nodeID))

        return nil</span>
}

// RevertNodeNetwork 恢复网络配置更改
func (s *pveNodeService) RevertNodeNetwork(ctx context.Context, nodeID int64) error <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = client.RevertNodeNetwork(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to revert node network",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID))
                return fmt.Errorf("恢复网络配置失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("node network reverted successfully",
                zap.String("node", node.NodeName),
                zap.Int64("node_id", nodeID))

        return nil</span>
}

func (s *pveNodeService) GetNodeRRDData(ctx context.Context, nodeID int64, timeframe, cf string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rrdData, err := client.GetNodeRRDData(ctx, node.NodeName, timeframe, cf)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node rrd data", zap.Error(err),
                        zap.String("node", node.NodeName), zap.Int64("node_id", nodeID),
                        zap.String("timeframe", timeframe), zap.String("cf", cf))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return rrdData, nil</span>
}

func (s *pveNodeService) GetNodeDisksList(ctx context.Context, nodeID int64, includePartitions bool) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">disks, err := client.GetNodeDisksList(ctx, node.NodeName, includePartitions)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node disks list",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.Bool("include_partitions", includePartitions))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return disks, nil</span>
}

func (s *pveNodeService) GetNodeDisksDirectory(ctx context.Context, nodeID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">directories, err := client.GetNodeDisksDirectory(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node disks directory",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return directories, nil</span>
}

func (s *pveNodeService) GetNodeDisksLVM(ctx context.Context, nodeID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">lvms, err := client.GetNodeDisksLVM(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node disks lvm",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return lvms, nil</span>
}

func (s *pveNodeService) GetNodeDisksLVMThin(ctx context.Context, nodeID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">lvmthins, err := client.GetNodeDisksLVMThin(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node disks lvmthin",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return lvmthins, nil</span>
}

func (s *pveNodeService) GetNodeDisksZFS(ctx context.Context, nodeID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">zfss, err := client.GetNodeDisksZFS(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node disks zfs",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return zfss, nil</span>
}

func (s *pveNodeService) InitGPTDisk(ctx context.Context, nodeID int64, disk string) (string, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">upid, err := client.InitGPTDisk(ctx, node.NodeName, disk)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to init gpt disk",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("disk", disk))
                return "", v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return upid, nil</span>
}

func (s *pveNodeService) WipeDisk(ctx context.Context, nodeID int64, disk string, partition *int) (string, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">upid, err := client.WipeDisk(ctx, node.NodeName, disk, partition)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to wipe disk",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("disk", disk),
                        zap.Any("partition", partition))
                return "", v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return upid, nil</span>
}

// GetNodeStorageStatus 获取节点存储状态
func (s *pveNodeService) GetNodeStorageStatus(ctx context.Context, nodeID int64, storage string) (map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status, err := client.GetStorageStatus(ctx, node.NodeName, storage)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get storage status",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("storage", storage))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return status, nil</span>
}

// GetNodeStorageRRDData 获取节点存储 RRD 监控数据
func (s *pveNodeService) GetNodeStorageRRDData(ctx context.Context, nodeID int64, storage, timeframe, cf string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data, err := client.GetStorageRRDData(ctx, node.NodeName, storage, timeframe, cf)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get storage rrd data",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("storage", storage),
                        zap.String("timeframe", timeframe),
                        zap.String("cf", cf))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// GetNodeStorageContent 获取节点存储内容列表
func (s *pveNodeService) GetNodeStorageContent(ctx context.Context, nodeID int64, storage, content string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">items, err := client.GetStorageContent(ctx, node.NodeName, storage, content)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get storage content",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("storage", storage),
                        zap.String("content", content))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

// GetNodeStorageVolume 获取节点存储卷属性
func (s *pveNodeService) GetNodeStorageVolume(ctx context.Context, nodeID int64, storage, volume string) (map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">info, err := client.GetStorageVolume(ctx, node.NodeName, storage, volume)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get storage volume",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("storage", storage),
                        zap.String("volume", volume))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return info, nil</span>
}

// UploadNodeStorageContent 上传存储内容（模板 / ISO / OVA / VM 镜像）
func (s *pveNodeService) UploadNodeStorageContent(
        ctx context.Context,
        nodeID int64,
        storage, content, filename string,
        file multipart.File,
) (interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := client.UploadStorageContent(ctx, node.NodeName, storage, content, filename, file)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to upload storage content",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("storage", storage),
                        zap.String("filename", filename),
                        zap.String("content", content))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// DeleteNodeStorageContent 删除存储内容（镜像 / ISO / OVA / VM 镜像等）
func (s *pveNodeService) DeleteNodeStorageContent(
        ctx context.Context,
        nodeID int64,
        storage, volume string,
        delay *int,
) error <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := client.DeleteStorageContent(ctx, node.NodeName, storage, volume, delay); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete storage content",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", nodeID),
                        zap.String("storage", storage),
                        zap.String("volume", volume),
                        zap.Any("delay", delay))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetNodeConsole 获取节点控制台信息
func (s *pveNodeService) GetNodeConsole(ctx context.Context, req *v1.GetNodeConsoleRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        // 验证控制台类型
        req.ConsoleType = strings.ToLower(strings.TrimSpace(req.ConsoleType))
        if req.ConsoleType != "termproxy" &amp;&amp; req.ConsoleType != "vncshell" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid console_type: %s (must be 'termproxy' or 'vncshell')", req.ConsoleType)
        }</span>

        // 获取节点信息
        <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 获取集群信息（用于获取 api_url）
        <span class="cov0" title="0">if node.ClusterID &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("节点的集群 ID 无效")
        }</span>
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, node.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("集群 ID %d 不存在", node.ClusterID)
        }</span>

        // 如果提供了 ticket 和 csrf_token，使用高权限认证方式；否则使用集群配置的 API Token
        <span class="cov0" title="0">var client *proxmox.ProxmoxClient
        if strings.TrimSpace(req.Ticket) != "" &amp;&amp; strings.TrimSpace(req.CSRFToken) != "" </span><span class="cov0" title="0">{
                // 使用高权限 ticket 和 CSRF token 创建客户端
                client, err = proxmox.NewProxmoxClientWithTicket(cluster.ApiUrl, req.Ticket, req.CSRFToken)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create proxmox client with ticket", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Info("using high-privilege ticket authentication",
                        zap.Int64("node_id", req.NodeID),
                        zap.String("node_name", node.NodeName))</span>
        } else<span class="cov0" title="0"> {
                // 使用集群配置的 API Token
                client, err = proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
        }

        // 验证节点名称不为空
        <span class="cov0" title="0">if strings.TrimSpace(node.NodeName) == "" </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("node name is empty",
                        zap.Int64("node_id", req.NodeID))
                return nil, fmt.Errorf("node name is empty for node_id=%d", req.NodeID)
        }</span>

        // 验证节点是否存在于 Proxmox 集群中
        <span class="cov0" title="0">_, err = client.GetNodeStatus(ctx, node.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("node not found in proxmox cluster",
                        zap.Error(err),
                        zap.Int64("node_id", req.NodeID),
                        zap.String("node_name", node.NodeName))
                return nil, fmt.Errorf("node '%s' not found in proxmox cluster or access denied: %w", node.NodeName, err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("getting node console",
                zap.Int64("node_id", req.NodeID),
                zap.String("node_name", node.NodeName),
                zap.String("console_type", req.ConsoleType))

        var result map[string]interface{}

        if req.ConsoleType == "termproxy" </span><span class="cov0" title="0">{
                // 终端代理模式
                // 注意：termproxy 返回的数据结构与 vncshell 相同（包含 port、ticket、user、upid 等）
                result, err = client.NodeTermProxy(ctx, node.NodeName)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get node termproxy",
                                zap.Error(err),
                                zap.String("node", node.NodeName),
                                zap.Int64("node_id", req.NodeID),
                                zap.String("error_detail", err.Error()))
                        // 返回原始错误，让调用方能看到具体错误信息
                        return nil, fmt.Errorf("failed to get node termproxy: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // VNC Shell 模式
                // 默认启用 websocket，确保返回 port/ticket
                websocket := req.Websocket
                if !websocket </span><span class="cov0" title="0">{
                        websocket = true
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Debug("calling NodeVncShell",
                        zap.String("node_name", node.NodeName),
                        zap.Bool("websocket", websocket),
                        zap.Bool("generate_password", req.GeneratePassword))
                result, err = client.NodeVncShell(ctx, node.NodeName, websocket, req.GeneratePassword)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get node vncshell",
                                zap.Error(err),
                                zap.String("node", node.NodeName),
                                zap.Int64("node_id", req.NodeID),
                                zap.Bool("websocket", websocket),
                                zap.Bool("generate_password", req.GeneratePassword),
                                zap.String("error_detail", err.Error()))
                        // 返回原始错误，让调用方能看到具体错误信息
                        return nil, fmt.Errorf("failed to get node vncshell: %w", err)
                }</span>
        }

        // 无论是 termproxy 还是 vncshell，只要返回了 port/ticket，就生成短期 ws_token，
        // 统一通过 /api/v1/nodes/console/ws 代理到 Proxmox vncwebsocket。
        <span class="cov0" title="0">var port int
        switch v := result["port"].(type) </span>{
        case float64:<span class="cov0" title="0">
                port = int(v)</span>
        case int:<span class="cov0" title="0">
                port = v</span>
        case int64:<span class="cov0" title="0">
                port = int(v)</span>
        case json.Number:<span class="cov0" title="0">
                if p, err := v.Int64(); err == nil </span><span class="cov0" title="0">{
                        port = int(p)
                }</span>
        case string:<span class="cov0" title="0">
                if p, err := strconv.Atoi(strings.TrimSpace(v)); err == nil </span><span class="cov0" title="0">{
                        port = p
                }</span>
        }
        <span class="cov0" title="0">ticket, _ := result["ticket"].(string)
        if port &lt;= 0 || strings.TrimSpace(ticket) == "" </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("node console response missing port/ticket",
                        zap.String("node", node.NodeName),
                        zap.Int64("node_id", req.NodeID),
                        zap.String("console_type", req.ConsoleType),
                        zap.Int("port", port),
                        zap.String("ticket", ticket),
                        zap.Any("response_data", result))
                return nil, fmt.Errorf("node console response missing required fields: port=%d, ticket=%s", port, ticket)
        }</span>

        // 生成短期 token 用于 WebSocket 连接
        <span class="cov0" title="0">token, err := newNodeConsoleToken()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to generate console token", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">exp := time.Now().Add(2 * time.Minute)
        session := nodeConsoleSession{
                NodeID:        req.NodeID,
                NodeName:      node.NodeName,
                Port:          port,
                Ticket:        ticket, // VNC ticket（用于 vncwebsocket）
                ExpiresAt:     exp,
                ClusterApiURL: cluster.ApiUrl,
        }
        // 如果原始请求使用了高权限认证，保存认证信息用于后续 WebSocket 连接
        if strings.TrimSpace(req.Ticket) != "" &amp;&amp; strings.TrimSpace(req.CSRFToken) != "" </span><span class="cov0" title="0">{
                session.AuthTicket = req.Ticket
                session.AuthCSRFToken = req.CSRFToken
        }</span>
        <span class="cov0" title="0">s.consoleSessions.Store(token, session)
        result["ws_token"] = token
        result["ws_expires_at"] = exp.Unix()

        return result, nil</span>
}

// DialNodeConsoleWebsocket 通过 ws_token 建立到 Proxmox vncwebsocket 的连接（单次使用/短期有效）
func (s *pveNodeService) DialNodeConsoleWebsocket(ctx context.Context, token string) (*websocket.Conn, error) <span class="cov0" title="0">{
        if strings.TrimSpace(token) == "" </span><span class="cov0" title="0">{
                return nil, v1.ErrBadRequest
        }</span>

        <span class="cov0" title="0">val, ok := s.consoleSessions.LoadAndDelete(token)
        if !ok </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>
        <span class="cov0" title="0">session, ok := val.(nodeConsoleSession)
        if !ok </span><span class="cov0" title="0">{
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if time.Now().After(session.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, v1.ErrUnauthorized
        }</span>

        // 如果 session 中保存了高权限认证信息，使用这些信息创建客户端；否则使用集群配置的 API Token
        <span class="cov0" title="0">var client *proxmox.ProxmoxClient
        var err error
        if session.AuthTicket != "" &amp;&amp; session.AuthCSRFToken != "" </span><span class="cov0" title="0">{
                // 使用高权限 ticket 和 CSRF token
                client, err = proxmox.NewProxmoxClientWithTicket(session.ClusterApiURL, session.AuthTicket, session.AuthCSRFToken)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create proxmox client with ticket for websocket", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> {
                // 使用集群配置的 API Token
                client, _, err = s.getProxmoxClientForNode(ctx, session.NodeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">params := url.Values{}
        params.Set("port", fmt.Sprintf("%d", session.Port))
        params.Set("vncticket", session.Ticket)

        path := fmt.Sprintf("/nodes/%s/vncwebsocket", session.NodeName)
        conn, resp, err := client.WebSocket(path, params.Encode())
        if err != nil </span><span class="cov0" title="0">{
                var statusCode int
                if resp != nil </span><span class="cov0" title="0">{
                        statusCode = resp.StatusCode
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Error("failed to dial proxmox vncwebsocket", zap.Error(err),
                        zap.String("node", session.NodeName),
                        zap.Int64("node_id", session.NodeID),
                        zap.Int("response_status", statusCode))
                return nil, v1.ErrInternalServerError</span>
        }
        <span class="cov0" title="0">return conn, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package service

import (
        "context"
        "time"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"
        "pvesphere/internal/repository"
        "pvesphere/pkg/log"

        "go.uber.org/zap"
)

type PveStorageService interface {
        CreateStorage(ctx context.Context, req *v1.CreateStorageRequest) error
        UpdateStorage(ctx context.Context, id int64, req *v1.UpdateStorageRequest) error
        DeleteStorage(ctx context.Context, id int64) error
        GetStorage(ctx context.Context, id int64) (*v1.StorageDetail, error)
        ListStorages(ctx context.Context, req *v1.ListStorageRequest) (*v1.ListStorageResponseData, error)
}

func NewPveStorageService(
        service *Service,
        storageRepo repository.PveStorageRepository,
        nodeRepo repository.PveNodeRepository,
        logger *log.Logger,
) PveStorageService <span class="cov0" title="0">{
        return &amp;pveStorageService{
                storageRepo: storageRepo,
                nodeRepo:    nodeRepo,
                Service:     service,
                logger:      logger,
        }
}</span>

type pveStorageService struct {
        storageRepo repository.PveStorageRepository
        nodeRepo    repository.PveNodeRepository
        *Service
        logger *log.Logger
}

func (s *pveStorageService) CreateStorage(ctx context.Context, req *v1.CreateStorageRequest) error <span class="cov0" title="0">{
        // 检查存储是否已存在
        existing, err := s.storageRepo.GetByStorageName(ctx, req.StorageName, req.NodeName, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to check storage", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                return v1.ErrBadRequest
        }</span>

        <span class="cov0" title="0">storage := &amp;model.PveStorage{
                NodeName:     req.NodeName,
                ClusterID:    req.ClusterID,
                Active:       req.Active,
                Type:         req.Type,
                Avail:        req.Avail,
                StorageName:  req.StorageName,
                Content:      req.Content,
                Used:         req.Used,
                Total:        req.Total,
                Enabled:      req.Enabled,
                UsedFraction: req.UsedFraction,
                Shared:       req.Shared,
                CreateTime:   time.Now(),
                UpdateTime:   time.Now(),
        }

        if err := s.storageRepo.Create(ctx, storage); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create storage", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveStorageService) UpdateStorage(ctx context.Context, id int64, req *v1.UpdateStorageRequest) error <span class="cov0" title="0">{
        storage, err := s.storageRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get storage", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if storage == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.Active != nil </span><span class="cov0" title="0">{
                storage.Active = *req.Active
        }</span>
        <span class="cov0" title="0">if req.Type != nil </span><span class="cov0" title="0">{
                storage.Type = *req.Type
        }</span>
        <span class="cov0" title="0">if req.Avail != nil </span><span class="cov0" title="0">{
                storage.Avail = *req.Avail
        }</span>
        <span class="cov0" title="0">if req.Content != nil </span><span class="cov0" title="0">{
                storage.Content = *req.Content
        }</span>
        <span class="cov0" title="0">if req.Used != nil </span><span class="cov0" title="0">{
                storage.Used = *req.Used
        }</span>
        <span class="cov0" title="0">if req.Total != nil </span><span class="cov0" title="0">{
                storage.Total = *req.Total
        }</span>
        <span class="cov0" title="0">if req.Enabled != nil </span><span class="cov0" title="0">{
                storage.Enabled = *req.Enabled
        }</span>
        <span class="cov0" title="0">if req.UsedFraction != nil </span><span class="cov0" title="0">{
                storage.UsedFraction = *req.UsedFraction
        }</span>
        <span class="cov0" title="0">if req.Shared != nil </span><span class="cov0" title="0">{
                storage.Shared = *req.Shared
        }</span>
        <span class="cov0" title="0">storage.UpdateTime = time.Now()

        if err := s.storageRepo.Update(ctx, storage); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update storage", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveStorageService) DeleteStorage(ctx context.Context, id int64) error <span class="cov0" title="0">{
        storage, err := s.storageRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get storage", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if storage == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        <span class="cov0" title="0">if err := s.storageRepo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete storage", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveStorageService) GetStorage(ctx context.Context, id int64) (*v1.StorageDetail, error) <span class="cov0" title="0">{
        storage, err := s.storageRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get storage", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if storage == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 查询节点 ID
        <span class="cov0" title="0">var nodeID int64
        node, err := s.nodeRepo.GetByNodeName(ctx, storage.NodeName, storage.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Warn("failed to get node for storage",
                        zap.Error(err),
                        zap.String("node_name", storage.NodeName),
                        zap.Int64("cluster_id", storage.ClusterID))
        }</span> else<span class="cov0" title="0"> if node != nil </span><span class="cov0" title="0">{
                nodeID = node.Id
        }</span>

        <span class="cov0" title="0">return &amp;v1.StorageDetail{
                Id:           storage.Id,
                NodeName:     storage.NodeName,
                NodeID:       nodeID,
                ClusterID:    storage.ClusterID,
                Active:       storage.Active,
                Type:         storage.Type,
                Avail:        storage.Avail,
                StorageName:  storage.StorageName,
                Content:      storage.Content,
                Used:         storage.Used,
                Total:        storage.Total,
                Enabled:      storage.Enabled,
                UsedFraction: storage.UsedFraction,
                Shared:       storage.Shared,
                CreateTime:   storage.CreateTime,
                UpdateTime:   storage.UpdateTime,
                Creator:      storage.Creator,
                Modifier:     storage.Modifier,
        }, nil</span>
}

func (s *pveStorageService) ListStorages(ctx context.Context, req *v1.ListStorageRequest) (*v1.ListStorageResponseData, error) <span class="cov0" title="0">{
        storages, total, err := s.storageRepo.ListWithPagination(ctx, req.Page, req.PageSize, req.ClusterID, req.NodeName, req.Type, req.StorageName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list storages", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 构建节点名称到节点 ID 的映射（批量查询优化）
        <span class="cov0" title="0">type nodeKey struct {
                nodeName  string
                clusterID int64
        }
        nodeIDMap := make(map[nodeKey]int64)

        // 收集所有唯一的 (node_name, cluster_id) 组合
        nodeKeys := make(map[nodeKey]struct{})
        for _, storage := range storages </span><span class="cov0" title="0">{
                nodeKeys[nodeKey{nodeName: storage.NodeName, clusterID: storage.ClusterID}] = struct{}{}
        }</span>

        // 批量查询节点信息
        <span class="cov0" title="0">for key := range nodeKeys </span><span class="cov0" title="0">{
                node, err := s.nodeRepo.GetByNodeName(ctx, key.nodeName, key.clusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get node for storage mapping",
                                zap.Error(err),
                                zap.String("node_name", key.nodeName),
                                zap.Int64("cluster_id", key.clusterID))
                        continue</span>
                }
                <span class="cov0" title="0">if node != nil </span><span class="cov0" title="0">{
                        nodeIDMap[key] = node.Id
                }</span>
        }

        <span class="cov0" title="0">items := make([]v1.StorageItem, 0, len(storages))
        for _, storage := range storages </span><span class="cov0" title="0">{
                nodeIDKey := nodeKey{nodeName: storage.NodeName, clusterID: storage.ClusterID}
                nodeID := nodeIDMap[nodeIDKey]

                items = append(items, v1.StorageItem{
                        Id:           storage.Id,
                        NodeName:     storage.NodeName,
                        NodeID:       nodeID,
                        ClusterID:    storage.ClusterID,
                        Active:       storage.Active,
                        Type:         storage.Type,
                        Avail:        storage.Avail,
                        StorageName:  storage.StorageName,
                        Content:      storage.Content,
                        Used:         storage.Used,
                        Total:        storage.Total,
                        Enabled:      storage.Enabled,
                        UsedFraction: storage.UsedFraction,
                        Shared:       storage.Shared,
                })
        }</span>

        <span class="cov0" title="0">return &amp;v1.ListStorageResponseData{
                Total: total,
                List:  items,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package service

import (
        "context"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/repository"
        "pvesphere/pkg/log"
        "pvesphere/pkg/proxmox"

        "go.uber.org/zap"
)

type PveTaskService interface {
        ListClusterTasks(ctx context.Context, req *v1.ListClusterTasksRequest) ([]v1.ClusterTaskItem, error)
        ListNodeTasks(ctx context.Context, req *v1.ListNodeTasksRequest) ([]v1.NodeTaskItem, error)
        GetTaskLog(ctx context.Context, req *v1.GetTaskLogRequest) ([]v1.TaskLogItem, error)
        GetTaskStatus(ctx context.Context, req *v1.GetTaskStatusRequest) (*v1.TaskStatusItem, error)
        StopTask(ctx context.Context, req *v1.StopTaskRequest) error
}

func NewPveTaskService(
        service *Service,
        clusterRepo repository.PveClusterRepository,
        logger *log.Logger,
) PveTaskService <span class="cov0" title="0">{
        return &amp;pveTaskService{
                clusterRepo: clusterRepo,
                Service:     service,
                logger:      logger,
        }
}</span>

type pveTaskService struct {
        clusterRepo repository.PveClusterRepository
        *Service
        logger *log.Logger
}

// getProxmoxClient 根据集群ID获取ProxmoxClient
func (s *pveTaskService) getProxmoxClient(ctx context.Context, clusterID int64) (*proxmox.ProxmoxClient, error) <span class="cov0" title="0">{
        cluster, err := s.clusterRepo.GetByID(ctx, clusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err), zap.Int64("cluster_id", clusterID))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        <span class="cov0" title="0">client, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err), zap.Int64("cluster_id", clusterID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

func (s *pveTaskService) ListClusterTasks(ctx context.Context, req *v1.ListClusterTasksRequest) ([]v1.ClusterTaskItem, error) <span class="cov0" title="0">{
        client, err := s.getProxmoxClient(ctx, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tasks, err := client.GetClusterTasks(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster tasks", zap.Error(err), zap.Int64("cluster_id", req.ClusterID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">result := make([]v1.ClusterTaskItem, 0, len(tasks))
        for _, task := range tasks </span><span class="cov0" title="0">{
                item := v1.ClusterTaskItem{
                        Extra: make(map[string]interface{}),
                }

                if upid, ok := task["upid"].(string); ok </span><span class="cov0" title="0">{
                        item.UPID = upid
                }</span>
                <span class="cov0" title="0">if taskType, ok := task["type"].(string); ok </span><span class="cov0" title="0">{
                        item.Type = taskType
                }</span>
                <span class="cov0" title="0">if id, ok := task["id"].(string); ok </span><span class="cov0" title="0">{
                        item.ID = id
                }</span>
                <span class="cov0" title="0">if user, ok := task["user"].(string); ok </span><span class="cov0" title="0">{
                        item.User = user
                }</span>
                <span class="cov0" title="0">if status, ok := task["status"].(string); ok </span><span class="cov0" title="0">{
                        item.Status = status
                }</span>
                <span class="cov0" title="0">if startTime, ok := task["starttime"].(float64); ok </span><span class="cov0" title="0">{
                        item.StartTime = int64(startTime)
                }</span>
                <span class="cov0" title="0">if endTime, ok := task["endtime"].(float64); ok </span><span class="cov0" title="0">{
                        item.EndTime = int64(endTime)
                }</span>
                <span class="cov0" title="0">if node, ok := task["node"].(string); ok </span><span class="cov0" title="0">{
                        item.Node = node
                }</span>

                // 保存其他字段到Extra
                <span class="cov0" title="0">for k, v := range task </span><span class="cov0" title="0">{
                        if k != "upid" &amp;&amp; k != "type" &amp;&amp; k != "id" &amp;&amp; k != "user" &amp;&amp; k != "status" &amp;&amp; k != "starttime" &amp;&amp; k != "endtime" &amp;&amp; k != "node" </span><span class="cov0" title="0">{
                                item.Extra[k] = v
                        }</span>
                }

                <span class="cov0" title="0">result = append(result, item)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (s *pveTaskService) ListNodeTasks(ctx context.Context, req *v1.ListNodeTasksRequest) ([]v1.NodeTaskItem, error) <span class="cov0" title="0">{
        client, err := s.getProxmoxClient(ctx, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tasks, err := client.GetNodeTasks(ctx, req.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node tasks", zap.Error(err),
                        zap.Int64("cluster_id", req.ClusterID), zap.String("node_name", req.NodeName))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">result := make([]v1.NodeTaskItem, 0, len(tasks))
        for _, task := range tasks </span><span class="cov0" title="0">{
                item := v1.NodeTaskItem{
                        Extra: make(map[string]interface{}),
                }

                if upid, ok := task["upid"].(string); ok </span><span class="cov0" title="0">{
                        item.UPID = upid
                }</span>
                <span class="cov0" title="0">if taskType, ok := task["type"].(string); ok </span><span class="cov0" title="0">{
                        item.Type = taskType
                }</span>
                <span class="cov0" title="0">if id, ok := task["id"].(string); ok </span><span class="cov0" title="0">{
                        item.ID = id
                }</span>
                <span class="cov0" title="0">if user, ok := task["user"].(string); ok </span><span class="cov0" title="0">{
                        item.User = user
                }</span>
                <span class="cov0" title="0">if status, ok := task["status"].(string); ok </span><span class="cov0" title="0">{
                        item.Status = status
                }</span>
                <span class="cov0" title="0">if startTime, ok := task["starttime"].(float64); ok </span><span class="cov0" title="0">{
                        item.StartTime = int64(startTime)
                }</span>
                <span class="cov0" title="0">if endTime, ok := task["endtime"].(float64); ok </span><span class="cov0" title="0">{
                        item.EndTime = int64(endTime)
                }</span>

                // 保存其他字段到Extra
                <span class="cov0" title="0">for k, v := range task </span><span class="cov0" title="0">{
                        if k != "upid" &amp;&amp; k != "type" &amp;&amp; k != "id" &amp;&amp; k != "user" &amp;&amp; k != "status" &amp;&amp; k != "starttime" &amp;&amp; k != "endtime" </span><span class="cov0" title="0">{
                                item.Extra[k] = v
                        }</span>
                }

                <span class="cov0" title="0">result = append(result, item)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (s *pveTaskService) GetTaskLog(ctx context.Context, req *v1.GetTaskLogRequest) ([]v1.TaskLogItem, error) <span class="cov0" title="0">{
        client, err := s.getProxmoxClient(ctx, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logs, err := client.GetTaskLog(ctx, req.NodeName, req.UPID, req.Start, req.Limit)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get task log", zap.Error(err),
                        zap.Int64("cluster_id", req.ClusterID), zap.String("node_name", req.NodeName), zap.String("upid", req.UPID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">result := make([]v1.TaskLogItem, 0, len(logs))
        for _, log := range logs </span><span class="cov0" title="0">{
                item := v1.TaskLogItem{}

                if n, ok := log["n"].(float64); ok </span><span class="cov0" title="0">{
                        item.N = int(n)
                }</span>
                <span class="cov0" title="0">if t, ok := log["t"].(string); ok </span><span class="cov0" title="0">{
                        item.T = t
                }</span>

                <span class="cov0" title="0">result = append(result, item)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (s *pveTaskService) GetTaskStatus(ctx context.Context, req *v1.GetTaskStatusRequest) (*v1.TaskStatusItem, error) <span class="cov0" title="0">{
        client, err := s.getProxmoxClient(ctx, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status, err := client.GetTaskStatus(ctx, req.NodeName, req.UPID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get task status", zap.Error(err),
                        zap.Int64("cluster_id", req.ClusterID), zap.String("node_name", req.NodeName), zap.String("upid", req.UPID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">item := &amp;v1.TaskStatusItem{
                Extra: make(map[string]interface{}),
        }

        if upid, ok := status["upid"].(string); ok </span><span class="cov0" title="0">{
                item.UPID = upid
        }</span>
        <span class="cov0" title="0">if taskType, ok := status["type"].(string); ok </span><span class="cov0" title="0">{
                item.Type = taskType
        }</span>
        <span class="cov0" title="0">if id, ok := status["id"].(string); ok </span><span class="cov0" title="0">{
                item.ID = id
        }</span>
        <span class="cov0" title="0">if user, ok := status["user"].(string); ok </span><span class="cov0" title="0">{
                item.User = user
        }</span>
        <span class="cov0" title="0">if statusStr, ok := status["status"].(string); ok </span><span class="cov0" title="0">{
                item.Status = statusStr
        }</span>
        <span class="cov0" title="0">if startTime, ok := status["starttime"].(float64); ok </span><span class="cov0" title="0">{
                item.StartTime = int64(startTime)
        }</span>
        <span class="cov0" title="0">if endTime, ok := status["endtime"].(float64); ok </span><span class="cov0" title="0">{
                item.EndTime = int64(endTime)
        }</span>
        <span class="cov0" title="0">if pid, ok := status["pid"].(float64); ok </span><span class="cov0" title="0">{
                item.Pid = int(pid)
        }</span>
        <span class="cov0" title="0">if pStart, ok := status["pstart"].(float64); ok </span><span class="cov0" title="0">{
                item.PStart = int64(pStart)
        }</span>
        <span class="cov0" title="0">if exitStatus, ok := status["exitstatus"]; ok </span><span class="cov0" title="0">{
                item.ExitStatus = exitStatus
        }</span>

        // 保存其他字段到Extra
        <span class="cov0" title="0">for k, v := range status </span><span class="cov0" title="0">{
                if k != "upid" &amp;&amp; k != "type" &amp;&amp; k != "id" &amp;&amp; k != "user" &amp;&amp; k != "status" &amp;&amp; k != "starttime" &amp;&amp; k != "endtime" &amp;&amp; k != "pid" &amp;&amp; k != "pstart" &amp;&amp; k != "exitstatus" </span><span class="cov0" title="0">{
                        item.Extra[k] = v
                }</span>
        }

        <span class="cov0" title="0">return item, nil</span>
}

func (s *pveTaskService) StopTask(ctx context.Context, req *v1.StopTaskRequest) error <span class="cov0" title="0">{
        client, err := s.getProxmoxClient(ctx, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := client.StopTask(ctx, req.NodeName, req.UPID); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to stop task", zap.Error(err),
                        zap.Int64("cluster_id", req.ClusterID), zap.String("node_name", req.NodeName), zap.String("upid", req.UPID))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package service

import (
        "context"
        "time"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"
        "pvesphere/internal/repository"
        "pvesphere/pkg/log"
        "pvesphere/pkg/proxmox"

        "go.uber.org/zap"
)

type PveTemplateService interface {
        CreateTemplate(ctx context.Context, req *v1.CreateTemplateRequest) error
        UpdateTemplate(ctx context.Context, id int64, req *v1.UpdateTemplateRequest) error
        DeleteTemplate(ctx context.Context, id int64) error
        GetTemplate(ctx context.Context, id int64) (*v1.TemplateDetail, error)
        ListTemplates(ctx context.Context, req *v1.ListTemplateRequest) (*v1.ListTemplateResponseData, error)
}

func NewPveTemplateService(
        service *Service,
        tplRepo repository.PveTemplateRepository,
        instanceRepo repository.TemplateInstanceRepository,
        syncTaskRepo repository.TemplateSyncTaskRepository,
        uploadRepo repository.TemplateUploadRepository,
        nodeRepo repository.PveNodeRepository,
        clusterRepo repository.PveClusterRepository,
        logger *log.Logger,
) PveTemplateService <span class="cov0" title="0">{
        return &amp;pveTemplateService{
                tplRepo:      tplRepo,
                instanceRepo: instanceRepo,
                syncTaskRepo: syncTaskRepo,
                uploadRepo:   uploadRepo,
                nodeRepo:     nodeRepo,
                clusterRepo:  clusterRepo,
                Service:      service,
                logger:       logger,
        }
}</span>

type pveTemplateService struct {
        tplRepo      repository.PveTemplateRepository
        instanceRepo repository.TemplateInstanceRepository
        syncTaskRepo repository.TemplateSyncTaskRepository
        uploadRepo   repository.TemplateUploadRepository
        nodeRepo     repository.PveNodeRepository
        clusterRepo  repository.PveClusterRepository
        *Service
        logger *log.Logger
}

func (s *pveTemplateService) CreateTemplate(ctx context.Context, req *v1.CreateTemplateRequest) error <span class="cov0" title="0">{
        tpl := &amp;model.PveTemplate{
                TemplateName: req.TemplateName,
                ClusterID:    req.ClusterID,
                Description:  req.Description,
                CreateTime:   time.Now(),
                UpdateTime:   time.Now(),
        }

        if err := s.tplRepo.Create(ctx, tpl); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create template", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *pveTemplateService) UpdateTemplate(ctx context.Context, id int64, req *v1.UpdateTemplateRequest) error <span class="cov0" title="0">{
        tpl, err := s.tplRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get template", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if tpl == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        <span class="cov0" title="0">if req.TemplateName != nil </span><span class="cov0" title="0">{
                tpl.TemplateName = *req.TemplateName
        }</span>
        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                tpl.Description = *req.Description
        }</span>
        <span class="cov0" title="0">tpl.UpdateTime = time.Now()

        if err := s.tplRepo.Update(ctx, tpl); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update template", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *pveTemplateService) DeleteTemplate(ctx context.Context, id int64) error <span class="cov0" title="0">{
        tpl, err := s.tplRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get template", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if tpl == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 1. 查询所有模板实例
        <span class="cov0" title="0">instances, err := s.instanceRepo.ListByTemplateID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list template instances", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        // 2. 删除所有节点上的 Proxmox 模板
        <span class="cov0" title="0">for _, instance := range instances </span><span class="cov0" title="0">{
                if instance.VMID == 0 </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("instance has no VMID, skip deletion",
                                zap.Int64("instance_id", instance.Id),
                                zap.String("node_name", instance.NodeName))
                        continue</span>
                }

                // 获取节点信息
                <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, instance.NodeID)
                if err != nil || node == nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get node",
                                zap.Error(err),
                                zap.Int64("node_id", instance.NodeID))
                        continue</span>
                }

                // 获取集群信息
                <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, node.ClusterID)
                if err != nil || cluster == nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster",
                                zap.Error(err),
                                zap.Int64("cluster_id", node.ClusterID))
                        continue</span>
                }

                // 创建 Proxmox 客户端
                <span class="cov0" title="0">client, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create proxmox client",
                                zap.Error(err),
                                zap.String("node_name", node.NodeName))
                        continue</span>
                }

                // 删除 Proxmox 模板（purge=true 表示同时删除磁盘）
                <span class="cov0" title="0">err = client.DeleteVM(ctx, node.NodeName, instance.VMID, true)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to delete proxmox template",
                                zap.Error(err),
                                zap.String("node_name", node.NodeName),
                                zap.Uint32("vmid", instance.VMID))
                        // 继续删除其他实例，不中断流程
                }</span> else<span class="cov0" title="0"> {
                        s.logger.WithContext(ctx).Info("deleted proxmox template",
                                zap.String("node_name", node.NodeName),
                                zap.Uint32("vmid", instance.VMID))
                }</span>
        }

        // 3. 删除所有同步任务
        <span class="cov0" title="0">syncTasks, err := s.syncTaskRepo.ListByTemplateID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list sync tasks", zap.Error(err))
                // 继续执行，不中断流程
        }</span> else<span class="cov0" title="0"> {
                for _, task := range syncTasks </span><span class="cov0" title="0">{
                        if err := s.syncTaskRepo.Delete(ctx, task.Id); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to delete sync task",
                                        zap.Error(err),
                                        zap.Int64("task_id", task.Id))
                        }</span>
                }
        }

        // 4. 删除所有模板实例
        <span class="cov0" title="0">if err := s.instanceRepo.DeleteByTemplateID(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete template instances", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        // 5. 删除上传记录（可选，保留历史记录）
        // 如果需要保留历史记录，可以注释掉这部分
        <span class="cov0" title="0">upload, err := s.uploadRepo.GetByTemplateID(ctx, id)
        if err == nil &amp;&amp; upload != nil </span><span class="cov0" title="0">{
                // 可以选择删除或保留上传记录
                // 这里选择保留，只删除关联关系
                s.logger.WithContext(ctx).Info("keeping upload record for history",
                        zap.Int64("upload_id", upload.Id))
        }</span>

        // 6. 最后删除模板记录
        <span class="cov0" title="0">if err := s.tplRepo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete template", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("template deleted successfully",
                zap.Int64("template_id", id),
                zap.String("template_name", tpl.TemplateName))

        return nil</span>
}

func (s *pveTemplateService) GetTemplate(ctx context.Context, id int64) (*v1.TemplateDetail, error) <span class="cov0" title="0">{
        tpl, err := s.tplRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get template", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if tpl == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 查询集群信息填充 cluster_name
        <span class="cov0" title="0">var clusterName string
        if tpl.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                cluster, err := s.clusterRepo.GetByID(ctx, tpl.ClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("failed to get cluster",
                                zap.Error(err), zap.Int64("cluster_id", tpl.ClusterID))
                        // 不阻塞主流程，cluster_name 为空
                }</span> else<span class="cov0" title="0"> if cluster != nil </span><span class="cov0" title="0">{
                        clusterName = cluster.ClusterName
                }</span>
        }

        <span class="cov0" title="0">return &amp;v1.TemplateDetail{
                Id:           tpl.Id,
                TemplateName: tpl.TemplateName,
                ClusterID:    tpl.ClusterID,
                ClusterName:  clusterName,
                Description:  tpl.Description,
                CreateTime:   tpl.CreateTime,
                UpdateTime:   tpl.UpdateTime,
                Creator:      tpl.Creator,
                Modifier:     tpl.Modifier,
        }, nil</span>
}

func (s *pveTemplateService) ListTemplates(ctx context.Context, req *v1.ListTemplateRequest) (*v1.ListTemplateResponseData, error) <span class="cov0" title="0">{
        tpls, total, err := s.tplRepo.ListWithPagination(ctx, req.Page, req.PageSize, req.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list templates", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">items := make([]v1.TemplateItem, 0, len(tpls))
        for _, tpl := range tpls </span><span class="cov0" title="0">{
                items = append(items, v1.TemplateItem{
                        Id:           tpl.Id,
                        TemplateName: tpl.TemplateName,
                        ClusterID:    tpl.ClusterID,
                        Description:  tpl.Description,
                })
        }</span>

        <span class="cov0" title="0">return &amp;v1.ListTemplateResponseData{
                Total: total,
                List:  items,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package service

import (
        "context"
        crand "crypto/rand"
        "encoding/base64"
        "encoding/json"
        "fmt"
        mrand "math/rand"
        "net/url"
        "strconv"
        "strings"
        "sync"
        "time"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"
        "pvesphere/internal/repository"
        "pvesphere/pkg/log"
        "pvesphere/pkg/proxmox"

        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

type PveVMService interface {
        CreateVM(ctx context.Context, req *v1.CreateVMRequest) error
        CreateVMInProxmox(ctx context.Context, req *v1.CreateVMRequest) error
        UpdateVM(ctx context.Context, id int64, req *v1.UpdateVMRequest) error
        DeleteVM(ctx context.Context, id int64) error
        GetVM(ctx context.Context, id int64) (*v1.VMDetail, error)
        ListVMs(ctx context.Context, req *v1.ListVMRequest) (*v1.ListVMResponseData, error)
        StartVM(ctx context.Context, id int64) error
        StopVM(ctx context.Context, id int64) error
        GetVMCurrentConfig(ctx context.Context, vmID int64) (map[string]interface{}, error)
        GetVMPendingConfig(ctx context.Context, vmID int64) ([]map[string]interface{}, error)
        UpdateVMConfig(ctx context.Context, req *v1.UpdateVMConfigRequest) error
        GetVMStatus(ctx context.Context, vmID int64) (map[string]interface{}, error)
        GetVMConsole(ctx context.Context, req *v1.GetVMConsoleRequest) (map[string]interface{}, error)
        DialVMConsoleWebsocket(ctx context.Context, token string) (*websocket.Conn, error)
        GetVMRRDData(ctx context.Context, vmID int64, timeframe, cf string) ([]map[string]interface{}, error)
        MigrateVM(ctx context.Context, req *v1.MigrateVMRequest) (string, error)
        RemoteMigrateVM(ctx context.Context, req *v1.RemoteMigrateVMRequest) (string, error)
        CreateBackup(ctx context.Context, req *v1.CreateBackupRequest) (*v1.CreateBackupResponseData, error)
        DeleteBackup(ctx context.Context, req *v1.DeleteBackupRequest) error
        GetVMCloudInit(ctx context.Context, req *v1.GetVMCloudInitRequest) (map[string]interface{}, error)
        UpdateVMCloudInit(ctx context.Context, req *v1.UpdateVMCloudInitRequest) error
}

func NewPveVMService(
        service *Service,
        vmRepo repository.PveVMRepository,
        templateRepo repository.VmTemplateRepository,
        templateInstanceRepo repository.TemplateInstanceRepository,
        storageRepo repository.PveStorageRepository,
        ipRepo repository.VMIPAddressRepository,
        clusterRepo repository.PveClusterRepository,
        nodeRepo repository.PveNodeRepository,
        logger *log.Logger,
) PveVMService <span class="cov0" title="0">{
        return &amp;pveVMService{
                vmRepo:               vmRepo,
                templateRepo:         templateRepo,
                templateInstanceRepo: templateInstanceRepo,
                storageRepo:          storageRepo,
                ipRepo:               ipRepo,
                clusterRepo:          clusterRepo,
                nodeRepo:             nodeRepo,
                Service:              service,
                logger:               logger,
        }
}</span>

type pveVMService struct {
        vmRepo               repository.PveVMRepository
        templateRepo         repository.VmTemplateRepository
        templateInstanceRepo repository.TemplateInstanceRepository
        storageRepo          repository.PveStorageRepository
        ipRepo               repository.VMIPAddressRepository
        clusterRepo          repository.PveClusterRepository
        nodeRepo             repository.PveNodeRepository
        *Service
        logger *log.Logger

        consoleSessions sync.Map // token -&gt; vmConsoleSession
}

type vmConsoleSession struct {
        VMID      int64
        Port      int
        Ticket    string
        ExpiresAt time.Time
}

func newConsoleToken() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 24)
        if _, err := crand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.RawURLEncoding.EncodeToString(b), nil</span>
}

// generateProxmoxVMID 根据传入的 ID 或时间纳秒 + 随机数生成 8 位数 VM ID。
// - 如果 providedID 不为 0，则直接返回 providedID
// - 如果为 0，则自动生成一个 8 位的随机数字（范围 10000000 ~ 99999999）
func generateProxmoxVMID(providedID uint32) uint32 <span class="cov0" title="0">{
        if providedID != 0 </span><span class="cov0" title="0">{
                return providedID
        }</span>

        // 以当前时间纳秒作为随机种子，叠加一次随机数，生成 8 位数字
        <span class="cov0" title="0">now := time.Now().UnixNano()
        r := mrand.New(mrand.NewSource(now))
        n := now + int64(r.Intn(1_000_000))

        // 取模 1e8，保证不超过 8 位；再保证至少是 8 位（&gt;= 10^7）
        v := n % 100_000_000
        if v &lt; 10_000_000 </span><span class="cov0" title="0">{
                v += 10_000_000
        }</span>
        <span class="cov0" title="0">return uint32(v)</span>
}

// CreateVM 仅创建数据库记录，用于手动同步或导入场景
func (s *pveVMService) CreateVM(ctx context.Context, req *v1.CreateVMRequest) error <span class="cov0" title="0">{
        // 0. 如果未显式传入 VMID，则自动生成一个 8 位数的 VM ID
        vmID := generateProxmoxVMID(req.VMID)
        req.VMID = vmID

        // 1. 获取模板信息
        template, err := s.templateRepo.GetByID(ctx, req.TemplateID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get template", zap.Error(err), zap.Int64("template_id", req.TemplateID))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if template == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("模板 %d 不存在", req.TemplateID)
        }</span>

        // 2. 获取集群信息（优先使用 ID，如果没有则使用名称）
        <span class="cov0" title="0">var cluster *model.PveCluster
        if req.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                cluster, err = s.clusterRepo.GetByID(ctx, req.ClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster by id", zap.Error(err), zap.Int64("cluster_id", req.ClusterID))
                        return v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> if req.ClusterName != "" </span><span class="cov0" title="0">{
                cluster, err = s.clusterRepo.GetByClusterName(ctx, req.ClusterName)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster by name", zap.Error(err))
                        return v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("必须提供 cluster_id 或 cluster_name")
        }</span>

        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                if req.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("集群 ID %d 不存在", req.ClusterID)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("集群 %s 不存在", req.ClusterName)</span>
        }

        // 3. 获取节点信息（优先使用 ID，如果没有则使用名称）
        <span class="cov0" title="0">var node *model.PveNode
        if req.NodeID &gt; 0 </span><span class="cov0" title="0">{
                node, err = s.nodeRepo.GetByID(ctx, req.NodeID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get node by id", zap.Error(err), zap.Int64("node_id", req.NodeID))
                        return v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> if req.NodeName != "" </span><span class="cov0" title="0">{
                node, err = s.nodeRepo.GetByNodeName(ctx, req.NodeName, cluster.Id)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get node by name", zap.Error(err))
                        return v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("必须提供 node_id 或 node_name")
        }</span>

        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                if req.NodeID &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("节点 ID %d 不存在", req.NodeID)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("节点 %s 在集群 %s 中不存在", req.NodeName, cluster.ClusterName)</span>
        }

        // 4. 检查新虚拟机是否已存在（使用 NodeID）
        <span class="cov0" title="0">existing, err := s.vmRepo.GetByVMID(ctx, vmID, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to check vm", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Warn("vm already exists", zap.Uint32("vmid", vmID), zap.Int64("node_id", node.Id))
                return fmt.Errorf("虚拟机 %d 在节点 %s 上已存在", vmID, node.NodeName)
        }</span>

        // 5. 查找模板实例（优先查找目标节点上的实例，如果没有则查找主实例或其他可用实例）
        <span class="cov0" title="0">var templateInstance *model.TemplateInstance

        // 优先查找目标节点上的模板实例
        instance, err := s.templateInstanceRepo.GetByTemplateAndNode(ctx, template.Id, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get template instance", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">if instance != nil &amp;&amp; instance.Status == model.TemplateInstanceStatusAvailable </span><span class="cov0" title="0">{
                // 目标节点上有可用的模板实例
                templateInstance = instance
        }</span> else<span class="cov0" title="0"> {
                // 目标节点上没有可用实例，查找主实例或其他可用实例
                primaryInstance, err := s.templateInstanceRepo.GetPrimaryInstance(ctx, template.Id)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get primary template instance", zap.Error(err))
                        return v1.ErrInternalServerError
                }</span>
                <span class="cov0" title="0">if primaryInstance != nil &amp;&amp; primaryInstance.Status == model.TemplateInstanceStatusAvailable </span><span class="cov0" title="0">{
                        templateInstance = primaryInstance
                }</span> else<span class="cov0" title="0"> {
                        // 查找任何可用的实例
                        allInstances, err := s.templateInstanceRepo.ListByTemplateID(ctx, template.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to list template instances", zap.Error(err))
                                return v1.ErrInternalServerError
                        }</span>
                        <span class="cov0" title="0">for _, inst := range allInstances </span><span class="cov0" title="0">{
                                if inst.Status == model.TemplateInstanceStatusAvailable </span><span class="cov0" title="0">{
                                        templateInstance = inst
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">if templateInstance == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("模板 ID %d 没有可用的模板实例", template.Id)
        }</span>

        // 6. 创建数据库记录（仅数据库操作，不调用 Proxmox API）
        <span class="cov0" title="0">vm := &amp;model.PveVM{
                VmName:     req.VmName,
                ClusterID:  cluster.Id,
                NodeID:     node.Id,
                TemplateID: template.Id,
                VMID:       vmID,
                Status:     "stopped", // 默认停止状态
                CreateTime: time.Now(),
                UpdateTime: time.Now(),
        }

        // 如果提供了配置，则使用提供的配置，否则使用默认值
        if req.CPUNum != nil </span><span class="cov0" title="0">{
                vm.CPUNum = *req.CPUNum
        }</span> else<span class="cov0" title="0"> {
                vm.CPUNum = 2 // 默认 2 核
        }</span>
        <span class="cov0" title="0">if req.MemorySize != nil </span><span class="cov0" title="0">{
                vm.MemorySize = *req.MemorySize
        }</span> else<span class="cov0" title="0"> {
                vm.MemorySize = 4096 // 默认 4GB
        }</span>
        <span class="cov0" title="0">if req.Storage != "" </span><span class="cov0" title="0">{
                vm.Storage = req.Storage
        }</span> else<span class="cov0" title="0"> {
                vm.Storage = templateInstance.StorageName // 使用模板实例的存储
        }</span>
        <span class="cov0" title="0">if req.StorageCfg != "" </span><span class="cov0" title="0">{
                vm.StorageCfg = req.StorageCfg
        }</span> else<span class="cov0" title="0"> {
                vm.StorageCfg = "{}" // 默认空配置
        }</span>
        <span class="cov0" title="0">if req.AppId != "" </span><span class="cov0" title="0">{
                vm.AppId = req.AppId
        }</span>
        <span class="cov0" title="0">if req.VmUser != "" </span><span class="cov0" title="0">{
                vm.VmUser = req.VmUser
        }</span>
        <span class="cov0" title="0">if req.VmPassword != "" </span><span class="cov0" title="0">{
                vm.VmPassword = req.VmPassword
        }</span>
        <span class="cov0" title="0">if node.IPAddress != "" </span><span class="cov0" title="0">{
                vm.NodeIP = node.IPAddress
        }</span>
        <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                vm.Description = req.Description
        }</span>

        <span class="cov0" title="0">if err := s.vmRepo.Create(ctx, vm); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create vm record", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        // 7. 如果提供了 IP 地址 ID，创建 IP 地址记录
        <span class="cov0" title="0">if req.IPAddressID != nil </span><span class="cov0" title="0">{
                ipAddr, err := s.ipRepo.GetByID(ctx, *req.IPAddressID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get ip address", zap.Error(err))
                        // IP 地址获取失败不影响虚拟机创建，只记录日志
                }</span> else<span class="cov0" title="0"> if ipAddr != nil </span><span class="cov0" title="0">{
                        // 更新 IP 地址记录的 VMId 和 ClusterID
                        ipAddr.VMId = vm.Id
                        ipAddr.ClusterID = cluster.Id
                        if err := s.ipRepo.Update(ctx, ipAddr); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to update ip address", zap.Error(err))
                                // IP 地址更新失败不影响虚拟机创建，只记录日志
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// CreateVMInProxmox 完整创建流程：调用 Proxmox API 创建虚拟机 + 自动创建数据库记录
func (s *pveVMService) CreateVMInProxmox(ctx context.Context, req *v1.CreateVMRequest) error <span class="cov0" title="0">{
        // 0. 如果未显式传入 VMID，则自动生成一个 8 位数的 VM ID
        vmID := generateProxmoxVMID(req.VMID)
        req.VMID = vmID

        // 0.1 创建模式（默认 template，兼容旧前端不传 create_mode 的情况）
        createMode := strings.ToLower(strings.TrimSpace(req.CreateMode))
        if createMode == "" </span><span class="cov0" title="0">{
                createMode = "template"
        }</span>

        // 1. 获取集群信息（优先使用 ID，如果没有则使用名称）
        <span class="cov0" title="0">var cluster *model.PveCluster
        var err error
        if req.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                cluster, err = s.clusterRepo.GetByID(ctx, req.ClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster by id", zap.Error(err), zap.Int64("cluster_id", req.ClusterID))
                        return v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> if req.ClusterName != "" </span><span class="cov0" title="0">{
                cluster, err = s.clusterRepo.GetByClusterName(ctx, req.ClusterName)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get cluster by name", zap.Error(err))
                        return v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("必须提供 cluster_id 或 cluster_name")
        }</span>

        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                if req.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("集群 ID %d 不存在", req.ClusterID)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("集群 %s 不存在", req.ClusterName)</span>
        }

        // 检查集群是否可调度
        <span class="cov0" title="0">if cluster.IsSchedulable != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("集群 %s 不可调度", cluster.ClusterName)
        }</span>

        // 2. 获取节点信息（优先使用 ID，如果没有则使用名称）
        <span class="cov0" title="0">var node *model.PveNode
        if req.NodeID &gt; 0 </span><span class="cov0" title="0">{
                node, err = s.nodeRepo.GetByID(ctx, req.NodeID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get node by id", zap.Error(err), zap.Int64("node_id", req.NodeID))
                        return v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> if req.NodeName != "" </span><span class="cov0" title="0">{
                node, err = s.nodeRepo.GetByNodeName(ctx, req.NodeName, cluster.Id)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get node by name", zap.Error(err))
                        return v1.ErrInternalServerError
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("必须提供 node_id 或 node_name")
        }</span>

        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                if req.NodeID &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("节点 ID %d 不存在", req.NodeID)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("节点 %s 在集群 %s 中不存在", req.NodeName, cluster.ClusterName)</span>
        }

        // 3. 检查新虚拟机是否已存在（使用 NodeID）
        <span class="cov0" title="0">existing, err := s.vmRepo.GetByVMID(ctx, vmID, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to check vm", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Warn("vm already exists", zap.Uint32("vmid", vmID), zap.Int64("node_id", node.Id))
                return fmt.Errorf("虚拟机 %d 在节点 %s 上已存在", vmID, node.NodeName)
        }</span>

        // 4. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">switch createMode </span>{
        case "template":<span class="cov0" title="0">
                // 5.template 分支：从模板克隆
                if req.TemplateID &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("create_mode=template 时必须提供 template_id")
                }</span>

                // 5.1 获取模板信息
                <span class="cov0" title="0">template, err := s.templateRepo.GetByID(ctx, req.TemplateID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get template", zap.Error(err), zap.Int64("template_id", req.TemplateID))
                        return v1.ErrInternalServerError
                }</span>
                <span class="cov0" title="0">if template == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("模板 %d 不存在", req.TemplateID)
                }</span>

                // 5.2 查找模板实例（优先查找目标节点上的实例，如果没有则查找主实例或其他可用实例）
                <span class="cov0" title="0">var templateInstance *model.TemplateInstance

                // 优先查找目标节点上的模板实例
                instance, err := s.templateInstanceRepo.GetByTemplateAndNode(ctx, template.Id, node.Id)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get template instance", zap.Error(err))
                        return v1.ErrInternalServerError
                }</span>

                <span class="cov0" title="0">if instance != nil &amp;&amp; instance.Status == model.TemplateInstanceStatusAvailable &amp;&amp; instance.VMID &gt; 0 </span><span class="cov0" title="0">{
                        // 目标节点上有可用的模板实例
                        templateInstance = instance
                        s.logger.WithContext(ctx).Info("using template instance on target node",
                                zap.Int64("template_id", template.Id),
                                zap.Int64("node_id", node.Id),
                                zap.Uint32("vmid", instance.VMID))
                }</span> else<span class="cov0" title="0"> {
                        // 目标节点上没有可用实例，查找主实例或其他可用实例
                        primaryInstance, err := s.templateInstanceRepo.GetPrimaryInstance(ctx, template.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to get primary template instance", zap.Error(err))
                                return v1.ErrInternalServerError
                        }</span>
                        <span class="cov0" title="0">if primaryInstance != nil &amp;&amp; primaryInstance.Status == model.TemplateInstanceStatusAvailable &amp;&amp; primaryInstance.VMID &gt; 0 </span><span class="cov0" title="0">{
                                templateInstance = primaryInstance
                                s.logger.WithContext(ctx).Info("using primary template instance",
                                        zap.Int64("template_id", template.Id),
                                        zap.Int64("node_id", primaryInstance.NodeID),
                                        zap.Uint32("vmid", primaryInstance.VMID))
                        }</span> else<span class="cov0" title="0"> {
                                // 查找任何可用的实例
                                allInstances, err := s.templateInstanceRepo.ListByTemplateID(ctx, template.Id)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.WithContext(ctx).Error("failed to list template instances", zap.Error(err))
                                        return v1.ErrInternalServerError
                                }</span>
                                <span class="cov0" title="0">for _, inst := range allInstances </span><span class="cov0" title="0">{
                                        if inst.Status == model.TemplateInstanceStatusAvailable &amp;&amp; inst.VMID &gt; 0 </span><span class="cov0" title="0">{
                                                templateInstance = inst
                                                s.logger.WithContext(ctx).Info("using available template instance",
                                                        zap.Int64("template_id", template.Id),
                                                        zap.Int64("node_id", inst.NodeID),
                                                        zap.Uint32("vmid", inst.VMID))
                                                break</span>
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">if templateInstance == nil || templateInstance.VMID == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("模板 ID %d 没有可用的模板实例", template.Id)
                }</span>

                // 获取模板实例所在的节点
                <span class="cov0" title="0">sourceNode, err := s.nodeRepo.GetByID(ctx, templateInstance.NodeID)
                if err != nil || sourceNode == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("无法获取模板实例的节点信息")
                }</span>
                <span class="cov0" title="0">sourceNodeName := sourceNode.NodeName

                // 5.3 准备克隆请求参数
                fullClone := 1 // 默认完整克隆
                if req.FullClone != nil </span><span class="cov0" title="0">{
                        fullClone = *req.FullClone
                }</span>

                // 如果目标节点和源节点相同，则不设置 target 参数
                <span class="cov0" title="0">var targetNode string
                if node.NodeName != sourceNodeName &amp;&amp; node.NodeName != "" </span><span class="cov0" title="0">{
                        targetNode = node.NodeName
                }</span>

                <span class="cov0" title="0">cloneReq := &amp;proxmox.CloneVMRequest{
                        NewID:       vmID,
                        Name:        req.VmName,
                        Target:      targetNode, // 目标节点（如果不同才设置）
                        Full:        fullClone,
                        Storage:     req.Storage,
                        Description: req.Description,
                }

                // 5.4 调用 Proxmox API 克隆虚拟机
                upid, err := proxmoxClient.CloneVM(ctx, sourceNodeName, templateInstance.VMID, cloneReq)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to clone vm", zap.Error(err),
                                zap.String("template_node", sourceNodeName),
                                zap.Uint32("template_vmid", templateInstance.VMID))
                        return fmt.Errorf("克隆虚拟机失败: %v", err)
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm cloned", zap.String("upid", upid), zap.Uint32("vmid", vmID))

                // 5.5 创建数据库记录
                vm := &amp;model.PveVM{
                        VmName:     req.VmName,
                        ClusterID:  cluster.Id,
                        NodeID:     node.Id,
                        TemplateID: template.Id,
                        VMID:       vmID,
                        Status:     "stopped", // 克隆后默认停止状态
                        CreateTime: time.Now(),
                        UpdateTime: time.Now(),
                }

                // 如果提供了配置，则使用提供的配置，否则使用默认值
                if req.CPUNum != nil </span><span class="cov0" title="0">{
                        vm.CPUNum = *req.CPUNum
                }</span> else<span class="cov0" title="0"> {
                        vm.CPUNum = 2 // 默认 2 核
                }</span>
                <span class="cov0" title="0">if req.MemorySize != nil </span><span class="cov0" title="0">{
                        vm.MemorySize = *req.MemorySize
                }</span> else<span class="cov0" title="0"> {
                        vm.MemorySize = 4096 // 默认 4GB
                }</span>
                <span class="cov0" title="0">if req.Storage != "" </span><span class="cov0" title="0">{
                        vm.Storage = req.Storage
                }</span> else<span class="cov0" title="0"> {
                        vm.Storage = templateInstance.StorageName // 使用模板实例的存储
                }</span>
                <span class="cov0" title="0">if req.StorageCfg != "" </span><span class="cov0" title="0">{
                        vm.StorageCfg = req.StorageCfg
                }</span> else<span class="cov0" title="0"> {
                        vm.StorageCfg = "{}" // 默认空配置
                }</span>
                <span class="cov0" title="0">if req.AppId != "" </span><span class="cov0" title="0">{
                        vm.AppId = req.AppId
                }</span>
                <span class="cov0" title="0">if req.VmUser != "" </span><span class="cov0" title="0">{
                        vm.VmUser = req.VmUser
                }</span>
                <span class="cov0" title="0">if req.VmPassword != "" </span><span class="cov0" title="0">{
                        vm.VmPassword = req.VmPassword
                }</span>
                <span class="cov0" title="0">if node.IPAddress != "" </span><span class="cov0" title="0">{
                        vm.NodeIP = node.IPAddress
                }</span>
                <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                        vm.Description = req.Description
                }</span>

                <span class="cov0" title="0">if err := s.vmRepo.Create(ctx, vm); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create vm record", zap.Error(err))
                        // 注意：如果数据库创建失败，可以考虑回滚 Proxmox 的克隆操作
                        return v1.ErrInternalServerError
                }</span>

                // 10. 如果提供了 IP 地址 ID，创建 IP 地址记录
                <span class="cov0" title="0">if req.IPAddressID != nil </span><span class="cov0" title="0">{
                        ipAddr, err := s.ipRepo.GetByID(ctx, *req.IPAddressID)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to get ip address", zap.Error(err))
                                // IP 地址获取失败不影响虚拟机创建，只记录日志
                        }</span> else<span class="cov0" title="0"> if ipAddr != nil </span><span class="cov0" title="0">{
                                // 更新 IP 地址记录的 VMId 和 ClusterID
                                ipAddr.VMId = vm.Id
                                ipAddr.ClusterID = cluster.Id
                                if err := s.ipRepo.Update(ctx, ipAddr); err != nil </span><span class="cov0" title="0">{
                                        s.logger.WithContext(ctx).Error("failed to update ip address", zap.Error(err))
                                        // IP 地址更新失败不影响虚拟机创建，只记录日志
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>

        case "iso", "empty":<span class="cov0" title="0">
                // 5.iso/empty 分支：创建空机（iso 会额外挂载 ISO 并从光驱启动）
                if req.Storage == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("create_mode=%s 时必须提供 storage", createMode)
                }</span>

                // 默认值
                <span class="cov0" title="0">cpu := 2
                if req.CPUNum != nil &amp;&amp; *req.CPUNum &gt; 0 </span><span class="cov0" title="0">{
                        cpu = *req.CPUNum
                }</span>
                <span class="cov0" title="0">mem := 2048
                if req.MemorySize != nil &amp;&amp; *req.MemorySize &gt; 0 </span><span class="cov0" title="0">{
                        mem = *req.MemorySize
                }</span>
                <span class="cov0" title="0">diskGB := 32
                if req.DiskSizeGB != nil &amp;&amp; *req.DiskSizeGB &gt; 0 </span><span class="cov0" title="0">{
                        diskGB = *req.DiskSizeGB
                }</span>
                <span class="cov0" title="0">bridge := "vmbr0"
                if strings.TrimSpace(req.Bridge) != "" </span><span class="cov0" title="0">{
                        bridge = strings.TrimSpace(req.Bridge)
                }</span>
                <span class="cov0" title="0">netModel := "virtio"
                if strings.TrimSpace(req.NetModel) != "" </span><span class="cov0" title="0">{
                        netModel = strings.TrimSpace(req.NetModel)
                }</span>
                <span class="cov0" title="0">ostype := "l26"
                if strings.TrimSpace(req.OSType) != "" </span><span class="cov0" title="0">{
                        ostype = strings.TrimSpace(req.OSType)
                }</span>

                // iso 模式必须提供 iso_volume
                <span class="cov0" title="0">isoVol := strings.TrimSpace(req.ISOVolume)
                if createMode == "iso" </span><span class="cov0" title="0">{
                        if isoVol == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("create_mode=iso 时必须提供 iso_volume")
                        }</span>
                        // 兼容前端可能传入以 / 开头的 volume
                        <span class="cov0" title="0">isoVol = strings.TrimPrefix(isoVol, "/")</span>
                }

                // 组装 Proxmox 创建参数（form）
                <span class="cov0" title="0">params := url.Values{}
                params.Set("vmid", fmt.Sprintf("%d", vmID))
                params.Set("name", req.VmName)
                params.Set("cores", fmt.Sprintf("%d", cpu))
                params.Set("memory", fmt.Sprintf("%d", mem))
                params.Set("sockets", "1")
                params.Set("ostype", ostype)
                params.Set("scsihw", "virtio-scsi-pci")
                params.Set("agent", "1")

                // 系统盘：scsi0=&lt;storage&gt;:&lt;sizeGB&gt;[,format=xxx]
                disk := fmt.Sprintf("%s:%d", req.Storage, diskGB)
                if strings.TrimSpace(req.DiskFormat) != "" </span><span class="cov0" title="0">{
                        // 注意：某些后端存储（如 lvmthin/zfs）不支持 qcow2，若报错请前端不传 disk_format
                        disk += fmt.Sprintf(",format=%s", strings.TrimSpace(req.DiskFormat))
                }</span>
                <span class="cov0" title="0">params.Set("scsi0", disk)

                // 网卡：net0=&lt;model&gt;,bridge=&lt;bridge&gt;
                params.Set("net0", fmt.Sprintf("%s,bridge=%s", netModel, bridge))

                // ISO 挂载与启动顺序
                if createMode == "iso" </span><span class="cov0" title="0">{
                        params.Set("ide2", fmt.Sprintf("%s,media=cdrom", isoVol))
                        params.Set("boot", "order=ide2;scsi0;net0")
                }</span> else<span class="cov0" title="0"> {
                        params.Set("boot", "order=scsi0;net0")
                }</span>

                <span class="cov0" title="0">if strings.TrimSpace(req.Description) != "" </span><span class="cov0" title="0">{
                        params.Set("description", strings.TrimSpace(req.Description))
                }</span>

                <span class="cov0" title="0">upid, err := proxmoxClient.CreateQemuVM(ctx, node.NodeName, params)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create qemu vm", zap.Error(err),
                                zap.String("node", node.NodeName),
                                zap.Uint32("vmid", vmID),
                                zap.String("create_mode", createMode))
                        return fmt.Errorf("创建虚拟机失败: %v", err)
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm created", zap.String("upid", upid), zap.Uint32("vmid", vmID), zap.String("create_mode", createMode))

                // 记录创建信息到 storage_cfg（若前端未显式传入）
                storageCfg := req.StorageCfg
                if strings.TrimSpace(storageCfg) == "" </span><span class="cov0" title="0">{
                        cfg := map[string]interface{}{
                                "create_mode":  createMode,
                                "disk_size_gb": diskGB,
                                "storage":      req.Storage,
                                "bridge":       bridge,
                                "net_model":    netModel,
                                "os_type":      ostype,
                        }
                        if createMode == "iso" </span><span class="cov0" title="0">{
                                cfg["iso_volume"] = isoVol
                        }</span>
                        <span class="cov0" title="0">if b, err := json.Marshal(cfg); err == nil </span><span class="cov0" title="0">{
                                storageCfg = string(b)
                        }</span>
                }

                // 创建数据库记录（TemplateID=0 表示非模板克隆创建）
                <span class="cov0" title="0">vm := &amp;model.PveVM{
                        VmName:     req.VmName,
                        ClusterID:  cluster.Id,
                        NodeID:     node.Id,
                        TemplateID: 0,
                        VMID:       vmID,
                        CPUNum:     cpu,
                        MemorySize: mem,
                        Storage:    req.Storage,
                        StorageCfg: storageCfg,
                        Status:     "stopped",
                        AppId:      req.AppId,
                        VmUser:     req.VmUser,
                        VmPassword: req.VmPassword,
                        CreateTime: time.Now(),
                        UpdateTime: time.Now(),
                }
                if node.IPAddress != "" </span><span class="cov0" title="0">{
                        vm.NodeIP = node.IPAddress
                }</span>
                <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                        vm.Description = req.Description
                }</span>

                <span class="cov0" title="0">if err := s.vmRepo.Create(ctx, vm); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create vm record", zap.Error(err))
                        return v1.ErrInternalServerError
                }</span>

                // IP 地址绑定（可选）
                <span class="cov0" title="0">if req.IPAddressID != nil </span><span class="cov0" title="0">{
                        ipAddr, err := s.ipRepo.GetByID(ctx, *req.IPAddressID)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to get ip address", zap.Error(err))
                        }</span> else<span class="cov0" title="0"> if ipAddr != nil </span><span class="cov0" title="0">{
                                ipAddr.VMId = vm.Id
                                ipAddr.ClusterID = cluster.Id
                                if err := s.ipRepo.Update(ctx, ipAddr); err != nil </span><span class="cov0" title="0">{
                                        s.logger.WithContext(ctx).Error("failed to update ip address", zap.Error(err))
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>

        default:<span class="cov0" title="0">
                s.logger.WithContext(ctx).Warn("invalid create mode", zap.String("create_mode", createMode))
                return v1.ErrInvalidCreateMode</span> //nolint:stylecheck,staticcheck // false-positive in editor diagnostics
        }
}

func (s *pveVMService) UpdateVM(ctx context.Context, id int64, req *v1.UpdateVMRequest) error <span class="cov0" title="0">{
        vm, err := s.vmRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.VmName != nil </span><span class="cov0" title="0">{
                vm.VmName = *req.VmName
        }</span>
        <span class="cov0" title="0">if req.CPUNum != nil </span><span class="cov0" title="0">{
                vm.CPUNum = *req.CPUNum
        }</span>
        <span class="cov0" title="0">if req.MemorySize != nil </span><span class="cov0" title="0">{
                vm.MemorySize = *req.MemorySize
        }</span>
        <span class="cov0" title="0">if req.Storage != nil </span><span class="cov0" title="0">{
                vm.Storage = *req.Storage
        }</span>
        <span class="cov0" title="0">if req.StorageCfg != nil </span><span class="cov0" title="0">{
                vm.StorageCfg = *req.StorageCfg
        }</span>
        <span class="cov0" title="0">if req.AppId != nil </span><span class="cov0" title="0">{
                vm.AppId = *req.AppId
        }</span>
        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                vm.Status = *req.Status
        }</span>
        <span class="cov0" title="0">if req.TemplateName != nil </span><span class="cov0" title="0">{
                vm.TemplateName = *req.TemplateName
        }</span>
        <span class="cov0" title="0">if req.VmUser != nil </span><span class="cov0" title="0">{
                vm.VmUser = *req.VmUser
        }</span>
        <span class="cov0" title="0">if req.VmPassword != nil </span><span class="cov0" title="0">{
                vm.VmPassword = *req.VmPassword
        }</span>
        <span class="cov0" title="0">if req.NodeIP != nil </span><span class="cov0" title="0">{
                vm.NodeIP = *req.NodeIP
        }</span>
        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                vm.Description = *req.Description
        }</span>
        <span class="cov0" title="0">vm.UpdateTime = time.Now()

        if err := s.vmRepo.Update(ctx, vm); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update vm", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveVMService) DeleteVM(ctx context.Context, id int64) error <span class="cov0" title="0">{
        // 1. 获取虚拟机信息
        vm, err := s.vmRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 2. 基于数据库状态进行前置校验，要求先在上层手动停止
        <span class="cov0" title="0">if vm.Status == "offline" || vm.Status == "orphan" </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机已经销毁，请勿重复销毁")
        }</span>
        <span class="cov0" title="0">if vm.Status != "stopped" </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机未停止，请先停止虚拟机")
        }</span>

        // 3. 获取集群信息（通过 ID）
        <span class="cov0" title="0">if vm.ClusterID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机的集群 ID 无效，无法删除 Proxmox 虚拟机")
        }</span>
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, vm.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("集群 ID %d 不存在，无法删除 Proxmox 虚拟机", vm.ClusterID)
        }</span>

        // 4. 获取节点信息（通过 ID）
        <span class="cov0" title="0">if vm.NodeID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机的节点 ID 无效，无法删除 Proxmox 虚拟机")
        }</span>
        <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, vm.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("节点 ID %d 不存在，无法删除 Proxmox 虚拟机", vm.NodeID)
        }</span>

        // 5. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return fmt.Errorf("创建 Proxmox 客户端失败: %v", err)
        }</span>

        // 6. 先获取虚拟机配置，检查虚拟机是否存在
        <span class="cov0" title="0">vmExistsInProxmox := true
        _, err = proxmoxClient.GetVMConfig(ctx, node.NodeName, vm.VMID)
        if err != nil </span><span class="cov0" title="0">{
                // 检查错误是否是 404/500（虚拟机不存在或已删除）
                errStr := err.Error()
                if strings.Contains(errStr, "status 404") || strings.Contains(errStr, "status 500") </span><span class="cov0" title="0">{
                        // 如果虚拟机已经不存在（404）或返回 500（可能是已删除），直接删除数据库记录
                        s.logger.WithContext(ctx).Warn("vm not found in proxmox or already deleted, will delete database record only", zap.Error(err),
                                zap.String("node", node.NodeName),
                                zap.Uint32("vmid", vm.VMID))
                        vmExistsInProxmox = false
                }</span> else<span class="cov0" title="0"> {
                        s.logger.WithContext(ctx).Error("failed to get vm config from proxmox", zap.Error(err),
                                zap.String("node", node.NodeName),
                                zap.Uint32("vmid", vm.VMID))
                        return fmt.Errorf("从 Proxmox 获取虚拟机配置失败: %v", err)
                }</span>
        }

        <span class="cov0" title="0">var vmStatus string
        if vmExistsInProxmox </span><span class="cov0" title="0">{
                // 7. 从 Proxmox 获取虚拟机的实际状态，并最多重试 3 次确认为 stopped
                for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                        statusData, err := proxmoxClient.GetVMStatus(ctx, node.NodeName, vm.VMID)
                        if err != nil </span><span class="cov0" title="0">{
                                // 检查错误是否是 404/500（虚拟机不存在或已删除）
                                errStr := err.Error()
                                if strings.Contains(errStr, "status 404") || strings.Contains(errStr, "status 500") </span><span class="cov0" title="0">{
                                        s.logger.WithContext(ctx).Warn("vm not found in proxmox when getting status, will delete database record only", zap.Error(err),
                                                zap.String("node", node.NodeName),
                                                zap.Uint32("vmid", vm.VMID))
                                        vmExistsInProxmox = false
                                        break</span>
                                }
                                <span class="cov0" title="0">s.logger.WithContext(ctx).Error("failed to get vm status from proxmox", zap.Error(err),
                                        zap.String("node", node.NodeName),
                                        zap.Uint32("vmid", vm.VMID))
                                return fmt.Errorf("从 Proxmox 获取虚拟机状态失败: %v", err)</span>
                        }

                        // 从返回的 map 中提取 status 字段
                        <span class="cov0" title="0">if status, ok := statusData["status"].(string); ok </span><span class="cov0" title="0">{
                                vmStatus = status
                                s.logger.WithContext(ctx).Info("get proxmox vm status before delete", zap.Uint32("vmid", vm.VMID), zap.String("status", vmStatus), zap.Any("statusData", statusData))
                                if vmStatus == "stopped" </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        } else<span class="cov0" title="0"> {
                                s.logger.WithContext(ctx).Warn("vm status field not found in response", zap.Any("statusData", statusData))
                        }</span>

                        <span class="cov0" title="0">if i &lt; 2 </span><span class="cov0" title="0">{
                                time.Sleep(2 * time.Second)
                        }</span>
                }

                <span class="cov0" title="0">if vmExistsInProxmox &amp;&amp; vmStatus != "stopped" </span><span class="cov0" title="0">{
                        return fmt.Errorf("proxmox 虚拟机当前状态为 %s，无法执行销毁操作，请先在 PVE 中停止虚拟机", vmStatus)
                }</span>

                // 8. 调用 Proxmox API 删除虚拟机（purge=true 表示完全删除，包括磁盘）
                <span class="cov0" title="0">if vmExistsInProxmox </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Info("deleting vm from proxmox", zap.Uint32("vmid", vm.VMID), zap.String("node", node.NodeName))
                        if err := proxmoxClient.DeleteVM(ctx, node.NodeName, vm.VMID, true); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to delete vm from proxmox", zap.Error(err),
                                        zap.String("node", node.NodeName),
                                        zap.Uint32("vmid", vm.VMID),
                                        zap.String("vm_name", vm.VmName),
                                        zap.String("vm_status", vmStatus))
                                return fmt.Errorf("从 Proxmox 删除虚拟机失败: %v", err)
                        }</span>
                        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm deleted from proxmox", zap.Uint32("vmid", vm.VMID))</span>
                }
        }

        // 删除 IP 地址记录
        <span class="cov0" title="0">if err := s.ipRepo.DeleteByVMID(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete ip addresses", zap.Error(err))
                // IP 地址删除失败不影响虚拟机删除，只记录日志
        }</span>

        // 8. 删除数据库记录
        <span class="cov0" title="0">if err := s.vmRepo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete vm record", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *pveVMService) GetVM(ctx context.Context, id int64) (*v1.VMDetail, error) <span class="cov0" title="0">{
        vm, err := s.vmRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        <span class="cov0" title="0">detail := &amp;v1.VMDetail{
                Id:          vm.Id,
                VmName:      vm.VmName,
                ClusterID:   vm.ClusterID,
                NodeID:      vm.NodeID,
                TemplateID:  vm.TemplateID,
                IsTemplate:  vm.IsTemplate,
                VMID:        vm.VMID,
                CPUNum:      vm.CPUNum,
                MemorySize:  vm.MemorySize,
                Storage:     vm.Storage,
                StorageCfg:  vm.StorageCfg,
                AppId:       vm.AppId,
                Status:      vm.Status,
                VmUser:      vm.VmUser,
                NodeIP:      vm.NodeIP,
                Description: vm.Description,
                CreateTime:  vm.CreateTime,
                UpdateTime:  vm.UpdateTime,
                Creator:     vm.Creator,
                Modifier:    vm.Modifier,
        }

        // 填充名称字段
        if vm.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                cluster, _ := s.clusterRepo.GetByID(ctx, vm.ClusterID)
                if cluster != nil </span><span class="cov0" title="0">{
                        detail.ClusterName = cluster.ClusterName
                }</span>
        }
        <span class="cov0" title="0">if vm.NodeID &gt; 0 </span><span class="cov0" title="0">{
                node, _ := s.nodeRepo.GetByID(ctx, vm.NodeID)
                if node != nil </span><span class="cov0" title="0">{
                        detail.NodeName = node.NodeName
                }</span>
        }
        <span class="cov0" title="0">if vm.TemplateID &gt; 0 </span><span class="cov0" title="0">{
                template, _ := s.templateRepo.GetByID(ctx, vm.TemplateID)
                if template != nil </span><span class="cov0" title="0">{
                        detail.TemplateName = template.TemplateName
                }</span>
        }

        <span class="cov0" title="0">return detail, nil</span>
}

func (s *pveVMService) ListVMs(ctx context.Context, req *v1.ListVMRequest) (*v1.ListVMResponseData, error) <span class="cov0" title="0">{
        vms, total, err := s.vmRepo.ListWithPagination(ctx, req.Page, req.PageSize, req.ClusterID, req.ClusterName, req.NodeID, req.NodeName, req.TemplateID, req.Status, req.AppId)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list vms", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 提取所有需要查询的 ID 用于批量填充名称
        <span class="cov0" title="0">clusterIDs := make([]int64, 0)
        nodeIDs := make([]int64, 0)
        templateIDs := make([]int64, 0)

        for _, vm := range vms </span><span class="cov0" title="0">{
                if vm.ClusterID &gt; 0 </span><span class="cov0" title="0">{
                        clusterIDs = append(clusterIDs, vm.ClusterID)
                }</span>
                <span class="cov0" title="0">if vm.NodeID &gt; 0 </span><span class="cov0" title="0">{
                        nodeIDs = append(nodeIDs, vm.NodeID)
                }</span>
                <span class="cov0" title="0">if vm.TemplateID &gt; 0 </span><span class="cov0" title="0">{
                        templateIDs = append(templateIDs, vm.TemplateID)
                }</span>
        }

        // 批量查询关联数据
        <span class="cov0" title="0">clusterMap, _ := s.clusterRepo.GetByIDs(ctx, clusterIDs)
        nodeMap, _ := s.nodeRepo.GetByIDs(ctx, nodeIDs)
        templateMap, _ := s.templateRepo.GetByIDs(ctx, templateIDs)

        items := make([]v1.VMItem, 0, len(vms))
        for _, vm := range vms </span><span class="cov0" title="0">{
                item := v1.VMItem{
                        Id:         vm.Id,
                        VmName:     vm.VmName,
                        ClusterID:  vm.ClusterID,
                        NodeID:     vm.NodeID,
                        TemplateID: vm.TemplateID,
                        IsTemplate: vm.IsTemplate,
                        VMID:       vm.VMID,
                        CPUNum:     vm.CPUNum,
                        MemorySize: vm.MemorySize,
                        Status:     vm.Status,
                        AppId:      vm.AppId,
                        NodeIP:     vm.NodeIP,
                }

                // 从 map 中填充名称
                if cluster, ok := clusterMap[vm.ClusterID]; ok </span><span class="cov0" title="0">{
                        item.ClusterName = cluster.ClusterName
                }</span>
                <span class="cov0" title="0">if node, ok := nodeMap[vm.NodeID]; ok </span><span class="cov0" title="0">{
                        item.NodeName = node.NodeName
                }</span>
                <span class="cov0" title="0">if template, ok := templateMap[vm.TemplateID]; ok </span><span class="cov0" title="0">{
                        item.TemplateName = template.TemplateName
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return &amp;v1.ListVMResponseData{
                Total: total,
                List:  items,
        }, nil</span>
}

func (s *pveVMService) StartVM(ctx context.Context, id int64) error <span class="cov0" title="0">{
        // 1. 获取虚拟机信息
        vm, err := s.vmRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 2. 检查虚拟机当前状态
        <span class="cov0" title="0">if vm.Status == "running" </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机已在运行中，无需启动")
        }</span>

        // 3. 获取集群信息（通过 ID）
        <span class="cov0" title="0">if vm.ClusterID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机的集群 ID 无效")
        }</span>
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, vm.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("集群 ID %d 不存在", vm.ClusterID)
        }</span>

        // 4. 获取节点信息（通过 ID）
        <span class="cov0" title="0">if vm.NodeID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机的节点 ID 无效")
        }</span>
        <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, vm.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("节点 ID %d 不存在", vm.NodeID)
        }</span>

        // 5. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return fmt.Errorf("创建 Proxmox 客户端失败: %v", err)
        }</span>

        // 6. 调用 Proxmox API 启动虚拟机
        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("starting vm from proxmox", zap.Uint32("vmid", vm.VMID), zap.String("node", node.NodeName))
        upid, err := proxmoxClient.StartVM(ctx, node.NodeName, vm.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to start vm from proxmox", zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Uint32("vmid", vm.VMID),
                        zap.String("vm_name", vm.VmName))
                return fmt.Errorf("从 Proxmox 启动虚拟机失败: %v", err)
        }</span>
        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm started from proxmox", zap.Uint32("vmid", vm.VMID), zap.String("upid", upid))

        return nil</span>
}

func (s *pveVMService) StopVM(ctx context.Context, id int64) error <span class="cov0" title="0">{
        // 1. 获取虚拟机信息
        vm, err := s.vmRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 2. 检查虚拟机当前状态
        <span class="cov0" title="0">if vm.Status == "stopped" </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机已停止，无需关机")
        }</span>

        // 3. 获取集群信息（通过 ID）
        <span class="cov0" title="0">if vm.ClusterID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机的集群 ID 无效")
        }</span>
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, vm.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("集群 ID %d 不存在", vm.ClusterID)
        }</span>

        // 4. 获取节点信息（通过 ID）
        <span class="cov0" title="0">if vm.NodeID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("虚拟机的节点 ID 无效")
        }</span>
        <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, vm.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("节点 ID %d 不存在", vm.NodeID)
        }</span>

        // 5. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return fmt.Errorf("创建 Proxmox 客户端失败: %v", err)
        }</span>

        // 6. 调用 Proxmox API 停止虚拟机
        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("stopping vm from proxmox", zap.Uint32("vmid", vm.VMID), zap.String("node", node.NodeName))
        upid, err := proxmoxClient.StopVM(ctx, node.NodeName, vm.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to stop vm from proxmox", zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Uint32("vmid", vm.VMID),
                        zap.String("vm_name", vm.VmName))
                return fmt.Errorf("从 Proxmox 停止虚拟机失败: %v", err)
        }</span>
        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm stopped from proxmox", zap.Uint32("vmid", vm.VMID), zap.String("upid", upid))

        return nil</span>
}

// getProxmoxClientForVM 根据虚拟机ID获取ProxmoxClient和节点信息
func (s *pveVMService) getProxmoxClientForVM(ctx context.Context, vmID int64) (*proxmox.ProxmoxClient, *model.PveNode, error) <span class="cov0" title="0">{
        // 1. 获取虚拟机信息
        vm, err := s.vmRepo.GetByID(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return nil, nil, v1.ErrNotFound
        }</span>

        // 2. 获取集群信息
        <span class="cov0" title="0">if vm.ClusterID &lt;= 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("虚拟机的集群 ID 无效")
        }</span>
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, vm.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("集群 ID %d 不存在", vm.ClusterID)
        }</span>

        // 3. 获取节点信息
        <span class="cov0" title="0">if vm.NodeID &lt;= 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("虚拟机的节点 ID 无效")
        }</span>
        <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, vm.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("节点 ID %d 不存在", vm.NodeID)
        }</span>

        // 4. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return proxmoxClient, node, nil</span>
}

// getProxmoxClientForNode 根据节点ID获取ProxmoxClient和节点信息
func (s *pveVMService) getProxmoxClientForNode(ctx context.Context, nodeID int64) (*proxmox.ProxmoxClient, error) <span class="cov0" title="0">{
        // 1. 获取节点信息
        node, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("节点 ID %d 不存在", nodeID)
        }</span>

        // 2. 获取集群信息
        <span class="cov0" title="0">if node.ClusterID &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("节点的集群 ID 无效")
        }</span>
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, node.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("集群 ID %d 不存在", node.ClusterID)
        }</span>

        // 3. 创建 Proxmox 客户端
        <span class="cov0" title="0">proxmoxClient, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return proxmoxClient, nil</span>
}

func (s *pveVMService) GetVMCurrentConfig(ctx context.Context, vmID int64) (map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForVM(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">vm, err := s.vmRepo.GetByID(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">config, err := client.GetVMCurrentConfig(ctx, node.NodeName, vm.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm current config", zap.Error(err),
                        zap.String("node", node.NodeName), zap.Uint32("vmid", vm.VMID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

func (s *pveVMService) GetVMPendingConfig(ctx context.Context, vmID int64) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForVM(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">vm, err := s.vmRepo.GetByID(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">config, err := client.GetVMPendingConfig(ctx, node.NodeName, vm.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm pending config", zap.Error(err),
                        zap.String("node", node.NodeName), zap.Uint32("vmid", vm.VMID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

func (s *pveVMService) UpdateVMConfig(ctx context.Context, req *v1.UpdateVMConfigRequest) error <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForVM(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">vm, err := s.vmRepo.GetByID(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">if err := client.UpdateVMConfig(ctx, node.NodeName, vm.VMID, req.Config); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update vm config", zap.Error(err),
                        zap.String("node", node.NodeName), zap.Uint32("vmid", vm.VMID))
                return v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm config updated", zap.Uint32("vmid", vm.VMID), zap.String("node", node.NodeName))
        return nil</span>
}

func (s *pveVMService) GetVMStatus(ctx context.Context, vmID int64) (map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForVM(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">vm, err := s.vmRepo.GetByID(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">status, err := client.GetVMStatus(ctx, node.NodeName, vm.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm status", zap.Error(err),
                        zap.String("node", node.NodeName), zap.Uint32("vmid", vm.VMID))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

func (s *pveVMService) GetVMConsole(ctx context.Context, req *v1.GetVMConsoleRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForVM(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">vm, err := s.vmRepo.GetByID(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // noVNC 需要 vncproxy 的 port/ticket 再去连 vncwebsocket；这里默认强制开启 websocket=1
        // 避免前端未传 websocket 导致返回字段不全（port/ticket 缺失）
        <span class="cov0" title="0">result, err := client.QemuVNCProxy(ctx, node.NodeName, vm.VMID, true, req.GeneratePassword)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm vncproxy", zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Uint32("vmid", vm.VMID))
                return nil, v1.ErrInternalServerError
        }</span>

        // vncproxy 返回 data 通常包含 port(int) 和 ticket(string)
        <span class="cov0" title="0">var port int
        switch v := result["port"].(type) </span>{
        case float64:<span class="cov0" title="0">
                port = int(v)</span>
        case int:<span class="cov0" title="0">
                port = v</span>
        case int64:<span class="cov0" title="0">
                port = int(v)</span>
        case json.Number:<span class="cov0" title="0">
                if p, err := v.Int64(); err == nil </span><span class="cov0" title="0">{
                        port = int(p)
                }</span>
        case string:<span class="cov0" title="0">
                if p, err := strconv.Atoi(strings.TrimSpace(v)); err == nil </span><span class="cov0" title="0">{
                        port = p
                }</span>
        }
        <span class="cov0" title="0">ticket, _ := result["ticket"].(string)
        if port &lt;= 0 || strings.TrimSpace(ticket) == "" </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Warn("vncproxy response missing port/ticket", zap.Any("data", result))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">token, err := newConsoleToken()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to generate console token", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">exp := time.Now().Add(2 * time.Minute)
        s.consoleSessions.Store(token, vmConsoleSession{
                VMID:      req.VMID,
                Port:      port,
                Ticket:    ticket,
                ExpiresAt: exp,
        })
        result["ws_token"] = token
        result["ws_expires_at"] = exp.Unix()

        return result, nil</span>
}

// DialVMConsoleWebsocket 通过 ws_token 建立到 Proxmox vncwebsocket 的连接（单次使用/短期有效）
func (s *pveVMService) DialVMConsoleWebsocket(ctx context.Context, token string) (*websocket.Conn, error) <span class="cov0" title="0">{
        if strings.TrimSpace(token) == "" </span><span class="cov0" title="0">{
                return nil, v1.ErrBadRequest
        }</span>

        <span class="cov0" title="0">val, ok := s.consoleSessions.LoadAndDelete(token)
        if !ok </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>
        <span class="cov0" title="0">session, ok := val.(vmConsoleSession)
        if !ok </span><span class="cov0" title="0">{
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if time.Now().After(session.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, v1.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">client, node, err := s.getProxmoxClientForVM(ctx, session.VMID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">params := url.Values{}
        params.Set("port", fmt.Sprintf("%d", session.Port))
        params.Set("vncticket", session.Ticket)

        // 获取虚拟机信息以得到实际的 VMID
        vm, err := s.vmRepo.GetByID(ctx, session.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm for websocket", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/nodes/%s/qemu/%d/vncwebsocket", node.NodeName, vm.VMID)
        conn, _, err := client.WebSocket(path, params.Encode())
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to dial proxmox vncwebsocket", zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Uint32("vmid", vm.VMID))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

func (s *pveVMService) GetVMRRDData(ctx context.Context, vmID int64, timeframe, cf string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        client, node, err := s.getProxmoxClientForVM(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">vm, err := s.vmRepo.GetByID(ctx, vmID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">rrdData, err := client.GetVMRRDData(ctx, node.NodeName, vm.VMID, timeframe, cf)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm rrd data", zap.Error(err),
                        zap.String("node", node.NodeName), zap.Uint32("vmid", vm.VMID),
                        zap.String("timeframe", timeframe), zap.String("cf", cf))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return rrdData, nil</span>
}

func (s *pveVMService) MigrateVM(ctx context.Context, req *v1.MigrateVMRequest) (string, error) <span class="cov0" title="0">{
        // 1. 获取源虚拟机信息
        vm, err := s.vmRepo.GetByID(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm", zap.Error(err))
                return "", v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return "", v1.ErrNotFound
        }</span>

        // 2. 获取源集群和节点信息
        <span class="cov0" title="0">client, sourceNode, err := s.getProxmoxClientForVM(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 3. 获取目标节点信息（必须在同一集群内）
        <span class="cov0" title="0">targetNode, err := s.nodeRepo.GetByID(ctx, req.TargetNodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get target node", zap.Error(err))
                return "", v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if targetNode == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("目标节点 ID %d 不存在", req.TargetNodeID)
        }</span>

        // 验证目标节点是否在同一集群
        <span class="cov0" title="0">if targetNode.ClusterID != vm.ClusterID </span><span class="cov0" title="0">{
                return "", fmt.Errorf("目标节点不在同一集群内，请使用远程迁移接口")
        }</span>

        // 4. 构建迁移参数
        <span class="cov0" title="0">params := make(map[string]interface{})
        params["target"] = targetNode.NodeName

        if req.Online != nil </span><span class="cov0" title="0">{
                params["online"] = *req.Online
        }</span>
        <span class="cov0" title="0">if req.Bwlimit != nil </span><span class="cov0" title="0">{
                params["bwlimit"] = *req.Bwlimit
        }</span>
        <span class="cov0" title="0">if req.WithLocalDisks != nil </span><span class="cov0" title="0">{
                params["with-local-disks"] = *req.WithLocalDisks
        }</span>
        // 注意：migration-type 参数在某些 Proxmox 版本中可能不支持，暂时移除
        // if req.MigrationType != "" {
        //         params["migration-type"] = req.MigrationType
        // }
        <span class="cov0" title="0">if req.MigrationNetwork != "" </span><span class="cov0" title="0">{
                params["migration-network"] = req.MigrationNetwork
        }</span>
        <span class="cov0" title="0">if req.MapStorage != "" </span><span class="cov0" title="0">{
                params["map-storage"] = req.MapStorage
        }</span>

        // 5. 调用 Proxmox API 执行迁移
        <span class="cov0" title="0">upid, err := client.MigrateVM(ctx, sourceNode.NodeName, vm.VMID, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to migrate vm", zap.Error(err),
                        zap.String("source_node", sourceNode.NodeName),
                        zap.String("target_node", targetNode.NodeName),
                        zap.Uint32("vmid", vm.VMID))
                return "", v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm migration started", zap.Uint32("vmid", vm.VMID),
                zap.String("source_node", sourceNode.NodeName),
                zap.String("target_node", targetNode.NodeName),
                zap.String("upid", upid))

        return upid, nil</span>
}

func (s *pveVMService) RemoteMigrateVM(ctx context.Context, req *v1.RemoteMigrateVMRequest) (string, error) <span class="cov0" title="0">{
        // 1. 获取源虚拟机信息
        vm, err := s.vmRepo.GetByID(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm", zap.Error(err))
                return "", v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return "", v1.ErrNotFound
        }</span>

        // 2. 获取源集群和节点信息
        <span class="cov0" title="0">client, sourceNode, err := s.getProxmoxClientForVM(ctx, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 3. 获取目标集群信息
        <span class="cov0" title="0">targetCluster, err := s.clusterRepo.GetByID(ctx, req.TargetClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get target cluster", zap.Error(err))
                return "", v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if targetCluster == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("目标集群 ID %d 不存在", req.TargetClusterID)
        }</span>

        // 4. 获取目标节点信息
        <span class="cov0" title="0">targetNode, err := s.nodeRepo.GetByID(ctx, req.TargetNodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get target node", zap.Error(err))
                return "", v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if targetNode == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("目标节点 ID %d 不存在", req.TargetNodeID)
        }</span>

        // 验证目标节点是否在目标集群内
        <span class="cov0" title="0">if targetNode.ClusterID != req.TargetClusterID </span><span class="cov0" title="0">{
                return "", fmt.Errorf("目标节点不在指定的目标集群内")
        }</span>

        // 5. 获取目标集群的 fingerprint
        // 创建目标集群的客户端来获取证书信息
        <span class="cov0" title="0">targetClient, err := proxmox.NewProxmoxClient(targetCluster.ApiUrl, targetCluster.UserId, targetCluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create target cluster client", zap.Error(err))
                return "", v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">var fingerprint string
        certificates, err := targetClient.GetNodeCertificatesInfo(ctx, targetNode.NodeName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Warn("failed to get target node certificates info, will proceed without fingerprint", zap.Error(err))
                // 如果获取失败，继续执行但不使用 fingerprint
        }</span> else<span class="cov0" title="0"> {
                // 查找 filename == "pve-ssl.pem" 的证书的 fingerprint（不要使用 pve-root-ca.pem）
                for _, cert := range certificates </span><span class="cov0" title="0">{
                        if filename, ok := cert["filename"].(string); ok &amp;&amp; filename == "pve-ssl.pem" </span><span class="cov0" title="0">{
                                if fp, ok := cert["fingerprint"].(string); ok &amp;&amp; fp != "" </span><span class="cov0" title="0">{
                                        fingerprint = fp
                                        s.logger.WithContext(ctx).Info("found pve-ssl.pem fingerprint",
                                                zap.String("fingerprint", fingerprint))
                                        break</span>
                                }
                        }
                }
                <span class="cov0" title="0">if fingerprint == "" </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("pve-ssl.pem certificate not found, will proceed without fingerprint",
                                zap.Int("cert_count", len(certificates)))
                }</span>
        }

        // 6. 构建 target-endpoint
        // 格式：host=&lt;TARGET_IP&gt;,apitoken=&lt;API_TOKEN&gt;[,port=&lt;PORT&gt;][,fingerprint=&lt;FINGERPRINT&gt;]
        // API_TOKEN 格式：PVEAPIToken=&lt;UserId&gt;=&lt;UserToken&gt;
        <span class="cov0" title="0">apiToken := fmt.Sprintf("PVEAPIToken=%s=%s", targetCluster.UserId, targetCluster.UserToken)

        // 从 ApiUrl 中提取 host 和 port
        targetURL, err := url.Parse(targetCluster.ApiUrl)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to parse target cluster api url", zap.Error(err))
                return "", fmt.Errorf("目标集群 API URL 格式错误")
        }</span>

        <span class="cov0" title="0">targetHost := targetURL.Hostname()
        targetPort := targetURL.Port()
        if targetPort == "" </span><span class="cov0" title="0">{
                // 默认端口
                if targetURL.Scheme == "https" </span><span class="cov0" title="0">{
                        targetPort = "8006"
                }</span> else<span class="cov0" title="0"> {
                        targetPort = "8006"
                }</span>
        }

        // 构建 target-endpoint，格式：host=&lt;HOST&gt;,apitoken=&lt;TOKEN&gt;[,fingerprint=&lt;FINGERPRINT&gt;],port=&lt;PORT&gt;
        // 注意：参数顺序可能重要，按照 Proxmox 文档格式
        <span class="cov0" title="0">targetEndpoint := fmt.Sprintf("host=%s,apitoken=%s", targetHost, apiToken)
        if fingerprint != "" </span><span class="cov0" title="0">{
                targetEndpoint += fmt.Sprintf(",fingerprint=%s", fingerprint)
        }</span>
        <span class="cov0" title="0">targetEndpoint += fmt.Sprintf(",port=%s", targetPort)

        // 7. 构建迁移参数
        params := make(map[string]interface{})
        params["target-endpoint"] = targetEndpoint
        params["target-bridge"] = req.TargetBridge
        params["target-storage"] = req.TargetStorage

        // 可选参数
        if req.TargetVMID != nil </span><span class="cov0" title="0">{
                params["target-vmid"] = *req.TargetVMID
        }</span>
        <span class="cov0" title="0">if req.Online != nil </span><span class="cov0" title="0">{
                params["online"] = *req.Online
        }</span>
        <span class="cov0" title="0">if req.Bwlimit != nil </span><span class="cov0" title="0">{
                params["bwlimit"] = *req.Bwlimit
        }</span>
        <span class="cov0" title="0">if req.Delete != nil </span><span class="cov0" title="0">{
                params["delete"] = *req.Delete
        }</span>

        // 记录迁移参数（不记录敏感信息）
        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("remote migrate vm params",
                zap.String("source_node", sourceNode.NodeName),
                zap.String("target_node", targetNode.NodeName),
                zap.String("target_cluster", targetCluster.ClusterName),
                zap.Uint32("vmid", vm.VMID),
                zap.String("target_bridge", req.TargetBridge),
                zap.String("target_storage", req.TargetStorage),
                zap.String("target_host", targetHost),
                zap.String("target_port", targetPort),
                zap.String("fingerprint", fingerprint),
                zap.String("target_endpoint", targetEndpoint))

        // 8. 调用 Proxmox API 执行跨集群迁移
        upid, err := client.RemoteMigrateVM(ctx, sourceNode.NodeName, vm.VMID, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to remote migrate vm", zap.Error(err),
                        zap.String("source_node", sourceNode.NodeName),
                        zap.String("target_node", targetNode.NodeName),
                        zap.String("target_cluster", targetCluster.ClusterName),
                        zap.Uint32("vmid", vm.VMID),
                        zap.String("target_endpoint", targetEndpoint)) // 记录完整的 endpoint 用于调试
                return "", v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm remote migration started", zap.Uint32("vmid", vm.VMID),
                zap.String("source_node", sourceNode.NodeName),
                zap.String("target_node", targetNode.NodeName),
                zap.String("target_cluster", targetCluster.ClusterName),
                zap.String("upid", upid))

        return upid, nil</span>
}

// CreateBackup 创建虚拟机备份
// 参考: https://pve.proxmox.com/pve-docs/api-viewer/#/nodes/{node}/vzdump
func (s *pveVMService) CreateBackup(ctx context.Context, req *v1.CreateBackupRequest) (*v1.CreateBackupResponseData, error) <span class="cov0" title="0">{
        // 1. 通过 VMID 查询虚拟机（需要先获取节点信息）
        // 由于 GetByVMID 需要 nodeID，我们需要先通过其他方式查询
        // 或者直接通过 Proxmox API 验证 VM 是否存在
        // 这里我们通过查询所有集群的 VM 来找到匹配的

        // 先尝试通过 Proxmox API 直接创建备份（如果 VMID 存在）
        // 但为了获取节点信息，我们需要查询数据库

        // 方案：查询所有 VM，找到匹配的 VMID
        var vm *model.PveVM
        allVMs, _, err := s.vmRepo.ListWithPagination(ctx, 1, 1000, 0, "", 0, "", 0, "", "")
        if err == nil </span><span class="cov0" title="0">{
                for _, v := range allVMs </span><span class="cov0" title="0">{
                        if v.VMID == req.VMID </span><span class="cov0" title="0">{
                                vm = v
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("虚拟机 VMID %d 不存在", req.VMID)
        }</span>

        // 2. 获取节点信息
        <span class="cov0" title="0">node, err := s.nodeRepo.GetByID(ctx, vm.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("节点不存在")
        }</span>

        // 3. 获取 Proxmox 客户端
        <span class="cov0" title="0">client, _, err := s.getProxmoxClientForVM(ctx, vm.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 4. 构建备份请求参数
        <span class="cov0" title="0">backupReq := &amp;proxmox.CreateBackupRequest{
                VMID: req.VMID,
        }

        if req.Storage != "" </span><span class="cov0" title="0">{
                backupReq.Storage = req.Storage
        }</span>
        <span class="cov0" title="0">if req.Compress != "" </span><span class="cov0" title="0">{
                // Proxmox API 压缩格式转换：支持常用别名
                compress := req.Compress
                switch compress </span>{
                case "zst":<span class="cov0" title="0">
                        compress = "zstd"</span> // zst -&gt; zstd
                case "gz":<span class="cov0" title="0">
                        compress = "gzip"</span> // gz -&gt; gzip
                }
                <span class="cov0" title="0">backupReq.Compress = compress</span>
        }
        <span class="cov0" title="0">if req.Mode != "" </span><span class="cov0" title="0">{
                backupReq.Mode = req.Mode
        }</span> else<span class="cov0" title="0"> {
                backupReq.Mode = "snapshot" // 默认使用快照模式
        }</span>
        <span class="cov0" title="0">if req.Remove != nil </span><span class="cov0" title="0">{
                backupReq.Remove = *req.Remove
        }</span>
        <span class="cov0" title="0">if req.MailTo != "" </span><span class="cov0" title="0">{
                backupReq.MailTo = req.MailTo
        }</span>
        <span class="cov0" title="0">if req.MailNotification != "" </span><span class="cov0" title="0">{
                backupReq.MailNotification = req.MailNotification
        }</span>
        <span class="cov0" title="0">if req.NotesTemplate != "" </span><span class="cov0" title="0">{
                backupReq.NotesTemplate = req.NotesTemplate
        }</span>
        <span class="cov0" title="0">if req.Exclude != "" </span><span class="cov0" title="0">{
                backupReq.Exclude = req.Exclude
        }</span>
        <span class="cov0" title="0">if req.Quiesce != nil </span><span class="cov0" title="0">{
                backupReq.Quiesce = *req.Quiesce
        }</span>
        <span class="cov0" title="0">if req.MaxFiles != nil </span><span class="cov0" title="0">{
                backupReq.MaxFiles = *req.MaxFiles
        }</span>
        <span class="cov0" title="0">if req.Bwlimit != nil </span><span class="cov0" title="0">{
                backupReq.Bwlimit = *req.Bwlimit
        }</span>
        <span class="cov0" title="0">if req.Ionice != nil </span><span class="cov0" title="0">{
                backupReq.Ionice = *req.Ionice
        }</span>
        <span class="cov0" title="0">if req.Stop != nil </span><span class="cov0" title="0">{
                backupReq.Stop = *req.Stop
        }</span>
        <span class="cov0" title="0">if req.StopWait != nil </span><span class="cov0" title="0">{
                backupReq.StopWait = *req.StopWait
        }</span>
        <span class="cov0" title="0">if req.DumpDir != "" </span><span class="cov0" title="0">{
                backupReq.DumpDir = req.DumpDir
        }</span>
        <span class="cov0" title="0">if req.Zstd != nil </span><span class="cov0" title="0">{
                backupReq.Zstd = *req.Zstd
        }</span>

        // 5. 调用 Proxmox API 创建备份
        <span class="cov0" title="0">upid, err := client.CreateBackup(ctx, node.NodeName, backupReq)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create backup",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.Uint32("vmid", req.VMID))
                return nil, fmt.Errorf("创建备份失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm backup started",
                zap.String("node", node.NodeName),
                zap.Uint32("vmid", req.VMID),
                zap.String("upid", upid),
                zap.String("mode", backupReq.Mode),
                zap.String("storage", backupReq.Storage))

        return &amp;v1.CreateBackupResponseData{
                UPID:     upid,
                VMID:     req.VMID,
                NodeID:   node.Id,
                NodeName: node.NodeName,
        }, nil</span>
}

// DeleteBackup 删除虚拟机备份
// 参考: https://pve.proxmox.com/pve-docs/api-viewer/#/nodes/{node}/storage/{storage}/content/{volume}
func (s *pveVMService) DeleteBackup(ctx context.Context, req *v1.DeleteBackupRequest) error <span class="cov0" title="0">{
        // 1. 获取节点信息
        node, err := s.nodeRepo.GetByID(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("节点 ID %d 不存在", req.NodeID)
        }</span>

        // 2. 获取存储信息
        <span class="cov0" title="0">storage, err := s.storageRepo.GetByID(ctx, req.StorageID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get storage", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if storage == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("存储 ID %d 不存在", req.StorageID)
        }</span>

        // 3. 获取 Proxmox 客户端
        <span class="cov0" title="0">client, err := s.getProxmoxClientForNode(ctx, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 4. 调用 Proxmox API 删除备份
        // volume 格式：storage:backup/filename，例如：local:backup/vzdump-qemu-100-2024_01_01-00_00_00.vma.zst
        <span class="cov0" title="0">err = client.DeleteStorageContent(ctx, node.NodeName, storage.StorageName, req.Volume, req.Delay)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to delete backup",
                        zap.Error(err),
                        zap.String("node", node.NodeName),
                        zap.String("storage", storage.StorageName),
                        zap.String("volume", req.Volume))
                return fmt.Errorf("删除备份失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("backup deleted successfully",
                zap.String("node", node.NodeName),
                zap.String("storage", storage.StorageName),
                zap.String("volume", req.Volume))

        return nil</span>
}

// GetVMCloudInit 获取虚拟机 CloudInit 配置
func (s *pveVMService) GetVMCloudInit(ctx context.Context, req *v1.GetVMCloudInitRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        // 1. 获取节点信息
        node, err := s.nodeRepo.GetByID(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("节点 ID %d 不存在", req.NodeID)
        }</span>

        // 2. 获取 Proxmox 客户端
        <span class="cov0" title="0">client, err := s.getProxmoxClientForNode(ctx, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 3. 调用 Proxmox API 获取 CloudInit 配置
        <span class="cov0" title="0">config, err := client.GetVMCloudInitConfig(ctx, node.NodeName, req.VMID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get vm cloudinit config",
                        zap.Error(err),
                        zap.Uint32("vmid", req.VMID),
                        zap.String("node", node.NodeName))
                return nil, fmt.Errorf("获取 CloudInit 配置失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm cloudinit config retrieved successfully",
                zap.Uint32("vmid", req.VMID),
                zap.String("node", node.NodeName))

        return config, nil</span>
}

// UpdateVMCloudInit 更新虚拟机 CloudInit 配置
func (s *pveVMService) UpdateVMCloudInit(ctx context.Context, req *v1.UpdateVMCloudInitRequest) error <span class="cov0" title="0">{
        // 1. 获取节点信息
        node, err := s.nodeRepo.GetByID(ctx, req.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("节点 ID %d 不存在", req.NodeID)
        }</span>

        // 2. 获取 Proxmox 客户端
        <span class="cov0" title="0">client, err := s.getProxmoxClientForNode(ctx, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 3. 构建 form 参数
        <span class="cov0" title="0">params := url.Values{}
        if req.Cipassword != nil &amp;&amp; *req.Cipassword != "" </span><span class="cov0" title="0">{
                params.Set("cipassword", *req.Cipassword)
        }</span>
        <span class="cov0" title="0">if req.CIuser != nil &amp;&amp; *req.CIuser != "" </span><span class="cov0" title="0">{
                params.Set("ciuser", *req.CIuser)
        }</span>
        <span class="cov0" title="0">if req.Citype != nil &amp;&amp; *req.Citype != "" </span><span class="cov0" title="0">{
                params.Set("citype", *req.Citype)
        }</span>
        <span class="cov0" title="0">if req.Nameserver != nil &amp;&amp; *req.Nameserver != "" </span><span class="cov0" title="0">{
                params.Set("nameserver", *req.Nameserver)
        }</span>
        <span class="cov0" title="0">if req.Searchdomain != nil &amp;&amp; *req.Searchdomain != "" </span><span class="cov0" title="0">{
                params.Set("searchdomain", *req.Searchdomain)
        }</span>
        <span class="cov0" title="0">if req.SSHkeys != nil &amp;&amp; *req.SSHkeys != "" </span><span class="cov0" title="0">{
                params.Set("sshkeys", *req.SSHkeys)
        }</span>
        <span class="cov0" title="0">if req.IPconfig0 != nil &amp;&amp; *req.IPconfig0 != "" </span><span class="cov0" title="0">{
                params.Set("ipconfig0", *req.IPconfig0)
        }</span>
        <span class="cov0" title="0">if req.IPconfig1 != nil &amp;&amp; *req.IPconfig1 != "" </span><span class="cov0" title="0">{
                params.Set("ipconfig1", *req.IPconfig1)
        }</span>
        <span class="cov0" title="0">if req.IPconfig2 != nil &amp;&amp; *req.IPconfig2 != "" </span><span class="cov0" title="0">{
                params.Set("ipconfig2", *req.IPconfig2)
        }</span>

        // 4. 调用 Proxmox API 更新 CloudInit 配置
        <span class="cov0" title="0">err = client.UpdateVMCloudInitConfig(ctx, node.NodeName, req.VMID, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update vm cloudinit config",
                        zap.Error(err),
                        zap.Uint32("vmid", req.VMID),
                        zap.String("node", node.NodeName))
                return fmt.Errorf("更新 CloudInit 配置失败: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("vm cloudinit config updated successfully",
                zap.Uint32("vmid", req.VMID),
                zap.String("node", node.NodeName))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package service

import (
        "pvesphere/internal/repository"
        "pvesphere/pkg/jwt"
        "pvesphere/pkg/log"
        "pvesphere/pkg/sid"
)

type Service struct {
        logger *log.Logger
        sid    *sid.Sid
        jwt    *jwt.JWT
        tm     repository.Transaction
}

func NewService(
        tm repository.Transaction,
        logger *log.Logger,
        sid *sid.Sid,
        jwt *jwt.JWT,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                logger: logger,
                sid:    sid,
                jwt:    jwt,
                tm:     tm,
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package service

import (
        "context"
        "crypto/md5"
        "fmt"
        "net/url"
        "strconv"
        "strings"
        "sync"
        "time"

        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"
        "pvesphere/internal/repository"
        "pvesphere/pkg/log"
        "pvesphere/pkg/proxmox"

        "go.uber.org/zap"
)

type TemplateManagementService interface {
        // 模板导入（基于已有备份文件）
        ImportTemplateFromBackup(ctx context.Context, req *v1.ImportTemplateRequest) (*v1.ImportTemplateResponseData, error)

        // 查询模板详情（包含实例）
        GetTemplateDetailWithInstances(ctx context.Context, templateID int64, includeInstances bool) (*v1.TemplateDetailWithInstances, error)

        // 模板同步
        SyncTemplateToNodes(ctx context.Context, templateID int64, targetNodeIDs []int64) (*v1.SyncTemplateResponseData, error)

        // 同步任务管理
        GetSyncTask(ctx context.Context, taskID int64) (*v1.SyncTaskDetail, error)
        ListSyncTasks(ctx context.Context, req *v1.ListSyncTasksRequest) (*v1.ListSyncTasksResponseData, error)
        RetrySyncTask(ctx context.Context, taskID int64) error

        // 实例管理
        ListTemplateInstances(ctx context.Context, templateID int64) (*v1.ListTemplateInstancesResponseData, error)
}

func NewTemplateManagementService(
        service *Service,
        templateRepo repository.PveTemplateRepository,
        uploadRepo repository.TemplateUploadRepository,
        instanceRepo repository.TemplateInstanceRepository,
        syncTaskRepo repository.TemplateSyncTaskRepository,
        vmRepo repository.PveVMRepository,
        storageRepo repository.PveStorageRepository,
        nodeRepo repository.PveNodeRepository,
        clusterRepo repository.PveClusterRepository,
        logger *log.Logger,
) TemplateManagementService <span class="cov0" title="0">{
        s := &amp;templateManagementService{
                Service:       service,
                templateRepo:  templateRepo,
                uploadRepo:    uploadRepo,
                instanceRepo:  instanceRepo,
                syncTaskRepo:  syncTaskRepo,
                vmRepo:        vmRepo,
                storageRepo:   storageRepo,
                nodeRepo:      nodeRepo,
                clusterRepo:   clusterRepo,
                logger:        logger,
                syncTaskQueue: make(chan int64, 100), // 缓冲队列，最多100个任务
        }

        // 启动任务队列处理器（串行执行）
        go s.processSyncTaskQueue()

        return s
}</span>

// processSyncTaskQueue 处理同步任务队列（串行执行）
func (s *templateManagementService) processSyncTaskQueue() <span class="cov0" title="0">{
        for taskID := range s.syncTaskQueue </span><span class="cov0" title="0">{
                s.executeSyncTask(context.Background(), taskID)
        }</span>
}

type templateManagementService struct {
        *Service
        templateRepo repository.PveTemplateRepository
        uploadRepo   repository.TemplateUploadRepository
        instanceRepo repository.TemplateInstanceRepository
        syncTaskRepo repository.TemplateSyncTaskRepository
        vmRepo       repository.PveVMRepository
        storageRepo  repository.PveStorageRepository
        nodeRepo     repository.PveNodeRepository
        clusterRepo  repository.PveClusterRepository
        logger       *log.Logger

        // 同步任务队列：用于串行化执行，避免并发克隆冲突
        syncTaskQueue chan int64
        // 模板级别的锁：确保同一模板的同步任务串行执行
        templateLocks sync.Map // map[int64]*sync.Mutex
}

// ImportTemplateFromBackup 从已有备份文件导入模板
func (s *templateManagementService) ImportTemplateFromBackup(
        ctx context.Context,
        req *v1.ImportTemplateRequest,
) (*v1.ImportTemplateResponseData, error) <span class="cov0" title="0">{
        // 1. 验证备份存储是否存在（存放备份文件的存储，通常是 local）
        backupStorage, err := s.storageRepo.GetByID(ctx, req.BackupStorageID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get backup storage", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if backupStorage == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrStorageNotFound
        }</span>

        // 2. 验证目标存储是否存在（创建 VM 磁盘的存储，必须支持 images）
        <span class="cov0" title="0">targetStorage, err := s.storageRepo.GetByID(ctx, req.TargetStorageID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get target storage", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if targetStorage == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("目标存储不存在")
        }</span>

        // 3. 验证目标存储是否支持 images 内容类型
        <span class="cov0" title="0">if !strings.Contains(targetStorage.Content, "images") </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("target storage does not support images",
                        zap.String("storage_name", targetStorage.StorageName),
                        zap.String("content", targetStorage.Content))
                return nil, fmt.Errorf("目标存储 '%s' 不支持 VM 磁盘镜像(images)，当前支持的内容类型：%s。请选择支持 'images' 的存储（如 local-lvm）",
                        targetStorage.StorageName, targetStorage.Content)
        }</span>

        // 4. 防止使用 local 存储作为目标存储
        <span class="cov0" title="0">if targetStorage.Type == "dir" &amp;&amp; targetStorage.StorageName == "local" </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("cannot use local storage as target",
                        zap.String("storage_name", targetStorage.StorageName))
                return nil, fmt.Errorf("不能使用 'local' 存储作为目标存储，请选择支持 VM 磁盘的存储（如 local-lvm）")
        }</span>

        // 5. 验证导入节点是否存在
        <span class="cov0" title="0">importNode, err := s.nodeRepo.GetByID(ctx, req.NodeID)
        if err != nil || importNode == nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get import node", zap.Error(err))
                return nil, v1.ErrNodeNotFound
        }</span>

        // 6. 判断目标存储类型（用于后续同步逻辑）
        <span class="cov0" title="0">isShared := targetStorage.Shared == 1

        // 7. 创建模板记录
        template := &amp;model.PveTemplate{
                TemplateName: req.TemplateName,
                ClusterID:    req.ClusterID,
                Description:  req.Description,
                CreateTime:   time.Now(),
                UpdateTime:   time.Now(),
        }
        if err := s.templateRepo.Create(ctx, template); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create template", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 8. 解析备份文件信息
        <span class="cov0" title="0">fileName := req.BackupFile
        fileFormat := s.getBackupFileFormat(fileName)

        // 构建备份文件完整路径（从备份存储读取）
        filePath := s.buildBackupFilePath(backupStorage.StorageName, fileName)

        // 9. 查询备份文件大小
        fileSize, err := s.getBackupFileSize(ctx, importNode, backupStorage.StorageName, fileName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Warn("failed to get backup file size, using 0",
                        zap.Error(err),
                        zap.String("backup_file", fileName))
                fileSize = 0 // 如果查询失败，使用 0
        }</span>

        // 10. 创建导入记录（记录目标存储信息）
        <span class="cov0" title="0">upload := &amp;model.TemplateUpload{
                TemplateID:     template.Id,
                ClusterID:      req.ClusterID,
                StorageID:      targetStorage.Id, // 使用目标存储
                StorageName:    targetStorage.StorageName,
                StorageType:    targetStorage.Type,
                IsShared:       int8(targetStorage.Shared),
                UploadNodeID:   importNode.Id,
                UploadNodeName: importNode.NodeName,
                FileName:       fileName,
                FilePath:       filePath, // 备份文件路径（从备份存储）
                FileSize:       fileSize, // 备份文件大小（字节）
                FileFormat:     fileFormat,
                Status:         model.TemplateUploadStatusImporting,
                ImportProgress: 0,
                CreateTime:     time.Now(),
                UpdateTime:     time.Now(),
        }
        if err := s.uploadRepo.Create(ctx, upload); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create import record", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 10. 从备份文件导入模板到 PVE（备份文件从 backupStorage 读取，VM 磁盘创建在 targetStorage）
        <span class="cov0" title="0">vmid, err := s.importTemplateFromBackup(ctx, importNode, backupStorage, targetStorage, filePath, fileName, template.TemplateName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to import template from backup", zap.Error(err))
                _ = s.uploadRepo.UpdateStatus(ctx, upload.Id, model.TemplateUploadStatusFailed, 0, err.Error())
                return nil, v1.ErrTemplateImportFailed
        }</span>

        // 8. 更新导入状态
        <span class="cov0" title="0">upload.Status = model.TemplateUploadStatusImported
        upload.ImportProgress = 100
        if err := s.uploadRepo.Update(ctx, upload); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update import status", zap.Error(err))
        }</span>

        // 9. 根据存储类型创建实例
        <span class="cov0" title="0">var syncTasks []v1.TemplateSyncTaskInfo

        if isShared </span><span class="cov0" title="0">{
                // 共享存储：为所有可见节点创建逻辑实例
                visibleNodes, err := s.getStorageVisibleNodes(ctx, req.ClusterID, targetStorage.StorageName)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get visible nodes", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>

                <span class="cov0" title="0">for _, node := range visibleNodes </span><span class="cov0" title="0">{
                        isPrimary := int8(0)
                        if node.Id == importNode.Id </span><span class="cov0" title="0">{
                                isPrimary = 1
                        }</span>

                        <span class="cov0" title="0">instance := &amp;model.TemplateInstance{
                                TemplateID:  template.Id,
                                UploadID:    upload.Id,
                                ClusterID:   req.ClusterID,
                                NodeID:      node.Id,
                                NodeName:    node.NodeName,
                                StorageID:   targetStorage.Id,
                                StorageName: targetStorage.StorageName,
                                IsShared:    1,
                                VMID:        vmid,
                                Status:      model.TemplateInstanceStatusAvailable,
                                IsPrimary:   isPrimary,
                                CreateTime:  time.Now(),
                                UpdateTime:  time.Now(),
                        }
                        if err := s.instanceRepo.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to create instance",
                                        zap.Error(err),
                                        zap.Int64("node_id", node.Id))
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // 本地存储：仅为导入节点创建实例
                instance := &amp;model.TemplateInstance{
                        TemplateID:  template.Id,
                        UploadID:    upload.Id,
                        ClusterID:   req.ClusterID,
                        NodeID:      importNode.Id,
                        NodeName:    importNode.NodeName,
                        StorageID:   targetStorage.Id,
                        StorageName: targetStorage.StorageName,
                        IsShared:    0,
                        VMID:        vmid,
                        Status:      model.TemplateInstanceStatusAvailable,
                        IsPrimary:   1,
                        CreateTime:  time.Now(),
                        UpdateTime:  time.Now(),
                }
                if err := s.instanceRepo.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create primary instance", zap.Error(err))
                        return nil, v1.ErrInternalServerError
                }</span>

                // 如果指定了同步节点，创建同步任务
                <span class="cov0" title="0">if len(req.SyncNodeIDs) &gt; 0 </span><span class="cov0" title="0">{
                        syncTasks, err = s.createSyncTasks(ctx, template, upload, importNode, req.SyncNodeIDs)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Error("failed to create sync tasks", zap.Error(err))
                                // 不返回错误，允许后续手动同步
                        }</span>
                }
        }

        // 10. 返回响应
        <span class="cov0" title="0">return &amp;v1.ImportTemplateResponseData{
                TemplateID:  template.Id,
                ImportID:    upload.Id,
                StorageType: targetStorage.Type,
                IsShared:    isShared,
                ImportNode: v1.TemplateImportNode{
                        NodeID:   importNode.Id,
                        NodeName: importNode.NodeName,
                },
                SyncTasks: syncTasks,
        }, nil</span>
}

// getBackupFileFormat 获取备份文件格式
func (s *templateManagementService) getBackupFileFormat(fileName string) string <span class="cov0" title="0">{
        // 支持的备份格式：
        // - vzdump-qemu-100-2024_01_01-00_00_00.vma
        // - vzdump-qemu-100-2024_01_01-00_00_00.vma.zst
        // - vzdump-qemu-100-2024_01_01-00_00_00.vma.lzo
        // - vzdump-qemu-100-2024_01_01-00_00_00.vma.gz
        if len(fileName) &gt; 4 </span><span class="cov0" title="0">{
                // 检查双重扩展名
                if len(fileName) &gt; 8 </span><span class="cov0" title="0">{
                        ext := fileName[len(fileName)-8:]
                        if ext == ".vma.zst" || ext == ".vma.lzo" </span><span class="cov0" title="0">{
                                return ext[1:] // 去掉前导点
                        }</span>
                }
                <span class="cov0" title="0">if len(fileName) &gt; 7 </span><span class="cov0" title="0">{
                        ext := fileName[len(fileName)-7:]
                        if ext == ".vma.gz" </span><span class="cov0" title="0">{
                                return ext[1:]
                        }</span>
                }
                // 检查单扩展名
                <span class="cov0" title="0">ext := fileName[len(fileName)-4:]
                if ext == ".vma" </span><span class="cov0" title="0">{
                        return ext[1:]
                }</span>
        }
        <span class="cov0" title="0">return "vma"</span>
}

// buildBackupFilePath 构建备份文件完整路径
func (s *templateManagementService) buildBackupFilePath(storageName, fileName string) string <span class="cov0" title="0">{
        // PVE 备份文件路径通常为：
        // 本地存储：/var/lib/vz/dump/文件名
        // 共享存储：/mnt/pve/{storage_name}/dump/文件名
        // 这里返回相对路径，实际路径由 PVE API 处理
        return fmt.Sprintf("%s:backup/%s", storageName, fileName)
}</span>

// getBackupFileSize 获取备份文件大小
func (s *templateManagementService) getBackupFileSize(
        ctx context.Context,
        node *model.PveNode,
        storageName string,
        fileName string,
) (int64, error) <span class="cov0" title="0">{
        // 1. 获取 Proxmox 客户端
        client, _, err := s.getProxmoxClientForNode(ctx, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get proxmox client: %w", err)
        }</span>

        // 2. 查询存储内容（备份文件）
        <span class="cov0" title="0">contentList, err := client.GetStorageContent(ctx, node.NodeName, storageName, "backup")
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get storage content: %w", err)
        }</span>

        // 3. 查找匹配的备份文件
        // volid 格式通常是：storage:backup/filename
        // 例如：local:backup/vzdump-qemu-100-2024_01_01-00_00_00.vma.zst
        <span class="cov0" title="0">expectedVolid := fmt.Sprintf("%s:backup/%s", storageName, fileName)

        for _, item := range contentList </span><span class="cov0" title="0">{
                volid, ok := item["volid"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 精确匹配 volid，或者文件名匹配
                <span class="cov0" title="0">if volid == expectedVolid || strings.HasSuffix(volid, "/"+fileName) </span><span class="cov0" title="0">{
                        // 提取文件大小
                        if size, ok := item["size"].(float64); ok </span><span class="cov0" title="0">{
                                return int64(size), nil
                        }</span>
                        // 如果 size 是字符串，尝试转换
                        <span class="cov0" title="0">if sizeStr, ok := item["size"].(string); ok </span><span class="cov0" title="0">{
                                size, err := strconv.ParseInt(sizeStr, 10, 64)
                                if err == nil </span><span class="cov0" title="0">{
                                        return size, nil
                                }</span>
                        }
                        // 如果 size 是 int64，直接返回
                        <span class="cov0" title="0">if size, ok := item["size"].(int64); ok </span><span class="cov0" title="0">{
                                return size, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return 0, fmt.Errorf("backup file not found: %s", fileName)</span>
}

// getStorageVisibleNodes 获取存储可见的所有节点
func (s *templateManagementService) getStorageVisibleNodes(ctx context.Context, clusterID int64, storageName string) ([]*model.PveNode, error) <span class="cov0" title="0">{
        // 1. 查询该存储的所有记录
        storages, err := s.storageRepo.ListByStorageName(ctx, clusterID, storageName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. 提取节点名称
        <span class="cov0" title="0">nodeNameMap := make(map[string]bool)
        for _, s := range storages </span><span class="cov0" title="0">{
                nodeNameMap[s.NodeName] = true
        }</span>

        // 3. 查询对应的节点信息
        <span class="cov0" title="0">var nodes []*model.PveNode
        for nodeName := range nodeNameMap </span><span class="cov0" title="0">{
                node, err := s.nodeRepo.GetByNodeName(ctx, nodeName, clusterID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get node",
                                zap.Error(err),
                                zap.String("node_name", nodeName))
                        continue</span>
                }
                <span class="cov0" title="0">if node != nil </span><span class="cov0" title="0">{
                        nodes = append(nodes, node)
                }</span>
        }

        <span class="cov0" title="0">return nodes, nil</span>
}

// importTemplateFromBackup 从备份文件导入模板到 PVE
// backupStorage: 备份文件所在的存储
// targetStorage: VM 磁盘要创建的目标存储
func (s *templateManagementService) importTemplateFromBackup(
        ctx context.Context,
        node *model.PveNode,
        backupStorage *model.PveStorage,
        targetStorage *model.PveStorage,
        filePath string,
        fileName string,
        templateName string,
) (uint32, error) <span class="cov0" title="0">{
        // TODO: 实现从备份导入模板的逻辑
        //
        // 根据 Proxmox VE API 文档：https://pve.proxmox.com/pve-docs/api-viewer
        // 从备份恢复虚拟机应使用：POST /nodes/{node}/qemu
        //
        // 实现步骤：
        // 1. 获取 Proxmox 客户端
        // 2. 分配新的 VMID
        // 3. 调用 CreateQemuVM API，传递 archive 参数恢复备份
        // 4. 等待恢复任务完成
        // 5. 重命名 VM（可选）
        // 6. 转换为模板

        // 1. 获取 Proxmox 客户端
        client, _, err := s.getProxmoxClientForNode(ctx, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get proxmox client", zap.Error(err))
                return 0, fmt.Errorf("failed to get proxmox client: %w", err)
        }</span>

        // 2. 获取下一个可用的 VMID
        <span class="cov0" title="0">vmid, err := client.GetNextFreeVMID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get next free vmid", zap.Error(err))
                return 0, fmt.Errorf("failed to get next free vmid: %w", err)
        }</span>

        // 3. 从备份恢复虚拟机
        // archive 格式：storage:backup/filename（从备份存储读取）
        <span class="cov0" title="0">archivePath := filePath
        if !strings.Contains(filePath, ":") </span><span class="cov0" title="0">{
                // 如果 filePath 不包含存储前缀，自动添加
                archivePath = fmt.Sprintf("%s:backup/%s", backupStorage.StorageName, fileName)
        }</span>

        <span class="cov0" title="0">params := url.Values{}
        params.Set("vmid", fmt.Sprintf("%d", vmid))
        params.Set("archive", archivePath) // 从备份存储读取备份文件
        if targetStorage.StorageName != "" </span><span class="cov0" title="0">{
                params.Set("storage", targetStorage.StorageName) // VM 磁盘创建在目标存储
        }</span>
        <span class="cov0" title="0">if templateName != "" </span><span class="cov0" title="0">{
                params.Set("name", templateName)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("restoring vm from backup",
                zap.String("node", node.NodeName),
                zap.String("archive", archivePath),
                zap.String("backup_storage", backupStorage.StorageName),
                zap.String("target_storage", targetStorage.StorageName),
                zap.Uint32("vmid", vmid))

        upid, err := client.CreateQemuVM(ctx, node.NodeName, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to restore from backup", zap.Error(err))
                return 0, fmt.Errorf("failed to restore from backup: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("restore task started", zap.String("upid", upid), zap.Uint32("vmid", vmid))

        // 4. 等待恢复任务完成
        err = s.waitForTask(ctx, client, node.NodeName, upid, 30*time.Minute, nil)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("restore task failed", zap.Error(err), zap.String("upid", upid))
                return 0, fmt.Errorf("restore task failed: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("restore task completed", zap.Uint32("vmid", vmid))

        // 5. 转换为模板
        err = client.ConvertToTemplate(ctx, node.NodeName, vmid, "")
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to convert to template", zap.Error(err), zap.Uint32("vmid", vmid))
                return 0, fmt.Errorf("failed to convert to template: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("template imported from backup successfully",
                zap.String("node", node.NodeName),
                zap.Uint32("vmid", vmid),
                zap.String("template_name", templateName))

        return vmid, nil</span>
}

// createSyncTasks 创建同步任务
func (s *templateManagementService) createSyncTasks(
        ctx context.Context,
        template *model.PveTemplate,
        upload *model.TemplateUpload,
        sourceNode *model.PveNode,
        targetNodeIDs []int64,
) ([]v1.TemplateSyncTaskInfo, error) <span class="cov0" title="0">{
        var tasks []v1.TemplateSyncTaskInfo

        for _, targetNodeID := range targetNodeIDs </span><span class="cov0" title="0">{
                // 检查是否已存在可用的实例
                existing, err := s.instanceRepo.GetByTemplateAndNode(ctx, template.Id, targetNodeID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to check existing instance",
                                zap.Error(err),
                                zap.Int64("node_id", targetNodeID))
                        continue</span>
                }
                <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                        // 如果实例状态是 available，跳过
                        if existing.Status == model.TemplateInstanceStatusAvailable </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Info("instance already available, skip sync",
                                        zap.Int64("template_id", template.Id),
                                        zap.Int64("node_id", targetNodeID))
                                continue</span>
                        }
                        // 如果实例状态是 pending 或 failed，清理旧的任务和实例
                        <span class="cov0" title="0">if existing.Status == model.TemplateInstanceStatusPending || existing.Status == model.TemplateInstanceStatusFailed </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Info("cleaning up failed/pending instance",
                                        zap.Int64("template_id", template.Id),
                                        zap.Int64("node_id", targetNodeID),
                                        zap.String("old_status", existing.Status))
                                // 如果有同步任务，删除失败的任务
                                if existing.SyncTaskID != nil </span><span class="cov0" title="0">{
                                        oldTask, _ := s.syncTaskRepo.GetByID(ctx, *existing.SyncTaskID)
                                        if oldTask != nil &amp;&amp; oldTask.Status == model.TemplateSyncTaskStatusFailed </span><span class="cov0" title="0">{
                                                _ = s.syncTaskRepo.Delete(ctx, *existing.SyncTaskID)
                                        }</span>
                                }
                                // 删除旧的实例记录
                                <span class="cov0" title="0">_ = s.instanceRepo.Delete(ctx, existing.Id)</span>
                        }
                }

                // 获取目标节点信息
                <span class="cov0" title="0">targetNode, err := s.nodeRepo.GetByID(ctx, targetNodeID)
                if err != nil || targetNode == nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to get target node",
                                zap.Error(err),
                                zap.Int64("node_id", targetNodeID))
                        continue</span>
                }

                // 创建同步任务
                <span class="cov0" title="0">syncTask := &amp;model.TemplateSyncTask{
                        TemplateID:     template.Id,
                        UploadID:       upload.Id,
                        ClusterID:      template.ClusterID,
                        SourceNodeID:   sourceNode.Id,
                        SourceNodeName: sourceNode.NodeName,
                        TargetNodeID:   targetNode.Id,
                        TargetNodeName: targetNode.NodeName,
                        StorageName:    upload.StorageName,
                        FilePath:       upload.FilePath,
                        FileSize:       upload.FileSize,
                        Status:         model.TemplateSyncTaskStatusPending,
                        Progress:       0,
                        CreateTime:     time.Now(),
                        UpdateTime:     time.Now(),
                }
                if err := s.syncTaskRepo.Create(ctx, syncTask); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create sync task",
                                zap.Error(err),
                                zap.Int64("target_node_id", targetNodeID))
                        continue</span>
                }

                // 创建待同步的实例记录
                <span class="cov0" title="0">instance := &amp;model.TemplateInstance{
                        TemplateID:  template.Id,
                        UploadID:    upload.Id,
                        ClusterID:   template.ClusterID,
                        NodeID:      targetNode.Id,
                        NodeName:    targetNode.NodeName,
                        StorageID:   upload.StorageID,
                        StorageName: upload.StorageName,
                        IsShared:    0,
                        VMID:        0, // 将在同步后分配
                        Status:      model.TemplateInstanceStatusPending,
                        SyncTaskID:  &amp;syncTask.Id,
                        IsPrimary:   0,
                        CreateTime:  time.Now(),
                        UpdateTime:  time.Now(),
                }
                if err := s.instanceRepo.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to create instance",
                                zap.Error(err),
                                zap.Int64("node_id", targetNodeID))
                }</span>

                // 添加到响应列表
                <span class="cov0" title="0">tasks = append(tasks, v1.TemplateSyncTaskInfo{
                        TaskID:         syncTask.Id,
                        TargetNodeID:   targetNode.Id,
                        TargetNodeName: targetNode.NodeName,
                        Status:         syncTask.Status,
                })

                // 将任务加入队列（串行执行，避免并发克隆冲突）
                select </span>{
                case s.syncTaskQueue &lt;- syncTask.Id:<span class="cov0" title="0">
                        s.logger.WithContext(ctx).Info("sync task queued",
                                zap.Int64("task_id", syncTask.Id),
                                zap.Int64("template_id", template.Id),
                                zap.Int64("target_node_id", targetNodeID))</span>
                default:<span class="cov0" title="0">
                        s.logger.WithContext(ctx).Error("sync task queue is full, task may be delayed",
                                zap.Int64("task_id", syncTask.Id))
                        // 队列满了，仍然尝试加入（可能会阻塞，但不会丢失任务）
                        go func() </span><span class="cov0" title="0">{
                                s.syncTaskQueue &lt;- syncTask.Id
                        }</span>()
                }
        }

        <span class="cov0" title="0">return tasks, nil</span>
}

// GetTemplateDetailWithInstances 查询模板详情（包含实例）
func (s *templateManagementService) GetTemplateDetailWithInstances(
        ctx context.Context,
        templateID int64,
        includeInstances bool,
) (*v1.TemplateDetailWithInstances, error) <span class="cov0" title="0">{
        // 1. 查询模板基本信息
        template, err := s.templateRepo.GetByID(ctx, templateID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get template", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if template == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 2. 查询集群名称
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, template.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
        }</span>
        <span class="cov0" title="0">clusterName := ""
        if cluster != nil </span><span class="cov0" title="0">{
                clusterName = cluster.ClusterName
        }</span>

        // 3. 查询上传信息
        <span class="cov0" title="0">upload, err := s.uploadRepo.GetByTemplateID(ctx, templateID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get upload", zap.Error(err))
        }</span>

        <span class="cov0" title="0">var uploadInfo *v1.TemplateUploadInfo
        if upload != nil </span><span class="cov0" title="0">{
                uploadInfo = &amp;v1.TemplateUploadInfo{
                        UploadID:    upload.Id,
                        StorageName: upload.StorageName,
                        IsShared:    upload.IsShared == 1,
                        FileName:    upload.FileName,
                        FileSize:    upload.FileSize,
                        Status:      upload.Status,
                }
        }</span>

        // 4. 查询实例信息
        <span class="cov0" title="0">var instances []v1.TemplateInstanceInfo
        if includeInstances </span><span class="cov0" title="0">{
                instanceList, err := s.instanceRepo.ListByTemplateID(ctx, templateID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to list instances", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        for _, inst := range instanceList </span><span class="cov0" title="0">{
                                instInfo := v1.TemplateInstanceInfo{
                                        InstanceID:  inst.Id,
                                        NodeID:      inst.NodeID,
                                        NodeName:    inst.NodeName,
                                        VMID:        inst.VMID,
                                        StorageName: inst.StorageName,
                                        Status:      inst.Status,
                                        IsPrimary:   inst.IsPrimary == 1,
                                }

                                // 如果有同步任务，查询进度
                                if inst.SyncTaskID != nil </span><span class="cov0" title="0">{
                                        task, err := s.syncTaskRepo.GetByID(ctx, *inst.SyncTaskID)
                                        if err == nil &amp;&amp; task != nil </span><span class="cov0" title="0">{
                                                instInfo.SyncProgress = &amp;task.Progress
                                        }</span>
                                }

                                <span class="cov0" title="0">instances = append(instances, instInfo)</span>
                        }
                }
        }

        <span class="cov0" title="0">return &amp;v1.TemplateDetailWithInstances{
                Id:           template.Id,
                TemplateName: template.TemplateName,
                ClusterID:    template.ClusterID,
                ClusterName:  clusterName,
                Description:  template.Description,
                UploadInfo:   uploadInfo,
                Instances:    instances,
        }, nil</span>
}

// SyncTemplateToNodes 同步模板到其他节点
func (s *templateManagementService) SyncTemplateToNodes(
        ctx context.Context,
        templateID int64,
        targetNodeIDs []int64,
) (*v1.SyncTemplateResponseData, error) <span class="cov0" title="0">{
        // 1. 获取模板信息
        template, err := s.templateRepo.GetByID(ctx, templateID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get template", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if template == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 2. 获取上传信息
        <span class="cov0" title="0">upload, err := s.uploadRepo.GetByTemplateID(ctx, templateID)
        if err != nil || upload == nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get upload", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 3. 验证是否为本地存储
        <span class="cov0" title="0">if upload.IsShared == 1 </span><span class="cov0" title="0">{
                return nil, v1.ErrSharedStorageNoSync
        }</span>

        // 4. 获取主实例（源节点）
        <span class="cov0" title="0">primaryInstance, err := s.instanceRepo.GetPrimaryInstance(ctx, templateID)
        if err != nil || primaryInstance == nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get primary instance", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">sourceNode, err := s.nodeRepo.GetByID(ctx, primaryInstance.NodeID)
        if err != nil || sourceNode == nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get source node", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        // 5. 创建同步任务
        <span class="cov0" title="0">tasks, err := s.createSyncTasks(ctx, template, upload, sourceNode, targetNodeIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create sync tasks", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return &amp;v1.SyncTemplateResponseData{
                SyncTasks: tasks,
        }, nil</span>
}

// GetSyncTask 查询同步任务
func (s *templateManagementService) GetSyncTask(ctx context.Context, taskID int64) (*v1.SyncTaskDetail, error) <span class="cov0" title="0">{
        task, err := s.syncTaskRepo.GetByID(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get sync task", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if task == nil </span><span class="cov0" title="0">{
                return nil, v1.ErrNotFound
        }</span>

        // 查询模板名称
        <span class="cov0" title="0">template, err := s.templateRepo.GetByID(ctx, task.TemplateID)
        templateName := ""
        if err == nil &amp;&amp; template != nil </span><span class="cov0" title="0">{
                templateName = template.TemplateName
        }</span>

        <span class="cov0" title="0">return &amp;v1.SyncTaskDetail{
                TaskID:       task.Id,
                TemplateID:   task.TemplateID,
                TemplateName: templateName,
                SourceNode: v1.NodeInfo{
                        NodeID:   task.SourceNodeID,
                        NodeName: task.SourceNodeName,
                },
                TargetNode: v1.NodeInfo{
                        NodeID:   task.TargetNodeID,
                        NodeName: task.TargetNodeName,
                },
                StorageName:   task.StorageName,
                Status:        task.Status,
                Progress:      task.Progress,
                SyncStartTime: task.SyncStartTime,
                SyncEndTime:   task.SyncEndTime,
                ErrorMessage:  task.ErrorMessage,
        }, nil</span>
}

// ListSyncTasks 列出同步任务
func (s *templateManagementService) ListSyncTasks(
        ctx context.Context,
        req *v1.ListSyncTasksRequest,
) (*v1.ListSyncTasksResponseData, error) <span class="cov0" title="0">{
        tasks, total, err := s.syncTaskRepo.ListWithPagination(
                ctx,
                req.Page,
                req.PageSize,
                req.TemplateID,
                req.Status,
        )
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list sync tasks", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">var list []v1.SyncTaskDetail
        for _, task := range tasks </span><span class="cov0" title="0">{
                // 查询模板名称
                template, err := s.templateRepo.GetByID(ctx, task.TemplateID)
                templateName := ""
                if err == nil &amp;&amp; template != nil </span><span class="cov0" title="0">{
                        templateName = template.TemplateName
                }</span>

                <span class="cov0" title="0">list = append(list, v1.SyncTaskDetail{
                        TaskID:       task.Id,
                        TemplateID:   task.TemplateID,
                        TemplateName: templateName,
                        SourceNode: v1.NodeInfo{
                                NodeID:   task.SourceNodeID,
                                NodeName: task.SourceNodeName,
                        },
                        TargetNode: v1.NodeInfo{
                                NodeID:   task.TargetNodeID,
                                NodeName: task.TargetNodeName,
                        },
                        StorageName:   task.StorageName,
                        Status:        task.Status,
                        Progress:      task.Progress,
                        SyncStartTime: task.SyncStartTime,
                        SyncEndTime:   task.SyncEndTime,
                        ErrorMessage:  task.ErrorMessage,
                })</span>
        }

        <span class="cov0" title="0">return &amp;v1.ListSyncTasksResponseData{
                Total: total,
                List:  list,
        }, nil</span>
}

// RetrySyncTask 重试同步任务
func (s *templateManagementService) RetrySyncTask(ctx context.Context, taskID int64) error <span class="cov0" title="0">{
        task, err := s.syncTaskRepo.GetByID(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get sync task", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if task == nil </span><span class="cov0" title="0">{
                return v1.ErrNotFound
        }</span>

        // 只有失败的任务才能重试
        <span class="cov0" title="0">if task.Status != model.TemplateSyncTaskStatusFailed </span><span class="cov0" title="0">{
                return v1.ErrInvalidOperation
        }</span>

        // 重置任务状态
        <span class="cov0" title="0">err = s.syncTaskRepo.UpdateStatus(ctx, taskID, model.TemplateSyncTaskStatusPending, 0, "")
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update task status", zap.Error(err))
                return v1.ErrInternalServerError
        }</span>

        // 将任务加入队列（串行执行）
        <span class="cov0" title="0">select </span>{
        case s.syncTaskQueue &lt;- taskID:<span class="cov0" title="0">
                s.logger.WithContext(ctx).Info("retry task queued",
                        zap.Int64("task_id", taskID))</span>
        default:<span class="cov0" title="0">
                s.logger.WithContext(ctx).Error("sync task queue is full, task may be delayed",
                        zap.Int64("task_id", taskID))
                // 队列满了，仍然尝试加入
                go func() </span><span class="cov0" title="0">{
                        s.syncTaskQueue &lt;- taskID
                }</span>()
        }

        <span class="cov0" title="0">return nil</span>
}

// ListTemplateInstances 列出模板实例
func (s *templateManagementService) ListTemplateInstances(
        ctx context.Context,
        templateID int64,
) (*v1.ListTemplateInstancesResponseData, error) <span class="cov0" title="0">{
        // 查询模板名称
        template, err := s.templateRepo.GetByID(ctx, templateID)
        if err != nil || template == nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get template", zap.Error(err))
                return nil, v1.ErrNotFound
        }</span>

        // 查询实例列表
        <span class="cov0" title="0">instances, err := s.instanceRepo.ListByTemplateID(ctx, templateID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to list instances", zap.Error(err))
                return nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">var list []v1.TemplateInstanceInfo
        for _, inst := range instances </span><span class="cov0" title="0">{
                instInfo := v1.TemplateInstanceInfo{
                        InstanceID:  inst.Id,
                        NodeID:      inst.NodeID,
                        NodeName:    inst.NodeName,
                        VMID:        inst.VMID,
                        StorageName: inst.StorageName,
                        Status:      inst.Status,
                        IsPrimary:   inst.IsPrimary == 1,
                }

                // 如果有同步任务，查询进度
                if inst.SyncTaskID != nil </span><span class="cov0" title="0">{
                        task, err := s.syncTaskRepo.GetByID(ctx, *inst.SyncTaskID)
                        if err == nil &amp;&amp; task != nil </span><span class="cov0" title="0">{
                                instInfo.SyncProgress = &amp;task.Progress
                        }</span>
                }

                <span class="cov0" title="0">list = append(list, instInfo)</span>
        }

        <span class="cov0" title="0">return &amp;v1.ListTemplateInstancesResponseData{
                TemplateID:   template.Id,
                TemplateName: template.TemplateName,
                Total:        int64(len(list)),
                Instances:    list,
        }, nil</span>
}

// ==================== 私有辅助方法 ====================

// waitForTask 等待 Proxmox 任务完成，支持进度回调
func (s *templateManagementService) waitForTask(
        ctx context.Context,
        client *proxmox.ProxmoxClient,
        nodeName string,
        upid string,
        timeout time.Duration,
        progressCallback func(progress int),
) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        ticker := time.NewTicker(2 * time.Second)
        defer ticker.Stop()

        lastProgress := 0
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("task timeout: %w", ctx.Err())</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        status, err := client.GetTaskStatus(ctx, nodeName, upid)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("failed to get task status", zap.Error(err))
                                continue</span>
                        }

                        // 尝试获取进度（部分任务可能不支持）
                        <span class="cov0" title="0">if progress, ok := status["progress"].(float64); ok &amp;&amp; progressCallback != nil </span><span class="cov0" title="0">{
                                currentProgress := int(progress * 100)
                                if currentProgress != lastProgress </span><span class="cov0" title="0">{
                                        progressCallback(currentProgress)
                                        lastProgress = currentProgress
                                }</span>
                        }

                        // 检查任务状态
                        <span class="cov0" title="0">statusStr, _ := status["status"].(string)
                        if statusStr == "stopped" </span><span class="cov0" title="0">{
                                exitStatus, _ := status["exitstatus"].(string)
                                if exitStatus == "OK" </span><span class="cov0" title="0">{
                                        return nil // 成功
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("task failed with status: %s", exitStatus)</span>
                        }
                }
        }
}

// getProxmoxClientForNode 获取指定节点的 Proxmox 客户端
func (s *templateManagementService) getProxmoxClientForNode(
        ctx context.Context,
        nodeID int64,
) (*proxmox.ProxmoxClient, *model.PveNode, error) <span class="cov0" title="0">{
        // 1. 获取节点信息
        node, err := s.nodeRepo.GetByID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get node", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("节点不存在")
        }</span>

        // 2. 获取集群信息
        <span class="cov0" title="0">if node.ClusterID &lt;= 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("节点的集群 ID 无效")
        }</span>
        <span class="cov0" title="0">cluster, err := s.clusterRepo.GetByID(ctx, node.ClusterID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get cluster", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("集群 ID %d 不存在", node.ClusterID)
        }</span>

        // 3. 创建 Proxmox 客户端
        <span class="cov0" title="0">client, err := proxmox.NewProxmoxClient(cluster.ApiUrl, cluster.UserId, cluster.UserToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to create proxmox client", zap.Error(err))
                return nil, nil, v1.ErrInternalServerError
        }</span>

        <span class="cov0" title="0">return client, node, nil</span>
}

// executeSyncTask 执行模板同步任务
// 流程：1. 在源节点克隆模板（存储保持一致） 2. 迁移到目标节点 3. 转换为模板
func (s *templateManagementService) executeSyncTask(ctx context.Context, taskID int64) <span class="cov0" title="0">{
        // 使用新的 context，避免请求 context 关闭
        ctx = context.Background()

        // 1. 获取同步任务信息
        task, err := s.syncTaskRepo.GetByID(ctx, taskID)
        if err != nil || task == nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get sync task",
                        zap.Error(err),
                        zap.Int64("task_id", taskID))
                return
        }</span>

        // 获取模板级别的锁，确保同一模板的同步任务串行执行
        <span class="cov0" title="0">lockInterface, _ := s.templateLocks.LoadOrStore(task.TemplateID, &amp;sync.Mutex{})
        templateLock := lockInterface.(*sync.Mutex)
        templateLock.Lock()
        defer templateLock.Unlock()

        // 再次检查任务状态（可能在等待锁期间被取消或完成）
        task2, err2 := s.syncTaskRepo.GetByID(ctx, taskID)
        if err2 != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get sync task after lock",
                        zap.Error(err2),
                        zap.Int64("task_id", taskID))
                return
        }</span>
        <span class="cov0" title="0">if task2 == nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("sync task not found after lock",
                        zap.Int64("task_id", taskID))
                return
        }</span>
        <span class="cov0" title="0">if task2.Status != model.TemplateSyncTaskStatusPending </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Info("task status changed, skip execution",
                        zap.Int64("task_id", taskID),
                        zap.String("status", task2.Status))
                return
        }</span>
        <span class="cov0" title="0">task = task2 // 使用最新的任务信息

        // 更新任务状态为同步中
        now := time.Now()
        task.Status = model.TemplateSyncTaskStatusSyncing
        task.SyncStartTime = &amp;now
        task.Progress = 0
        if err := s.syncTaskRepo.Update(ctx, task); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update task status to syncing", zap.Error(err))
        }</span>

        // 2. 获取模板信息（用于生成同步后的虚拟机名称）
        <span class="cov0" title="0">template, err := s.templateRepo.GetByID(ctx, task.TemplateID)
        if err != nil || template == nil </span><span class="cov0" title="0">{
                errorMsg := "failed to get template"
                if err != nil </span><span class="cov0" title="0">{
                        errorMsg = err.Error()
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Error("failed to get template",
                        zap.Error(err),
                        zap.Int64("template_id", task.TemplateID))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                return</span>
        }

        // 生成同步后的虚拟机名称：sync-{template_name}-{task_id}
        <span class="cov0" title="0">syncVMName := fmt.Sprintf("sync-%s-%d", template.TemplateName, taskID)

        // 3. 获取源节点的主实例（primary instance）的 VMID
        primaryInstance, err := s.instanceRepo.GetPrimaryInstance(ctx, task.TemplateID)
        if err != nil || primaryInstance == nil </span><span class="cov0" title="0">{
                errorMsg := "failed to get primary instance"
                if err != nil </span><span class="cov0" title="0">{
                        errorMsg = err.Error()
                }</span>
                <span class="cov0" title="0">s.logger.WithContext(ctx).Error("failed to get primary instance",
                        zap.Error(err),
                        zap.Int64("template_id", task.TemplateID))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                return</span>
        }

        <span class="cov0" title="0">if primaryInstance.VMID == 0 </span><span class="cov0" title="0">{
                errorMsg := "primary instance VMID is 0"
                s.logger.WithContext(ctx).Error(errorMsg, zap.Int64("instance_id", primaryInstance.Id))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                return
        }</span>

        // 4. 获取源节点和目标节点的 Proxmox 客户端
        <span class="cov0" title="0">sourceClient, sourceNode, err := s.getProxmoxClientForNode(ctx, task.SourceNodeID)
        if err != nil </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("failed to get source node client: %v", err)
                s.logger.WithContext(ctx).Error(errorMsg, zap.Error(err))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                return
        }</span>

        <span class="cov0" title="0">targetClient, targetNode, err := s.getProxmoxClientForNode(ctx, task.TargetNodeID)
        if err != nil </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("failed to get target node client: %v", err)
                s.logger.WithContext(ctx).Error(errorMsg, zap.Error(err))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                return
        }</span>

        // 5. 分配新的 VMID（用于克隆的临时 VM）
        <span class="cov0" title="0">newVMID, err := sourceClient.GetNextFreeVMID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("failed to get next free vmid: %v", err)
                s.logger.WithContext(ctx).Error(errorMsg, zap.Error(err))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                return
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("starting template sync",
                zap.Int64("task_id", taskID),
                zap.Uint32("source_vmid", primaryInstance.VMID),
                zap.Uint32("new_vmid", newVMID),
                zap.String("source_node", sourceNode.NodeName),
                zap.String("target_node", targetNode.NodeName))

        // 6. 在源节点克隆模板（不指定 target，存储保持一致）
        // 注意：不指定 storage 参数，保持与原模板相同的存储
        cloneReq := &amp;proxmox.CloneVMRequest{
                NewID:       newVMID,
                Name:        syncVMName, // 使用模板名称生成：sync-{template_name}
                Target:      "",         // 不指定 target，在同一节点克隆
                Full:        1,          // 完整克隆
                Storage:     "",         // 不指定 storage，保持原存储
                Description: fmt.Sprintf("Template sync VM: %s", template.TemplateName),
        }

        cloneUPID, err := sourceClient.CloneVM(ctx, sourceNode.NodeName, primaryInstance.VMID, cloneReq)
        if err != nil </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("failed to clone template: %v", err)
                s.logger.WithContext(ctx).Error(errorMsg, zap.Error(err))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                return
        }</span>

        // 等待克隆任务完成
        <span class="cov0" title="0">task.Progress = 20
        _ = s.syncTaskRepo.Update(ctx, task)

        err = s.waitForTask(ctx, sourceClient, sourceNode.NodeName, cloneUPID, 30*time.Minute, func(progress int) </span><span class="cov0" title="0">{
                // 克隆进度：0-50%
                overallProgress := 10 + (progress * 40 / 100)
                task.Progress = overallProgress
                _ = s.syncTaskRepo.Update(ctx, task)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("clone task failed: %v", err)
                s.logger.WithContext(ctx).Error(errorMsg, zap.Error(err))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                // 清理：删除克隆失败的临时 VM
                _ = sourceClient.DeleteVM(ctx, sourceNode.NodeName, newVMID, true)
                return
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("clone completed",
                zap.Uint32("new_vmid", newVMID),
                zap.String("source_node", sourceNode.NodeName))

        // 6. 迁移克隆的 VM 到目标节点
        task.Progress = 50
        task.Status = model.TemplateSyncTaskStatusImporting
        _ = s.syncTaskRepo.Update(ctx, task)

        migrateParams := map[string]interface{}{
                "target":  targetNode.NodeName,
                "online":  false, // 离线迁移（模板通常是停止状态）
                "storage": "",    // 不指定 storage，使用目标节点的默认存储
        }

        migrateUPID, err := sourceClient.MigrateVM(ctx, sourceNode.NodeName, newVMID, migrateParams)
        if err != nil </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("failed to migrate VM: %v", err)
                s.logger.WithContext(ctx).Error(errorMsg, zap.Error(err))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                // 清理：删除克隆的临时 VM
                _ = sourceClient.DeleteVM(ctx, sourceNode.NodeName, newVMID, true)
                return
        }</span>

        // 等待迁移任务完成
        <span class="cov0" title="0">err = s.waitForTask(ctx, sourceClient, sourceNode.NodeName, migrateUPID, 60*time.Minute, func(progress int) </span><span class="cov0" title="0">{
                // 迁移进度：50-90%
                overallProgress := 50 + (progress * 40 / 100)
                task.Progress = overallProgress
                _ = s.syncTaskRepo.Update(ctx, task)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("migrate task failed: %v", err)
                s.logger.WithContext(ctx).Error(errorMsg, zap.Error(err))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                // 清理：尝试删除目标节点上的 VM（如果迁移部分成功）
                _ = targetClient.DeleteVM(ctx, targetNode.NodeName, newVMID, true)
                return
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("migration completed",
                zap.Uint32("vmid", newVMID),
                zap.String("target_node", targetNode.NodeName))

        // 7. 在目标节点转换为模板
        task.Progress = 90
        _ = s.syncTaskRepo.Update(ctx, task)

        err = targetClient.ConvertToTemplate(ctx, targetNode.NodeName, newVMID, "")
        if err != nil </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("failed to convert to template: %v", err)
                s.logger.WithContext(ctx).Error(errorMsg, zap.Error(err))
                task.Status = model.TemplateSyncTaskStatusFailed
                task.ErrorMessage = errorMsg
                _ = s.syncTaskRepo.Update(ctx, task)
                // 清理：删除目标节点上的 VM
                _ = targetClient.DeleteVM(ctx, targetNode.NodeName, newVMID, true)
                return
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("template conversion completed",
                zap.Uint32("vmid", newVMID),
                zap.String("target_node", targetNode.NodeName))

        // 7.1 清理数据库中可能存在的临时虚拟机记录（脏数据清理），并确保模板记录正确
        // 因为临时虚拟机在迁移和转换过程中可能被上报系统捕获，导致数据库中有普通虚拟机记录
        // 但实际在 Proxmox 中已经是模板了，需要清理这些脏数据
        // 同时，如果数据库中还没有记录，可以通过 GetVMConfig 确认后创建正确的模板记录
        if err := s.cleanupAndEnsureTemplateRecord(ctx, targetNode, newVMID, syncVMName); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Warn("failed to cleanup/ensure template record",
                        zap.Error(err),
                        zap.Uint32("vmid", newVMID),
                        zap.Int64("node_id", targetNode.Id))
                // 不中断流程，只记录警告
        }</span>

        // 8. 更新实例状态
        <span class="cov0" title="0">instance, err := s.instanceRepo.GetByTemplateAndNode(ctx, task.TemplateID, task.TargetNodeID)
        if err != nil || instance == nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to get target instance",
                        zap.Error(err),
                        zap.Int64("template_id", task.TemplateID),
                        zap.Int64("target_node_id", task.TargetNodeID))
        }</span> else<span class="cov0" title="0"> {
                instance.VMID = newVMID
                instance.Status = model.TemplateInstanceStatusAvailable
                if err := s.instanceRepo.Update(ctx, instance); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Error("failed to update instance",
                                zap.Error(err),
                                zap.Int64("instance_id", instance.Id))
                }</span>
        }

        // 9. 更新同步任务状态为完成
        <span class="cov0" title="0">task.Progress = 100
        task.Status = model.TemplateSyncTaskStatusCompleted
        endTime := time.Now()
        task.SyncEndTime = &amp;endTime
        task.ErrorMessage = ""
        if err := s.syncTaskRepo.Update(ctx, task); err != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Error("failed to update task status to completed", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("template sync task completed successfully",
                zap.Int64("task_id", taskID),
                zap.Uint32("vmid", newVMID),
                zap.String("target_node", targetNode.NodeName))</span>
}

// cleanupAndEnsureTemplateRecord 清理临时虚拟机的脏数据并确保模板记录正确
// 1. 如果数据库中存在 isTemplate=0 的记录，删除它（脏数据清理）
// 2. 通过 GetVMConfig 确认 Proxmox 中确实是模板后，创建正确的模板记录
// 这样确保数据库记录与实际状态一致，即使上报系统还没上报
func (s *templateManagementService) cleanupAndEnsureTemplateRecord(
        ctx context.Context,
        node *model.PveNode,
        vmid uint32,
        vmName string,
) error <span class="cov0" title="0">{
        // 1. 查找数据库中是否存在该 VMID 和 NodeID 的记录
        vm, err := s.vmRepo.GetByVMID(ctx, vmid, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get vm record: %w", err)
        }</span>

        // 2. 获取 Proxmox 客户端，用于查询 VM 配置确认是否为模板
        <span class="cov0" title="0">client, _, err := s.getProxmoxClientForNode(ctx, node.Id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get proxmox client: %w", err)
        }</span>

        // 3. 通过 GetVMConfig 确认 Proxmox 中的真实状态
        <span class="cov0" title="0">vmConfig, err := client.GetVMCurrentConfig(ctx, node.NodeName, vmid)
        if err != nil </span><span class="cov0" title="0">{
                // 如果获取配置失败，只清理脏数据，不创建新记录
                s.logger.WithContext(ctx).Warn("failed to get vm config for template verification",
                        zap.Error(err),
                        zap.Uint32("vmid", vmid),
                        zap.String("node", node.NodeName))

                // 只执行清理逻辑
                if vm != nil &amp;&amp; vm.IsTemplate == 0 </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Info("cleaning up temp vm record (cannot verify template status)",
                                zap.Uint32("vmid", vmid),
                                zap.Int64("node_id", node.Id))
                        return s.vmRepo.Delete(ctx, vm.Id)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // 4. 检查配置中的 template 字段，确认是否为模板
        <span class="cov0" title="0">isTemplateInProxmox := false
        if templateVal, ok := vmConfig["template"]; ok </span><span class="cov0" title="0">{
                // template 字段可能是 1, "1", 或者 boolean true
                switch v := templateVal.(type) </span>{
                case int:<span class="cov0" title="0">
                        isTemplateInProxmox = v == 1</span>
                case int64:<span class="cov0" title="0">
                        isTemplateInProxmox = v == 1</span>
                case float64:<span class="cov0" title="0">
                        isTemplateInProxmox = v == 1</span>
                case string:<span class="cov0" title="0">
                        isTemplateInProxmox = v == "1" || v == "true"</span>
                case bool:<span class="cov0" title="0">
                        isTemplateInProxmox = v</span>
                }
        }

        // 5. 如果 Proxmox 中确实是模板
        <span class="cov0" title="0">if isTemplateInProxmox </span><span class="cov0" title="0">{
                // 5.1 如果数据库中有 isTemplate=0 的记录，删除它（脏数据）
                if vm != nil &amp;&amp; vm.IsTemplate == 0 </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Info("cleaning up temp vm record that was converted to template",
                                zap.Uint32("vmid", vmid),
                                zap.Int64("node_id", node.Id),
                                zap.String("vm_name", vm.VmName),
                                zap.Int64("vm_db_id", vm.Id))

                        if err := s.vmRepo.Delete(ctx, vm.Id); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete temp vm record: %w", err)
                        }</span>

                        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("temp vm record cleaned up successfully",
                                zap.Uint32("vmid", vmid),
                                zap.Int64("node_id", node.Id))</span>
                }

                // 5.2 如果数据库中没有记录或记录不正确，创建正确的模板记录
                // 这样即使上报系统还没上报，也能确保数据库中有正确的记录
                <span class="cov0" title="0">if vm == nil || vm.IsTemplate == 0 </span><span class="cov0" title="0">{
                        // 获取集群信息（用于创建记录）
                        cluster, err := s.clusterRepo.GetByID(ctx, node.ClusterID)
                        if err != nil || cluster == nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Warn("failed to get cluster for template record creation",
                                        zap.Error(err),
                                        zap.Int64("cluster_id", node.ClusterID))
                                return nil // 不中断，让上报系统后续处理
                        }</span>

                        // 从配置中提取其他信息
                        <span class="cov0" title="0">cpuNum := 0
                        memorySize := 0
                        if cpu, ok := vmConfig["cores"]; ok </span><span class="cov0" title="0">{
                                if cpuInt, ok := cpu.(float64); ok </span><span class="cov0" title="0">{
                                        cpuNum = int(cpuInt)
                                }</span>
                        }
                        <span class="cov0" title="0">if memory, ok := vmConfig["memory"]; ok </span><span class="cov0" title="0">{
                                if memInt, ok := memory.(float64); ok </span><span class="cov0" title="0">{
                                        memorySize = int(memInt) // MB
                                }</span>
                        }

                        // 创建模板记录
                        <span class="cov0" title="0">templateVM := &amp;model.PveVM{
                                VMID:         vmid,
                                VmName:       vmName,
                                NodeID:       node.Id,
                                ClusterID:    node.ClusterID,
                                IsTemplate:   1,         // 标记为模板
                                Status:       "stopped", // 模板通常是停止状态
                                CPUNum:       cpuNum,
                                MemorySize:   memorySize,
                                CreateTime:   time.Now(),
                                UpdateTime:   time.Now(),
                                LastSyncTime: time.Now(),
                        }

                        // 计算资源 hash
                        resourceHash, err := s.calculateVMResourceHash(templateVM)
                        if err == nil </span><span class="cov0" title="0">{
                                templateVM.ResourceHash = resourceHash
                        }</span>

                        // 使用 Upsert 创建或更新记录
                        <span class="cov0" title="0">if err := s.vmRepo.Upsert(ctx, templateVM); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithContext(ctx).Warn("failed to create template record",
                                        zap.Error(err),
                                        zap.Uint32("vmid", vmid))
                                return nil // 不中断，让上报系统后续处理
                        }</span>

                        <span class="cov0" title="0">s.logger.WithContext(ctx).Info("template record created/updated successfully",
                                zap.Uint32("vmid", vmid),
                                zap.String("vm_name", vmName),
                                zap.Int64("node_id", node.Id))</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// calculateVMResourceHash 计算虚拟机的资源 hash（简化版本）
func (s *templateManagementService) calculateVMResourceHash(vm *model.PveVM) (string, error) <span class="cov0" title="0">{
        // 使用简单的 hash 计算（实际应该使用 pkg/hash 包，但这里为了简化直接使用 md5）
        hashStr := fmt.Sprintf("%d-%d-%d-%d-%s-%d",
                vm.VMID, vm.NodeID, vm.CPUNum, vm.MemorySize, vm.Status, vm.IsTemplate)

        hashBytes := md5.Sum([]byte(hashStr))
        return fmt.Sprintf("%x", hashBytes), nil
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package service

import (
        "context"
        v1 "pvesphere/api/v1"
        "pvesphere/internal/model"
        "pvesphere/internal/repository"
        "golang.org/x/crypto/bcrypt"
        "time"
)

type UserService interface {
        Register(ctx context.Context, req *v1.RegisterRequest) error
        Login(ctx context.Context, req *v1.LoginRequest) (string, error)
        GetProfile(ctx context.Context, userId string) (*v1.GetProfileResponseData, error)
        UpdateProfile(ctx context.Context, userId string, req *v1.UpdateProfileRequest) error
}

func NewUserService(
        service *Service,
        userRepo repository.UserRepository,
) UserService <span class="cov8" title="1">{
        return &amp;userService{
                userRepo: userRepo,
                Service:  service,
        }
}</span>

type userService struct {
        userRepo repository.UserRepository
        *Service
}

func (s *userService) Register(ctx context.Context, req *v1.RegisterRequest) error <span class="cov8" title="1">{
        // check username
        user, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return v1.ErrInternalServerError
        }</span>
        <span class="cov8" title="1">if err == nil &amp;&amp; user != nil </span><span class="cov8" title="1">{
                return v1.ErrEmailAlreadyUse
        }</span>

        <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Generate user ID
        <span class="cov8" title="1">userId, err := s.sid.GenString()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">user = &amp;model.User{
                UserId:   userId,
                Email:    req.Email,
                Password: string(hashedPassword),
        }
        // Transaction demo
        err = s.tm.Transaction(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                // Create a user
                if err = s.userRepo.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // TODO: other repo
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov8" title="1">return err</span>
}

func (s *userService) Login(ctx context.Context, req *v1.LoginRequest) (string, error) <span class="cov8" title="1">{
        user, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err != nil || user == nil </span><span class="cov8" title="1">{
                return "", v1.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">token, err := s.jwt.GenToken(user.UserId, time.Now().Add(time.Hour*24*90))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (s *userService) GetProfile(ctx context.Context, userId string) (*v1.GetProfileResponseData, error) <span class="cov8" title="1">{
        if userId == "" </span><span class="cov0" title="0">{
                return nil, v1.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">user, err := s.userRepo.GetByID(ctx, userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;v1.GetProfileResponseData{
                UserId:   user.UserId,
                Email:    user.Email,
                Nickname: user.Nickname,
        }, nil</span>
}

func (s *userService) UpdateProfile(ctx context.Context, userId string, req *v1.UpdateProfileRequest) error <span class="cov8" title="1">{
        user, err := s.userRepo.GetByID(ctx, userId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 更新昵称
        <span class="cov8" title="1">if req.Nickname != "" </span><span class="cov8" title="1">{
                user.Nickname = req.Nickname
        }</span>

        // 更新密码（如果提供了旧密码和新密码）
        <span class="cov8" title="1">if req.OldPassword != "" &amp;&amp; req.NewPassword != "" </span><span class="cov0" title="0">{
                // 验证旧密码
                err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.OldPassword))
                if err != nil </span><span class="cov0" title="0">{
                        return v1.ErrUnauthorized
                }</span>

                // 加密新密码
                <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">user.Password = string(hashedPassword)</span>
        }

        <span class="cov8" title="1">if err = s.userRepo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
